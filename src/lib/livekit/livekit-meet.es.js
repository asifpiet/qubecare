var t5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function mP(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var kT = { exports: {} }, sv = {}, TT = { exports: {} }, Bt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __;
function n5() {
  if (__)
    return Bt;
  __ = 1;
  var r = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), c = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), b = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), E = Symbol.iterator;
  function x(Y) {
    return Y === null || typeof Y != "object" ? null : (Y = E && Y[E] || Y["@@iterator"], typeof Y == "function" ? Y : null);
  }
  var O = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, N = Object.assign, M = {};
  function I(Y, ge, lt) {
    this.props = Y, this.context = ge, this.refs = M, this.updater = lt || O;
  }
  I.prototype.isReactComponent = {}, I.prototype.setState = function(Y, ge) {
    if (typeof Y != "object" && typeof Y != "function" && Y != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, Y, ge, "setState");
  }, I.prototype.forceUpdate = function(Y) {
    this.updater.enqueueForceUpdate(this, Y, "forceUpdate");
  };
  function U() {
  }
  U.prototype = I.prototype;
  function ae(Y, ge, lt) {
    this.props = Y, this.context = ge, this.refs = M, this.updater = lt || O;
  }
  var Z = ae.prototype = new U();
  Z.constructor = ae, N(Z, I.prototype), Z.isPureReactComponent = !0;
  var B = Array.isArray, F = Object.prototype.hasOwnProperty, K = { current: null }, te = { key: !0, ref: !0, __self: !0, __source: !0 };
  function he(Y, ge, lt) {
    var Be, kt = {}, Rt = null, Ft = null;
    if (ge != null)
      for (Be in ge.ref !== void 0 && (Ft = ge.ref), ge.key !== void 0 && (Rt = "" + ge.key), ge)
        F.call(ge, Be) && !te.hasOwnProperty(Be) && (kt[Be] = ge[Be]);
    var Dt = arguments.length - 2;
    if (Dt === 1)
      kt.children = lt;
    else if (1 < Dt) {
      for (var Ot = Array(Dt), yn = 0; yn < Dt; yn++)
        Ot[yn] = arguments[yn + 2];
      kt.children = Ot;
    }
    if (Y && Y.defaultProps)
      for (Be in Dt = Y.defaultProps, Dt)
        kt[Be] === void 0 && (kt[Be] = Dt[Be]);
    return { $$typeof: r, type: Y, key: Rt, ref: Ft, props: kt, _owner: K.current };
  }
  function pe(Y, ge) {
    return { $$typeof: r, type: Y.type, key: ge, ref: Y.ref, props: Y.props, _owner: Y._owner };
  }
  function ye(Y) {
    return typeof Y == "object" && Y !== null && Y.$$typeof === r;
  }
  function se(Y) {
    var ge = { "=": "=0", ":": "=2" };
    return "$" + Y.replace(/[=:]/g, function(lt) {
      return ge[lt];
    });
  }
  var Ee = /\/+/g;
  function Ne(Y, ge) {
    return typeof Y == "object" && Y !== null && Y.key != null ? se("" + Y.key) : ge.toString(36);
  }
  function Je(Y, ge, lt, Be, kt) {
    var Rt = typeof Y;
    (Rt === "undefined" || Rt === "boolean") && (Y = null);
    var Ft = !1;
    if (Y === null)
      Ft = !0;
    else
      switch (Rt) {
        case "string":
        case "number":
          Ft = !0;
          break;
        case "object":
          switch (Y.$$typeof) {
            case r:
            case t:
              Ft = !0;
          }
      }
    if (Ft)
      return Ft = Y, kt = kt(Ft), Y = Be === "" ? "." + Ne(Ft, 0) : Be, B(kt) ? (lt = "", Y != null && (lt = Y.replace(Ee, "$&/") + "/"), Je(kt, ge, lt, "", function(yn) {
        return yn;
      })) : kt != null && (ye(kt) && (kt = pe(kt, lt + (!kt.key || Ft && Ft.key === kt.key ? "" : ("" + kt.key).replace(Ee, "$&/") + "/") + Y)), ge.push(kt)), 1;
    if (Ft = 0, Be = Be === "" ? "." : Be + ":", B(Y))
      for (var Dt = 0; Dt < Y.length; Dt++) {
        Rt = Y[Dt];
        var Ot = Be + Ne(Rt, Dt);
        Ft += Je(Rt, ge, lt, Ot, kt);
      }
    else if (Ot = x(Y), typeof Ot == "function")
      for (Y = Ot.call(Y), Dt = 0; !(Rt = Y.next()).done; )
        Rt = Rt.value, Ot = Be + Ne(Rt, Dt++), Ft += Je(Rt, ge, lt, Ot, kt);
    else if (Rt === "object")
      throw ge = String(Y), Error("Objects are not valid as a React child (found: " + (ge === "[object Object]" ? "object with keys {" + Object.keys(Y).join(", ") + "}" : ge) + "). If you meant to render a collection of children, use an array instead.");
    return Ft;
  }
  function vt(Y, ge, lt) {
    if (Y == null)
      return Y;
    var Be = [], kt = 0;
    return Je(Y, Be, "", "", function(Rt) {
      return ge.call(lt, Rt, kt++);
    }), Be;
  }
  function Ct(Y) {
    if (Y._status === -1) {
      var ge = Y._result;
      ge = ge(), ge.then(function(lt) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 1, Y._result = lt);
      }, function(lt) {
        (Y._status === 0 || Y._status === -1) && (Y._status = 2, Y._result = lt);
      }), Y._status === -1 && (Y._status = 0, Y._result = ge);
    }
    if (Y._status === 1)
      return Y._result.default;
    throw Y._result;
  }
  var Me = { current: null }, Pe = { transition: null }, Ze = { ReactCurrentDispatcher: Me, ReactCurrentBatchConfig: Pe, ReactCurrentOwner: K };
  function Ie() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Bt.Children = { map: vt, forEach: function(Y, ge, lt) {
    vt(Y, function() {
      ge.apply(this, arguments);
    }, lt);
  }, count: function(Y) {
    var ge = 0;
    return vt(Y, function() {
      ge++;
    }), ge;
  }, toArray: function(Y) {
    return vt(Y, function(ge) {
      return ge;
    }) || [];
  }, only: function(Y) {
    if (!ye(Y))
      throw Error("React.Children.only expected to receive a single React element child.");
    return Y;
  } }, Bt.Component = I, Bt.Fragment = i, Bt.Profiler = u, Bt.PureComponent = ae, Bt.StrictMode = o, Bt.Suspense = g, Bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ze, Bt.act = Ie, Bt.cloneElement = function(Y, ge, lt) {
    if (Y == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + Y + ".");
    var Be = N({}, Y.props), kt = Y.key, Rt = Y.ref, Ft = Y._owner;
    if (ge != null) {
      if (ge.ref !== void 0 && (Rt = ge.ref, Ft = K.current), ge.key !== void 0 && (kt = "" + ge.key), Y.type && Y.type.defaultProps)
        var Dt = Y.type.defaultProps;
      for (Ot in ge)
        F.call(ge, Ot) && !te.hasOwnProperty(Ot) && (Be[Ot] = ge[Ot] === void 0 && Dt !== void 0 ? Dt[Ot] : ge[Ot]);
    }
    var Ot = arguments.length - 2;
    if (Ot === 1)
      Be.children = lt;
    else if (1 < Ot) {
      Dt = Array(Ot);
      for (var yn = 0; yn < Ot; yn++)
        Dt[yn] = arguments[yn + 2];
      Be.children = Dt;
    }
    return { $$typeof: r, type: Y.type, key: kt, ref: Rt, props: Be, _owner: Ft };
  }, Bt.createContext = function(Y) {
    return Y = { $$typeof: c, _currentValue: Y, _currentValue2: Y, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, Y.Provider = { $$typeof: d, _context: Y }, Y.Consumer = Y;
  }, Bt.createElement = he, Bt.createFactory = function(Y) {
    var ge = he.bind(null, Y);
    return ge.type = Y, ge;
  }, Bt.createRef = function() {
    return { current: null };
  }, Bt.forwardRef = function(Y) {
    return { $$typeof: m, render: Y };
  }, Bt.isValidElement = ye, Bt.lazy = function(Y) {
    return { $$typeof: C, _payload: { _status: -1, _result: Y }, _init: Ct };
  }, Bt.memo = function(Y, ge) {
    return { $$typeof: b, type: Y, compare: ge === void 0 ? null : ge };
  }, Bt.startTransition = function(Y) {
    var ge = Pe.transition;
    Pe.transition = {};
    try {
      Y();
    } finally {
      Pe.transition = ge;
    }
  }, Bt.unstable_act = Ie, Bt.useCallback = function(Y, ge) {
    return Me.current.useCallback(Y, ge);
  }, Bt.useContext = function(Y) {
    return Me.current.useContext(Y);
  }, Bt.useDebugValue = function() {
  }, Bt.useDeferredValue = function(Y) {
    return Me.current.useDeferredValue(Y);
  }, Bt.useEffect = function(Y, ge) {
    return Me.current.useEffect(Y, ge);
  }, Bt.useId = function() {
    return Me.current.useId();
  }, Bt.useImperativeHandle = function(Y, ge, lt) {
    return Me.current.useImperativeHandle(Y, ge, lt);
  }, Bt.useInsertionEffect = function(Y, ge) {
    return Me.current.useInsertionEffect(Y, ge);
  }, Bt.useLayoutEffect = function(Y, ge) {
    return Me.current.useLayoutEffect(Y, ge);
  }, Bt.useMemo = function(Y, ge) {
    return Me.current.useMemo(Y, ge);
  }, Bt.useReducer = function(Y, ge, lt) {
    return Me.current.useReducer(Y, ge, lt);
  }, Bt.useRef = function(Y) {
    return Me.current.useRef(Y);
  }, Bt.useState = function(Y) {
    return Me.current.useState(Y);
  }, Bt.useSyncExternalStore = function(Y, ge, lt) {
    return Me.current.useSyncExternalStore(Y, ge, lt);
  }, Bt.useTransition = function() {
    return Me.current.useTransition();
  }, Bt.version = "18.3.1", Bt;
}
var mv = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
mv.exports;
var x_;
function r5() {
  return x_ || (x_ = 1, function(r, t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var i = "18.3.1", o = Symbol.for("react.element"), u = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), m = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), b = Symbol.for("react.context"), C = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), x = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), N = Symbol.for("react.lazy"), M = Symbol.for("react.offscreen"), I = Symbol.iterator, U = "@@iterator";
      function ae(P) {
        if (P === null || typeof P != "object")
          return null;
        var z = I && P[I] || P[U];
        return typeof z == "function" ? z : null;
      }
      var Z = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, B = {
        transition: null
      }, F = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, K = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, te = {}, he = null;
      function pe(P) {
        he = P;
      }
      te.setExtraStackFrame = function(P) {
        he = P;
      }, te.getCurrentStack = null, te.getStackAddendum = function() {
        var P = "";
        he && (P += he);
        var z = te.getCurrentStack;
        return z && (P += z() || ""), P;
      };
      var ye = !1, se = !1, Ee = !1, Ne = !1, Je = !1, vt = {
        ReactCurrentDispatcher: Z,
        ReactCurrentBatchConfig: B,
        ReactCurrentOwner: K
      };
      vt.ReactDebugCurrentFrame = te, vt.ReactCurrentActQueue = F;
      function Ct(P) {
        {
          for (var z = arguments.length, ie = new Array(z > 1 ? z - 1 : 0), de = 1; de < z; de++)
            ie[de - 1] = arguments[de];
          Pe("warn", P, ie);
        }
      }
      function Me(P) {
        {
          for (var z = arguments.length, ie = new Array(z > 1 ? z - 1 : 0), de = 1; de < z; de++)
            ie[de - 1] = arguments[de];
          Pe("error", P, ie);
        }
      }
      function Pe(P, z, ie) {
        {
          var de = vt.ReactDebugCurrentFrame, De = de.getStackAddendum();
          De !== "" && (z += "%s", ie = ie.concat([De]));
          var ft = ie.map(function(je) {
            return String(je);
          });
          ft.unshift("Warning: " + z), Function.prototype.apply.call(console[P], console, ft);
        }
      }
      var Ze = {};
      function Ie(P, z) {
        {
          var ie = P.constructor, de = ie && (ie.displayName || ie.name) || "ReactClass", De = de + "." + z;
          if (Ze[De])
            return;
          Me("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", z, de), Ze[De] = !0;
        }
      }
      var Y = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(P) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(P, z, ie) {
          Ie(P, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(P, z, ie, de) {
          Ie(P, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(P, z, ie, de) {
          Ie(P, "setState");
        }
      }, ge = Object.assign, lt = {};
      Object.freeze(lt);
      function Be(P, z, ie) {
        this.props = P, this.context = z, this.refs = lt, this.updater = ie || Y;
      }
      Be.prototype.isReactComponent = {}, Be.prototype.setState = function(P, z) {
        if (typeof P != "object" && typeof P != "function" && P != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, P, z, "setState");
      }, Be.prototype.forceUpdate = function(P) {
        this.updater.enqueueForceUpdate(this, P, "forceUpdate");
      };
      {
        var kt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Rt = function(P, z) {
          Object.defineProperty(Be.prototype, P, {
            get: function() {
              Ct("%s(...) is deprecated in plain JavaScript React classes. %s", z[0], z[1]);
            }
          });
        };
        for (var Ft in kt)
          kt.hasOwnProperty(Ft) && Rt(Ft, kt[Ft]);
      }
      function Dt() {
      }
      Dt.prototype = Be.prototype;
      function Ot(P, z, ie) {
        this.props = P, this.context = z, this.refs = lt, this.updater = ie || Y;
      }
      var yn = Ot.prototype = new Dt();
      yn.constructor = Ot, ge(yn, Be.prototype), yn.isPureReactComponent = !0;
      function Vr() {
        var P = {
          current: null
        };
        return Object.seal(P), P;
      }
      var yi = Array.isArray;
      function Nn(P) {
        return yi(P);
      }
      function yr(P) {
        {
          var z = typeof Symbol == "function" && Symbol.toStringTag, ie = z && P[Symbol.toStringTag] || P.constructor.name || "Object";
          return ie;
        }
      }
      function ur(P) {
        try {
          return er(P), !1;
        } catch {
          return !0;
        }
      }
      function er(P) {
        return "" + P;
      }
      function Yn(P) {
        if (ur(P))
          return Me("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", yr(P)), er(P);
      }
      function bi(P, z, ie) {
        var de = P.displayName;
        if (de)
          return de;
        var De = z.displayName || z.name || "";
        return De !== "" ? ie + "(" + De + ")" : ie;
      }
      function Si(P) {
        return P.displayName || "Context";
      }
      function br(P) {
        if (P == null)
          return null;
        if (typeof P.tag == "number" && Me("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
          return P.displayName || P.name || null;
        if (typeof P == "string")
          return P;
        switch (P) {
          case d:
            return "Fragment";
          case u:
            return "Portal";
          case m:
            return "Profiler";
          case c:
            return "StrictMode";
          case E:
            return "Suspense";
          case x:
            return "SuspenseList";
        }
        if (typeof P == "object")
          switch (P.$$typeof) {
            case b:
              var z = P;
              return Si(z) + ".Consumer";
            case g:
              var ie = P;
              return Si(ie._context) + ".Provider";
            case C:
              return bi(P, P.render, "ForwardRef");
            case O:
              var de = P.displayName || null;
              return de !== null ? de : br(P.type) || "Memo";
            case N: {
              var De = P, ft = De._payload, je = De._init;
              try {
                return br(je(ft));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Br = Object.prototype.hasOwnProperty, Ci = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Hr, qi, xr;
      xr = {};
      function ki(P) {
        if (Br.call(P, "ref")) {
          var z = Object.getOwnPropertyDescriptor(P, "ref").get;
          if (z && z.isReactWarning)
            return !1;
        }
        return P.ref !== void 0;
      }
      function Ln(P) {
        if (Br.call(P, "key")) {
          var z = Object.getOwnPropertyDescriptor(P, "key").get;
          if (z && z.isReactWarning)
            return !1;
        }
        return P.key !== void 0;
      }
      function Zr(P, z) {
        var ie = function() {
          Hr || (Hr = !0, Me("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        ie.isReactWarning = !0, Object.defineProperty(P, "key", {
          get: ie,
          configurable: !0
        });
      }
      function eo(P, z) {
        var ie = function() {
          qi || (qi = !0, Me("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        ie.isReactWarning = !0, Object.defineProperty(P, "ref", {
          get: ie,
          configurable: !0
        });
      }
      function Wi(P) {
        if (typeof P.ref == "string" && K.current && P.__self && K.current.stateNode !== P.__self) {
          var z = br(K.current.type);
          xr[z] || (Me('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z, P.ref), xr[z] = !0);
        }
      }
      var Ae = function(P, z, ie, de, De, ft, je) {
        var ct = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: o,
          // Built-in properties that belong on the element
          type: P,
          key: z,
          ref: ie,
          props: je,
          // Record the component responsible for creating this element.
          _owner: ft
        };
        return ct._store = {}, Object.defineProperty(ct._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(ct, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: de
        }), Object.defineProperty(ct, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: De
        }), Object.freeze && (Object.freeze(ct.props), Object.freeze(ct)), ct;
      };
      function at(P, z, ie) {
        var de, De = {}, ft = null, je = null, ct = null, Lt = null;
        if (z != null) {
          ki(z) && (je = z.ref, Wi(z)), Ln(z) && (Yn(z.key), ft = "" + z.key), ct = z.__self === void 0 ? null : z.__self, Lt = z.__source === void 0 ? null : z.__source;
          for (de in z)
            Br.call(z, de) && !Ci.hasOwnProperty(de) && (De[de] = z[de]);
        }
        var Gt = arguments.length - 2;
        if (Gt === 1)
          De.children = ie;
        else if (Gt > 1) {
          for (var mn = Array(Gt), dn = 0; dn < Gt; dn++)
            mn[dn] = arguments[dn + 2];
          Object.freeze && Object.freeze(mn), De.children = mn;
        }
        if (P && P.defaultProps) {
          var vn = P.defaultProps;
          for (de in vn)
            De[de] === void 0 && (De[de] = vn[de]);
        }
        if (ft || je) {
          var bn = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
          ft && Zr(De, bn), je && eo(De, bn);
        }
        return Ae(P, ft, je, ct, Lt, K.current, De);
      }
      function _t(P, z) {
        var ie = Ae(P.type, z, P.ref, P._self, P._source, P._owner, P.props);
        return ie;
      }
      function en(P, z, ie) {
        if (P == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + P + ".");
        var de, De = ge({}, P.props), ft = P.key, je = P.ref, ct = P._self, Lt = P._source, Gt = P._owner;
        if (z != null) {
          ki(z) && (je = z.ref, Gt = K.current), Ln(z) && (Yn(z.key), ft = "" + z.key);
          var mn;
          P.type && P.type.defaultProps && (mn = P.type.defaultProps);
          for (de in z)
            Br.call(z, de) && !Ci.hasOwnProperty(de) && (z[de] === void 0 && mn !== void 0 ? De[de] = mn[de] : De[de] = z[de]);
        }
        var dn = arguments.length - 2;
        if (dn === 1)
          De.children = ie;
        else if (dn > 1) {
          for (var vn = Array(dn), bn = 0; bn < dn; bn++)
            vn[bn] = arguments[bn + 2];
          De.children = vn;
        }
        return Ae(P.type, ft, je, ct, Lt, Gt, De);
      }
      function rn(P) {
        return typeof P == "object" && P !== null && P.$$typeof === o;
      }
      var Kn = ".", An = ":";
      function $r(P) {
        var z = /[=:]/g, ie = {
          "=": "=0",
          ":": "=2"
        }, de = P.replace(z, function(De) {
          return ie[De];
        });
        return "$" + de;
      }
      var cn = !1, ei = /\/+/g;
      function an(P) {
        return P.replace(ei, "$&/");
      }
      function on(P, z) {
        return typeof P == "object" && P !== null && P.key != null ? (Yn(P.key), $r("" + P.key)) : z.toString(36);
      }
      function ja(P, z, ie, de, De) {
        var ft = typeof P;
        (ft === "undefined" || ft === "boolean") && (P = null);
        var je = !1;
        if (P === null)
          je = !0;
        else
          switch (ft) {
            case "string":
            case "number":
              je = !0;
              break;
            case "object":
              switch (P.$$typeof) {
                case o:
                case u:
                  je = !0;
              }
          }
        if (je) {
          var ct = P, Lt = De(ct), Gt = de === "" ? Kn + on(ct, 0) : de;
          if (Nn(Lt)) {
            var mn = "";
            Gt != null && (mn = an(Gt) + "/"), ja(Lt, z, mn, "", function(oh) {
              return oh;
            });
          } else
            Lt != null && (rn(Lt) && (Lt.key && (!ct || ct.key !== Lt.key) && Yn(Lt.key), Lt = _t(
              Lt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              ie + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Lt.key && (!ct || ct.key !== Lt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                an("" + Lt.key) + "/"
              ) : "") + Gt
            )), z.push(Lt));
          return 1;
        }
        var dn, vn, bn = 0, Vt = de === "" ? Kn : de + An;
        if (Nn(P))
          for (var Do = 0; Do < P.length; Do++)
            dn = P[Do], vn = Vt + on(dn, Do), bn += ja(dn, z, ie, vn, De);
        else {
          var du = ae(P);
          if (typeof du == "function") {
            var Pc = P;
            du === Pc.entries && (cn || Ct("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), cn = !0);
            for (var ah = du.call(Pc), Ha, Dc = 0; !(Ha = ah.next()).done; )
              dn = Ha.value, vn = Vt + on(dn, Dc++), bn += ja(dn, z, ie, vn, De);
          } else if (ft === "object") {
            var Oc = String(P);
            throw new Error("Objects are not valid as a React child (found: " + (Oc === "[object Object]" ? "object with keys {" + Object.keys(P).join(", ") + "}" : Oc) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return bn;
      }
      function la(P, z, ie) {
        if (P == null)
          return P;
        var de = [], De = 0;
        return ja(P, de, "", "", function(ft) {
          return z.call(ie, ft, De++);
        }), de;
      }
      function hs(P) {
        var z = 0;
        return la(P, function() {
          z++;
        }), z;
      }
      function ol(P, z, ie) {
        la(P, function() {
          z.apply(this, arguments);
        }, ie);
      }
      function eu(P) {
        return la(P, function(z) {
          return z;
        }) || [];
      }
      function Ro(P) {
        if (!rn(P))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return P;
      }
      function ms(P) {
        var z = {
          $$typeof: b,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: P,
          _currentValue2: P,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        z.Provider = {
          $$typeof: g,
          _context: z
        };
        var ie = !1, de = !1, De = !1;
        {
          var ft = {
            $$typeof: b,
            _context: z
          };
          Object.defineProperties(ft, {
            Provider: {
              get: function() {
                return de || (de = !0, Me("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), z.Provider;
              },
              set: function(je) {
                z.Provider = je;
              }
            },
            _currentValue: {
              get: function() {
                return z._currentValue;
              },
              set: function(je) {
                z._currentValue = je;
              }
            },
            _currentValue2: {
              get: function() {
                return z._currentValue2;
              },
              set: function(je) {
                z._currentValue2 = je;
              }
            },
            _threadCount: {
              get: function() {
                return z._threadCount;
              },
              set: function(je) {
                z._threadCount = je;
              }
            },
            Consumer: {
              get: function() {
                return ie || (ie = !0, Me("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), z.Consumer;
              }
            },
            displayName: {
              get: function() {
                return z.displayName;
              },
              set: function(je) {
                De || (Ct("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", je), De = !0);
              }
            }
          }), z.Consumer = ft;
        }
        return z._currentRenderer = null, z._currentRenderer2 = null, z;
      }
      var Gi = -1, to = 0, Yi = 1, za = 2;
      function ti(P) {
        if (P._status === Gi) {
          var z = P._result, ie = z();
          if (ie.then(function(ft) {
            if (P._status === to || P._status === Gi) {
              var je = P;
              je._status = Yi, je._result = ft;
            }
          }, function(ft) {
            if (P._status === to || P._status === Gi) {
              var je = P;
              je._status = za, je._result = ft;
            }
          }), P._status === Gi) {
            var de = P;
            de._status = to, de._result = ie;
          }
        }
        if (P._status === Yi) {
          var De = P._result;
          return De === void 0 && Me(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, De), "default" in De || Me(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, De), De.default;
        } else
          throw P._result;
      }
      function Ki(P) {
        var z = {
          // We use these fields to store the result.
          _status: Gi,
          _result: P
        }, ie = {
          $$typeof: N,
          _payload: z,
          _init: ti
        };
        {
          var de, De;
          Object.defineProperties(ie, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return de;
              },
              set: function(ft) {
                Me("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), de = ft, Object.defineProperty(ie, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return De;
              },
              set: function(ft) {
                Me("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), De = ft, Object.defineProperty(ie, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return ie;
      }
      function no(P) {
        P != null && P.$$typeof === O ? Me("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof P != "function" ? Me("forwardRef requires a render function but was given %s.", P === null ? "null" : typeof P) : P.length !== 0 && P.length !== 2 && Me("forwardRef render functions accept exactly two parameters: props and ref. %s", P.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), P != null && (P.defaultProps != null || P.propTypes != null) && Me("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var z = {
          $$typeof: C,
          render: P
        };
        {
          var ie;
          Object.defineProperty(z, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ie;
            },
            set: function(de) {
              ie = de, !P.name && !P.displayName && (P.displayName = de);
            }
          });
        }
        return z;
      }
      var ro;
      ro = Symbol.for("react.module.reference");
      function V(P) {
        return !!(typeof P == "string" || typeof P == "function" || P === d || P === m || Je || P === c || P === E || P === x || Ne || P === M || ye || se || Ee || typeof P == "object" && P !== null && (P.$$typeof === N || P.$$typeof === O || P.$$typeof === g || P.$$typeof === b || P.$$typeof === C || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        P.$$typeof === ro || P.getModuleId !== void 0));
      }
      function ke(P, z) {
        V(P) || Me("memo: The first argument must be a component. Instead received: %s", P === null ? "null" : typeof P);
        var ie = {
          $$typeof: O,
          type: P,
          compare: z === void 0 ? null : z
        };
        {
          var de;
          Object.defineProperty(ie, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return de;
            },
            set: function(De) {
              de = De, !P.name && !P.displayName && (P.displayName = De);
            }
          });
        }
        return ie;
      }
      function _e() {
        var P = Z.current;
        return P === null && Me(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), P;
      }
      function nt(P) {
        var z = _e();
        if (P._context !== void 0) {
          var ie = P._context;
          ie.Consumer === P ? Me("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : ie.Provider === P && Me("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return z.useContext(P);
      }
      function Nt(P) {
        var z = _e();
        return z.useState(P);
      }
      function jt(P, z, ie) {
        var de = _e();
        return de.useReducer(P, z, ie);
      }
      function dt(P) {
        var z = _e();
        return z.useRef(P);
      }
      function xt(P, z) {
        var ie = _e();
        return ie.useEffect(P, z);
      }
      function tr(P, z) {
        var ie = _e();
        return ie.useInsertionEffect(P, z);
      }
      function hn(P, z) {
        var ie = _e();
        return ie.useLayoutEffect(P, z);
      }
      function kn(P, z) {
        var ie = _e();
        return ie.useCallback(P, z);
      }
      function qr(P, z) {
        var ie = _e();
        return ie.useMemo(P, z);
      }
      function io(P, z, ie) {
        var de = _e();
        return de.useImperativeHandle(P, z, ie);
      }
      function Kt(P, z) {
        {
          var ie = _e();
          return ie.useDebugValue(P, z);
        }
      }
      function Sr() {
        var P = _e();
        return P.useTransition();
      }
      function ni(P) {
        var z = _e();
        return z.useDeferredValue(P);
      }
      function Pt() {
        var P = _e();
        return P.useId();
      }
      function ua(P, z, ie) {
        var de = _e();
        return de.useSyncExternalStore(P, z, ie);
      }
      var vs = 0, tu, gs, Ti, wc, ri, Rc, _c;
      function Vd() {
      }
      Vd.__reactDisabledLog = !0;
      function nu() {
        {
          if (vs === 0) {
            tu = console.log, gs = console.info, Ti = console.warn, wc = console.error, ri = console.group, Rc = console.groupCollapsed, _c = console.groupEnd;
            var P = {
              configurable: !0,
              enumerable: !0,
              value: Vd,
              writable: !0
            };
            Object.defineProperties(console, {
              info: P,
              log: P,
              warn: P,
              error: P,
              group: P,
              groupCollapsed: P,
              groupEnd: P
            });
          }
          vs++;
        }
      }
      function ys() {
        {
          if (vs--, vs === 0) {
            var P = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ge({}, P, {
                value: tu
              }),
              info: ge({}, P, {
                value: gs
              }),
              warn: ge({}, P, {
                value: Ti
              }),
              error: ge({}, P, {
                value: wc
              }),
              group: ge({}, P, {
                value: ri
              }),
              groupCollapsed: ge({}, P, {
                value: Rc
              }),
              groupEnd: ge({}, P, {
                value: _c
              })
            });
          }
          vs < 0 && Me("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Va = vt.ReactCurrentDispatcher, ii;
      function bs(P, z, ie) {
        {
          if (ii === void 0)
            try {
              throw Error();
            } catch (De) {
              var de = De.stack.trim().match(/\n( *(at )?)/);
              ii = de && de[1] || "";
            }
          return `
` + ii + P;
        }
      }
      var Ss = !1, Cs;
      {
        var ru = typeof WeakMap == "function" ? WeakMap : Map;
        Cs = new ru();
      }
      function iu(P, z) {
        if (!P || Ss)
          return "";
        {
          var ie = Cs.get(P);
          if (ie !== void 0)
            return ie;
        }
        var de;
        Ss = !0;
        var De = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ft;
        ft = Va.current, Va.current = null, nu();
        try {
          if (z) {
            var je = function() {
              throw Error();
            };
            if (Object.defineProperty(je.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(je, []);
              } catch (Vt) {
                de = Vt;
              }
              Reflect.construct(P, [], je);
            } else {
              try {
                je.call();
              } catch (Vt) {
                de = Vt;
              }
              P.call(je.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Vt) {
              de = Vt;
            }
            P();
          }
        } catch (Vt) {
          if (Vt && de && typeof Vt.stack == "string") {
            for (var ct = Vt.stack.split(`
`), Lt = de.stack.split(`
`), Gt = ct.length - 1, mn = Lt.length - 1; Gt >= 1 && mn >= 0 && ct[Gt] !== Lt[mn]; )
              mn--;
            for (; Gt >= 1 && mn >= 0; Gt--, mn--)
              if (ct[Gt] !== Lt[mn]) {
                if (Gt !== 1 || mn !== 1)
                  do
                    if (Gt--, mn--, mn < 0 || ct[Gt] !== Lt[mn]) {
                      var dn = `
` + ct[Gt].replace(" at new ", " at ");
                      return P.displayName && dn.includes("<anonymous>") && (dn = dn.replace("<anonymous>", P.displayName)), typeof P == "function" && Cs.set(P, dn), dn;
                    }
                  while (Gt >= 1 && mn >= 0);
                break;
              }
          }
        } finally {
          Ss = !1, Va.current = ft, ys(), Error.prepareStackTrace = De;
        }
        var vn = P ? P.displayName || P.name : "", bn = vn ? bs(vn) : "";
        return typeof P == "function" && Cs.set(P, bn), bn;
      }
      function _o(P, z, ie) {
        return iu(P, !1);
      }
      function ih(P) {
        var z = P.prototype;
        return !!(z && z.isReactComponent);
      }
      function ao(P, z, ie) {
        if (P == null)
          return "";
        if (typeof P == "function")
          return iu(P, ih(P));
        if (typeof P == "string")
          return bs(P);
        switch (P) {
          case E:
            return bs("Suspense");
          case x:
            return bs("SuspenseList");
        }
        if (typeof P == "object")
          switch (P.$$typeof) {
            case C:
              return _o(P.render);
            case O:
              return ao(P.type, z, ie);
            case N: {
              var de = P, De = de._payload, ft = de._init;
              try {
                return ao(ft(De), z, ie);
              } catch {
              }
            }
          }
        return "";
      }
      var Qt = {}, au = vt.ReactDebugCurrentFrame;
      function sl(P) {
        if (P) {
          var z = P._owner, ie = ao(P.type, P._source, z ? z.type : null);
          au.setExtraStackFrame(ie);
        } else
          au.setExtraStackFrame(null);
      }
      function ou(P, z, ie, de, De) {
        {
          var ft = Function.call.bind(Br);
          for (var je in P)
            if (ft(P, je)) {
              var ct = void 0;
              try {
                if (typeof P[je] != "function") {
                  var Lt = Error((de || "React class") + ": " + ie + " type `" + je + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[je] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Lt.name = "Invariant Violation", Lt;
                }
                ct = P[je](z, je, de, ie, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Gt) {
                ct = Gt;
              }
              ct && !(ct instanceof Error) && (sl(De), Me("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", de || "React class", ie, je, typeof ct), sl(null)), ct instanceof Error && !(ct.message in Qt) && (Qt[ct.message] = !0, sl(De), Me("Failed %s type: %s", ie, ct.message), sl(null));
            }
        }
      }
      function zt(P) {
        if (P) {
          var z = P._owner, ie = ao(P.type, P._source, z ? z.type : null);
          pe(ie);
        } else
          pe(null);
      }
      var su;
      su = !1;
      function lu() {
        if (K.current) {
          var P = br(K.current.type);
          if (P)
            return `

Check the render method of \`` + P + "`.";
        }
        return "";
      }
      function bt(P) {
        if (P !== void 0) {
          var z = P.fileName.replace(/^.*[\\\/]/, ""), ie = P.lineNumber;
          return `

Check your code at ` + z + ":" + ie + ".";
        }
        return "";
      }
      function ll(P) {
        return P != null ? bt(P.__source) : "";
      }
      var In = {};
      function Ei(P) {
        var z = lu();
        if (!z) {
          var ie = typeof P == "string" ? P : P.displayName || P.name;
          ie && (z = `

Check the top-level render call using <` + ie + ">.");
        }
        return z;
      }
      function ai(P, z) {
        if (!(!P._store || P._store.validated || P.key != null)) {
          P._store.validated = !0;
          var ie = Ei(z);
          if (!In[ie]) {
            In[ie] = !0;
            var de = "";
            P && P._owner && P._owner !== K.current && (de = " It was passed a child from " + br(P._owner.type) + "."), zt(P), Me('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ie, de), zt(null);
          }
        }
      }
      function ks(P, z) {
        if (typeof P == "object") {
          if (Nn(P))
            for (var ie = 0; ie < P.length; ie++) {
              var de = P[ie];
              rn(de) && ai(de, z);
            }
          else if (rn(P))
            P._store && (P._store.validated = !0);
          else if (P) {
            var De = ae(P);
            if (typeof De == "function" && De !== P.entries)
              for (var ft = De.call(P), je; !(je = ft.next()).done; )
                rn(je.value) && ai(je.value, z);
          }
        }
      }
      function Vn(P) {
        {
          var z = P.type;
          if (z == null || typeof z == "string")
            return;
          var ie;
          if (typeof z == "function")
            ie = z.propTypes;
          else if (typeof z == "object" && (z.$$typeof === C || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          z.$$typeof === O))
            ie = z.propTypes;
          else
            return;
          if (ie) {
            var de = br(z);
            ou(ie, P.props, "prop", de, P);
          } else if (z.PropTypes !== void 0 && !su) {
            su = !0;
            var De = br(z);
            Me("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", De || "Unknown");
          }
          typeof z.getDefaultProps == "function" && !z.getDefaultProps.isReactClassApproved && Me("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function sn(P) {
        {
          for (var z = Object.keys(P.props), ie = 0; ie < z.length; ie++) {
            var de = z[ie];
            if (de !== "children" && de !== "key") {
              zt(P), Me("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", de), zt(null);
              break;
            }
          }
          P.ref !== null && (zt(P), Me("Invalid attribute `ref` supplied to `React.Fragment`."), zt(null));
        }
      }
      function Bd(P, z, ie) {
        var de = V(P);
        if (!de) {
          var De = "";
          (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (De += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ft = ll(z);
          ft ? De += ft : De += lu();
          var je;
          P === null ? je = "null" : Nn(P) ? je = "array" : P !== void 0 && P.$$typeof === o ? (je = "<" + (br(P.type) || "Unknown") + " />", De = " Did you accidentally export a JSX literal instead of a component?") : je = typeof P, Me("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", je, De);
        }
        var ct = at.apply(this, arguments);
        if (ct == null)
          return ct;
        if (de)
          for (var Lt = 2; Lt < arguments.length; Lt++)
            ks(arguments[Lt], P);
        return P === d ? sn(ct) : Vn(ct), ct;
      }
      var wi = !1;
      function Cr(P) {
        var z = Bd.bind(null, P);
        return z.type = P, wi || (wi = !0, Ct("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(z, "type", {
          enumerable: !1,
          get: function() {
            return Ct("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: P
            }), P;
          }
        }), z;
      }
      function oo(P, z, ie) {
        for (var de = en.apply(this, arguments), De = 2; De < arguments.length; De++)
          ks(arguments[De], de.type);
        return Vn(de), de;
      }
      function Hd(P, z) {
        var ie = B.transition;
        B.transition = {};
        var de = B.transition;
        B.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          P();
        } finally {
          if (B.transition = ie, ie === null && de._updatedFibers) {
            var De = de._updatedFibers.size;
            De > 10 && Ct("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), de._updatedFibers.clear();
          }
        }
      }
      var xo = !1, Ts = null;
      function $d(P) {
        if (Ts === null)
          try {
            var z = ("require" + Math.random()).slice(0, 7), ie = r && r[z];
            Ts = ie.call(r, "timers").setImmediate;
          } catch {
            Ts = function(De) {
              xo === !1 && (xo = !0, typeof MessageChannel > "u" && Me("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var ft = new MessageChannel();
              ft.port1.onmessage = De, ft.port2.postMessage(void 0);
            };
          }
        return Ts(P);
      }
      var ca = 0, Es = !1;
      function Po(P) {
        {
          var z = ca;
          ca++, F.current === null && (F.current = []);
          var ie = F.isBatchingLegacy, de;
          try {
            if (F.isBatchingLegacy = !0, de = P(), !ie && F.didScheduleLegacyUpdate) {
              var De = F.current;
              De !== null && (F.didScheduleLegacyUpdate = !1, Rs(De));
            }
          } catch (vn) {
            throw da(z), vn;
          } finally {
            F.isBatchingLegacy = ie;
          }
          if (de !== null && typeof de == "object" && typeof de.then == "function") {
            var ft = de, je = !1, ct = {
              then: function(vn, bn) {
                je = !0, ft.then(function(Vt) {
                  da(z), ca === 0 ? uu(Vt, vn, bn) : vn(Vt);
                }, function(Vt) {
                  da(z), bn(Vt);
                });
              }
            };
            return !Es && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              je || (Es = !0, Me("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), ct;
          } else {
            var Lt = de;
            if (da(z), ca === 0) {
              var Gt = F.current;
              Gt !== null && (Rs(Gt), F.current = null);
              var mn = {
                then: function(vn, bn) {
                  F.current === null ? (F.current = [], uu(Lt, vn, bn)) : vn(Lt);
                }
              };
              return mn;
            } else {
              var dn = {
                then: function(vn, bn) {
                  vn(Lt);
                }
              };
              return dn;
            }
          }
        }
      }
      function da(P) {
        P !== ca - 1 && Me("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), ca = P;
      }
      function uu(P, z, ie) {
        {
          var de = F.current;
          if (de !== null)
            try {
              Rs(de), $d(function() {
                de.length === 0 ? (F.current = null, z(P)) : uu(P, z, ie);
              });
            } catch (De) {
              ie(De);
            }
          else
            z(P);
        }
      }
      var ws = !1;
      function Rs(P) {
        if (!ws) {
          ws = !0;
          var z = 0;
          try {
            for (; z < P.length; z++) {
              var ie = P[z];
              do
                ie = ie(!0);
              while (ie !== null);
            }
            P.length = 0;
          } catch (de) {
            throw P = P.slice(z + 1), de;
          } finally {
            ws = !1;
          }
        }
      }
      var ul = Bd, cu = oo, xc = Cr, Ba = {
        map: la,
        forEach: ol,
        count: hs,
        toArray: eu,
        only: Ro
      };
      t.Children = Ba, t.Component = Be, t.Fragment = d, t.Profiler = m, t.PureComponent = Ot, t.StrictMode = c, t.Suspense = E, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vt, t.act = Po, t.cloneElement = cu, t.createContext = ms, t.createElement = ul, t.createFactory = xc, t.createRef = Vr, t.forwardRef = no, t.isValidElement = rn, t.lazy = Ki, t.memo = ke, t.startTransition = Hd, t.unstable_act = Po, t.useCallback = kn, t.useContext = nt, t.useDebugValue = Kt, t.useDeferredValue = ni, t.useEffect = xt, t.useId = Pt, t.useImperativeHandle = io, t.useInsertionEffect = tr, t.useLayoutEffect = hn, t.useMemo = qr, t.useReducer = jt, t.useRef = dt, t.useState = Nt, t.useSyncExternalStore = ua, t.useTransition = Sr, t.version = i, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(mv, mv.exports)), mv.exports;
}
process.env.NODE_ENV === "production" ? TT.exports = n5() : TT.exports = r5();
var R = TT.exports;
const Na = /* @__PURE__ */ mP(R);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P_;
function i5() {
  if (P_)
    return sv;
  P_ = 1;
  var r = R, t = Symbol.for("react.element"), i = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, u = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 };
  function c(m, g, b) {
    var C, E = {}, x = null, O = null;
    b !== void 0 && (x = "" + b), g.key !== void 0 && (x = "" + g.key), g.ref !== void 0 && (O = g.ref);
    for (C in g)
      o.call(g, C) && !d.hasOwnProperty(C) && (E[C] = g[C]);
    if (m && m.defaultProps)
      for (C in g = m.defaultProps, g)
        E[C] === void 0 && (E[C] = g[C]);
    return { $$typeof: t, type: m, key: x, ref: O, props: E, _owner: u.current };
  }
  return sv.Fragment = i, sv.jsx = c, sv.jsxs = c, sv;
}
var lv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D_;
function a5() {
  return D_ || (D_ = 1, process.env.NODE_ENV !== "production" && function() {
    var r = R, t = Symbol.for("react.element"), i = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), m = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), C = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), O = Symbol.for("react.offscreen"), N = Symbol.iterator, M = "@@iterator";
    function I(V) {
      if (V === null || typeof V != "object")
        return null;
      var ke = N && V[N] || V[M];
      return typeof ke == "function" ? ke : null;
    }
    var U = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ae(V) {
      {
        for (var ke = arguments.length, _e = new Array(ke > 1 ? ke - 1 : 0), nt = 1; nt < ke; nt++)
          _e[nt - 1] = arguments[nt];
        Z("error", V, _e);
      }
    }
    function Z(V, ke, _e) {
      {
        var nt = U.ReactDebugCurrentFrame, Nt = nt.getStackAddendum();
        Nt !== "" && (ke += "%s", _e = _e.concat([Nt]));
        var jt = _e.map(function(dt) {
          return String(dt);
        });
        jt.unshift("Warning: " + ke), Function.prototype.apply.call(console[V], console, jt);
      }
    }
    var B = !1, F = !1, K = !1, te = !1, he = !1, pe;
    pe = Symbol.for("react.module.reference");
    function ye(V) {
      return !!(typeof V == "string" || typeof V == "function" || V === o || V === d || he || V === u || V === b || V === C || te || V === O || B || F || K || typeof V == "object" && V !== null && (V.$$typeof === x || V.$$typeof === E || V.$$typeof === c || V.$$typeof === m || V.$$typeof === g || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      V.$$typeof === pe || V.getModuleId !== void 0));
    }
    function se(V, ke, _e) {
      var nt = V.displayName;
      if (nt)
        return nt;
      var Nt = ke.displayName || ke.name || "";
      return Nt !== "" ? _e + "(" + Nt + ")" : _e;
    }
    function Ee(V) {
      return V.displayName || "Context";
    }
    function Ne(V) {
      if (V == null)
        return null;
      if (typeof V.tag == "number" && ae("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof V == "function")
        return V.displayName || V.name || null;
      if (typeof V == "string")
        return V;
      switch (V) {
        case o:
          return "Fragment";
        case i:
          return "Portal";
        case d:
          return "Profiler";
        case u:
          return "StrictMode";
        case b:
          return "Suspense";
        case C:
          return "SuspenseList";
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case m:
            var ke = V;
            return Ee(ke) + ".Consumer";
          case c:
            var _e = V;
            return Ee(_e._context) + ".Provider";
          case g:
            return se(V, V.render, "ForwardRef");
          case E:
            var nt = V.displayName || null;
            return nt !== null ? nt : Ne(V.type) || "Memo";
          case x: {
            var Nt = V, jt = Nt._payload, dt = Nt._init;
            try {
              return Ne(dt(jt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Je = Object.assign, vt = 0, Ct, Me, Pe, Ze, Ie, Y, ge;
    function lt() {
    }
    lt.__reactDisabledLog = !0;
    function Be() {
      {
        if (vt === 0) {
          Ct = console.log, Me = console.info, Pe = console.warn, Ze = console.error, Ie = console.group, Y = console.groupCollapsed, ge = console.groupEnd;
          var V = {
            configurable: !0,
            enumerable: !0,
            value: lt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: V,
            log: V,
            warn: V,
            error: V,
            group: V,
            groupCollapsed: V,
            groupEnd: V
          });
        }
        vt++;
      }
    }
    function kt() {
      {
        if (vt--, vt === 0) {
          var V = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Je({}, V, {
              value: Ct
            }),
            info: Je({}, V, {
              value: Me
            }),
            warn: Je({}, V, {
              value: Pe
            }),
            error: Je({}, V, {
              value: Ze
            }),
            group: Je({}, V, {
              value: Ie
            }),
            groupCollapsed: Je({}, V, {
              value: Y
            }),
            groupEnd: Je({}, V, {
              value: ge
            })
          });
        }
        vt < 0 && ae("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Rt = U.ReactCurrentDispatcher, Ft;
    function Dt(V, ke, _e) {
      {
        if (Ft === void 0)
          try {
            throw Error();
          } catch (Nt) {
            var nt = Nt.stack.trim().match(/\n( *(at )?)/);
            Ft = nt && nt[1] || "";
          }
        return `
` + Ft + V;
      }
    }
    var Ot = !1, yn;
    {
      var Vr = typeof WeakMap == "function" ? WeakMap : Map;
      yn = new Vr();
    }
    function yi(V, ke) {
      if (!V || Ot)
        return "";
      {
        var _e = yn.get(V);
        if (_e !== void 0)
          return _e;
      }
      var nt;
      Ot = !0;
      var Nt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var jt;
      jt = Rt.current, Rt.current = null, Be();
      try {
        if (ke) {
          var dt = function() {
            throw Error();
          };
          if (Object.defineProperty(dt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(dt, []);
            } catch (Sr) {
              nt = Sr;
            }
            Reflect.construct(V, [], dt);
          } else {
            try {
              dt.call();
            } catch (Sr) {
              nt = Sr;
            }
            V.call(dt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Sr) {
            nt = Sr;
          }
          V();
        }
      } catch (Sr) {
        if (Sr && nt && typeof Sr.stack == "string") {
          for (var xt = Sr.stack.split(`
`), tr = nt.stack.split(`
`), hn = xt.length - 1, kn = tr.length - 1; hn >= 1 && kn >= 0 && xt[hn] !== tr[kn]; )
            kn--;
          for (; hn >= 1 && kn >= 0; hn--, kn--)
            if (xt[hn] !== tr[kn]) {
              if (hn !== 1 || kn !== 1)
                do
                  if (hn--, kn--, kn < 0 || xt[hn] !== tr[kn]) {
                    var qr = `
` + xt[hn].replace(" at new ", " at ");
                    return V.displayName && qr.includes("<anonymous>") && (qr = qr.replace("<anonymous>", V.displayName)), typeof V == "function" && yn.set(V, qr), qr;
                  }
                while (hn >= 1 && kn >= 0);
              break;
            }
        }
      } finally {
        Ot = !1, Rt.current = jt, kt(), Error.prepareStackTrace = Nt;
      }
      var io = V ? V.displayName || V.name : "", Kt = io ? Dt(io) : "";
      return typeof V == "function" && yn.set(V, Kt), Kt;
    }
    function Nn(V, ke, _e) {
      return yi(V, !1);
    }
    function yr(V) {
      var ke = V.prototype;
      return !!(ke && ke.isReactComponent);
    }
    function ur(V, ke, _e) {
      if (V == null)
        return "";
      if (typeof V == "function")
        return yi(V, yr(V));
      if (typeof V == "string")
        return Dt(V);
      switch (V) {
        case b:
          return Dt("Suspense");
        case C:
          return Dt("SuspenseList");
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case g:
            return Nn(V.render);
          case E:
            return ur(V.type, ke, _e);
          case x: {
            var nt = V, Nt = nt._payload, jt = nt._init;
            try {
              return ur(jt(Nt), ke, _e);
            } catch {
            }
          }
        }
      return "";
    }
    var er = Object.prototype.hasOwnProperty, Yn = {}, bi = U.ReactDebugCurrentFrame;
    function Si(V) {
      if (V) {
        var ke = V._owner, _e = ur(V.type, V._source, ke ? ke.type : null);
        bi.setExtraStackFrame(_e);
      } else
        bi.setExtraStackFrame(null);
    }
    function br(V, ke, _e, nt, Nt) {
      {
        var jt = Function.call.bind(er);
        for (var dt in V)
          if (jt(V, dt)) {
            var xt = void 0;
            try {
              if (typeof V[dt] != "function") {
                var tr = Error((nt || "React class") + ": " + _e + " type `" + dt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof V[dt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tr.name = "Invariant Violation", tr;
              }
              xt = V[dt](ke, dt, nt, _e, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (hn) {
              xt = hn;
            }
            xt && !(xt instanceof Error) && (Si(Nt), ae("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", nt || "React class", _e, dt, typeof xt), Si(null)), xt instanceof Error && !(xt.message in Yn) && (Yn[xt.message] = !0, Si(Nt), ae("Failed %s type: %s", _e, xt.message), Si(null));
          }
      }
    }
    var Br = Array.isArray;
    function Ci(V) {
      return Br(V);
    }
    function Hr(V) {
      {
        var ke = typeof Symbol == "function" && Symbol.toStringTag, _e = ke && V[Symbol.toStringTag] || V.constructor.name || "Object";
        return _e;
      }
    }
    function qi(V) {
      try {
        return xr(V), !1;
      } catch {
        return !0;
      }
    }
    function xr(V) {
      return "" + V;
    }
    function ki(V) {
      if (qi(V))
        return ae("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Hr(V)), xr(V);
    }
    var Ln = U.ReactCurrentOwner, Zr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, eo, Wi, Ae;
    Ae = {};
    function at(V) {
      if (er.call(V, "ref")) {
        var ke = Object.getOwnPropertyDescriptor(V, "ref").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return V.ref !== void 0;
    }
    function _t(V) {
      if (er.call(V, "key")) {
        var ke = Object.getOwnPropertyDescriptor(V, "key").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return V.key !== void 0;
    }
    function en(V, ke) {
      if (typeof V.ref == "string" && Ln.current && ke && Ln.current.stateNode !== ke) {
        var _e = Ne(Ln.current.type);
        Ae[_e] || (ae('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ne(Ln.current.type), V.ref), Ae[_e] = !0);
      }
    }
    function rn(V, ke) {
      {
        var _e = function() {
          eo || (eo = !0, ae("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        _e.isReactWarning = !0, Object.defineProperty(V, "key", {
          get: _e,
          configurable: !0
        });
      }
    }
    function Kn(V, ke) {
      {
        var _e = function() {
          Wi || (Wi = !0, ae("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        _e.isReactWarning = !0, Object.defineProperty(V, "ref", {
          get: _e,
          configurable: !0
        });
      }
    }
    var An = function(V, ke, _e, nt, Nt, jt, dt) {
      var xt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: V,
        key: ke,
        ref: _e,
        props: dt,
        // Record the component responsible for creating this element.
        _owner: jt
      };
      return xt._store = {}, Object.defineProperty(xt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(xt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: nt
      }), Object.defineProperty(xt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Nt
      }), Object.freeze && (Object.freeze(xt.props), Object.freeze(xt)), xt;
    };
    function $r(V, ke, _e, nt, Nt) {
      {
        var jt, dt = {}, xt = null, tr = null;
        _e !== void 0 && (ki(_e), xt = "" + _e), _t(ke) && (ki(ke.key), xt = "" + ke.key), at(ke) && (tr = ke.ref, en(ke, Nt));
        for (jt in ke)
          er.call(ke, jt) && !Zr.hasOwnProperty(jt) && (dt[jt] = ke[jt]);
        if (V && V.defaultProps) {
          var hn = V.defaultProps;
          for (jt in hn)
            dt[jt] === void 0 && (dt[jt] = hn[jt]);
        }
        if (xt || tr) {
          var kn = typeof V == "function" ? V.displayName || V.name || "Unknown" : V;
          xt && rn(dt, kn), tr && Kn(dt, kn);
        }
        return An(V, xt, tr, Nt, nt, Ln.current, dt);
      }
    }
    var cn = U.ReactCurrentOwner, ei = U.ReactDebugCurrentFrame;
    function an(V) {
      if (V) {
        var ke = V._owner, _e = ur(V.type, V._source, ke ? ke.type : null);
        ei.setExtraStackFrame(_e);
      } else
        ei.setExtraStackFrame(null);
    }
    var on;
    on = !1;
    function ja(V) {
      return typeof V == "object" && V !== null && V.$$typeof === t;
    }
    function la() {
      {
        if (cn.current) {
          var V = Ne(cn.current.type);
          if (V)
            return `

Check the render method of \`` + V + "`.";
        }
        return "";
      }
    }
    function hs(V) {
      {
        if (V !== void 0) {
          var ke = V.fileName.replace(/^.*[\\\/]/, ""), _e = V.lineNumber;
          return `

Check your code at ` + ke + ":" + _e + ".";
        }
        return "";
      }
    }
    var ol = {};
    function eu(V) {
      {
        var ke = la();
        if (!ke) {
          var _e = typeof V == "string" ? V : V.displayName || V.name;
          _e && (ke = `

Check the top-level render call using <` + _e + ">.");
        }
        return ke;
      }
    }
    function Ro(V, ke) {
      {
        if (!V._store || V._store.validated || V.key != null)
          return;
        V._store.validated = !0;
        var _e = eu(ke);
        if (ol[_e])
          return;
        ol[_e] = !0;
        var nt = "";
        V && V._owner && V._owner !== cn.current && (nt = " It was passed a child from " + Ne(V._owner.type) + "."), an(V), ae('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', _e, nt), an(null);
      }
    }
    function ms(V, ke) {
      {
        if (typeof V != "object")
          return;
        if (Ci(V))
          for (var _e = 0; _e < V.length; _e++) {
            var nt = V[_e];
            ja(nt) && Ro(nt, ke);
          }
        else if (ja(V))
          V._store && (V._store.validated = !0);
        else if (V) {
          var Nt = I(V);
          if (typeof Nt == "function" && Nt !== V.entries)
            for (var jt = Nt.call(V), dt; !(dt = jt.next()).done; )
              ja(dt.value) && Ro(dt.value, ke);
        }
      }
    }
    function Gi(V) {
      {
        var ke = V.type;
        if (ke == null || typeof ke == "string")
          return;
        var _e;
        if (typeof ke == "function")
          _e = ke.propTypes;
        else if (typeof ke == "object" && (ke.$$typeof === g || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ke.$$typeof === E))
          _e = ke.propTypes;
        else
          return;
        if (_e) {
          var nt = Ne(ke);
          br(_e, V.props, "prop", nt, V);
        } else if (ke.PropTypes !== void 0 && !on) {
          on = !0;
          var Nt = Ne(ke);
          ae("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Nt || "Unknown");
        }
        typeof ke.getDefaultProps == "function" && !ke.getDefaultProps.isReactClassApproved && ae("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function to(V) {
      {
        for (var ke = Object.keys(V.props), _e = 0; _e < ke.length; _e++) {
          var nt = ke[_e];
          if (nt !== "children" && nt !== "key") {
            an(V), ae("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", nt), an(null);
            break;
          }
        }
        V.ref !== null && (an(V), ae("Invalid attribute `ref` supplied to `React.Fragment`."), an(null));
      }
    }
    var Yi = {};
    function za(V, ke, _e, nt, Nt, jt) {
      {
        var dt = ye(V);
        if (!dt) {
          var xt = "";
          (V === void 0 || typeof V == "object" && V !== null && Object.keys(V).length === 0) && (xt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tr = hs(Nt);
          tr ? xt += tr : xt += la();
          var hn;
          V === null ? hn = "null" : Ci(V) ? hn = "array" : V !== void 0 && V.$$typeof === t ? (hn = "<" + (Ne(V.type) || "Unknown") + " />", xt = " Did you accidentally export a JSX literal instead of a component?") : hn = typeof V, ae("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", hn, xt);
        }
        var kn = $r(V, ke, _e, Nt, jt);
        if (kn == null)
          return kn;
        if (dt) {
          var qr = ke.children;
          if (qr !== void 0)
            if (nt)
              if (Ci(qr)) {
                for (var io = 0; io < qr.length; io++)
                  ms(qr[io], V);
                Object.freeze && Object.freeze(qr);
              } else
                ae("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ms(qr, V);
        }
        if (er.call(ke, "key")) {
          var Kt = Ne(V), Sr = Object.keys(ke).filter(function(ua) {
            return ua !== "key";
          }), ni = Sr.length > 0 ? "{key: someKey, " + Sr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Yi[Kt + ni]) {
            var Pt = Sr.length > 0 ? "{" + Sr.join(": ..., ") + ": ...}" : "{}";
            ae(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ni, Kt, Pt, Kt), Yi[Kt + ni] = !0;
          }
        }
        return V === o ? to(kn) : Gi(kn), kn;
      }
    }
    function ti(V, ke, _e) {
      return za(V, ke, _e, !0);
    }
    function Ki(V, ke, _e) {
      return za(V, ke, _e, !1);
    }
    var no = Ki, ro = ti;
    lv.Fragment = o, lv.jsx = no, lv.jsxs = ro;
  }()), lv;
}
process.env.NODE_ENV === "production" ? kT.exports = i5() : kT.exports = a5();
var Mt = kT.exports, vv = {}, ET = { exports: {} }, Oa = {}, R0 = { exports: {} }, Xk = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O_;
function o5() {
  return O_ || (O_ = 1, function(r) {
    function t(Pe, Ze) {
      var Ie = Pe.length;
      Pe.push(Ze);
      e:
        for (; 0 < Ie; ) {
          var Y = Ie - 1 >>> 1, ge = Pe[Y];
          if (0 < u(ge, Ze))
            Pe[Y] = Ze, Pe[Ie] = ge, Ie = Y;
          else
            break e;
        }
    }
    function i(Pe) {
      return Pe.length === 0 ? null : Pe[0];
    }
    function o(Pe) {
      if (Pe.length === 0)
        return null;
      var Ze = Pe[0], Ie = Pe.pop();
      if (Ie !== Ze) {
        Pe[0] = Ie;
        e:
          for (var Y = 0, ge = Pe.length, lt = ge >>> 1; Y < lt; ) {
            var Be = 2 * (Y + 1) - 1, kt = Pe[Be], Rt = Be + 1, Ft = Pe[Rt];
            if (0 > u(kt, Ie))
              Rt < ge && 0 > u(Ft, kt) ? (Pe[Y] = Ft, Pe[Rt] = Ie, Y = Rt) : (Pe[Y] = kt, Pe[Be] = Ie, Y = Be);
            else if (Rt < ge && 0 > u(Ft, Ie))
              Pe[Y] = Ft, Pe[Rt] = Ie, Y = Rt;
            else
              break e;
          }
      }
      return Ze;
    }
    function u(Pe, Ze) {
      var Ie = Pe.sortIndex - Ze.sortIndex;
      return Ie !== 0 ? Ie : Pe.id - Ze.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var d = performance;
      r.unstable_now = function() {
        return d.now();
      };
    } else {
      var c = Date, m = c.now();
      r.unstable_now = function() {
        return c.now() - m;
      };
    }
    var g = [], b = [], C = 1, E = null, x = 3, O = !1, N = !1, M = !1, I = typeof setTimeout == "function" ? setTimeout : null, U = typeof clearTimeout == "function" ? clearTimeout : null, ae = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Z(Pe) {
      for (var Ze = i(b); Ze !== null; ) {
        if (Ze.callback === null)
          o(b);
        else if (Ze.startTime <= Pe)
          o(b), Ze.sortIndex = Ze.expirationTime, t(g, Ze);
        else
          break;
        Ze = i(b);
      }
    }
    function B(Pe) {
      if (M = !1, Z(Pe), !N)
        if (i(g) !== null)
          N = !0, Ct(F);
        else {
          var Ze = i(b);
          Ze !== null && Me(B, Ze.startTime - Pe);
        }
    }
    function F(Pe, Ze) {
      N = !1, M && (M = !1, U(he), he = -1), O = !0;
      var Ie = x;
      try {
        for (Z(Ze), E = i(g); E !== null && (!(E.expirationTime > Ze) || Pe && !se()); ) {
          var Y = E.callback;
          if (typeof Y == "function") {
            E.callback = null, x = E.priorityLevel;
            var ge = Y(E.expirationTime <= Ze);
            Ze = r.unstable_now(), typeof ge == "function" ? E.callback = ge : E === i(g) && o(g), Z(Ze);
          } else
            o(g);
          E = i(g);
        }
        if (E !== null)
          var lt = !0;
        else {
          var Be = i(b);
          Be !== null && Me(B, Be.startTime - Ze), lt = !1;
        }
        return lt;
      } finally {
        E = null, x = Ie, O = !1;
      }
    }
    var K = !1, te = null, he = -1, pe = 5, ye = -1;
    function se() {
      return !(r.unstable_now() - ye < pe);
    }
    function Ee() {
      if (te !== null) {
        var Pe = r.unstable_now();
        ye = Pe;
        var Ze = !0;
        try {
          Ze = te(!0, Pe);
        } finally {
          Ze ? Ne() : (K = !1, te = null);
        }
      } else
        K = !1;
    }
    var Ne;
    if (typeof ae == "function")
      Ne = function() {
        ae(Ee);
      };
    else if (typeof MessageChannel < "u") {
      var Je = new MessageChannel(), vt = Je.port2;
      Je.port1.onmessage = Ee, Ne = function() {
        vt.postMessage(null);
      };
    } else
      Ne = function() {
        I(Ee, 0);
      };
    function Ct(Pe) {
      te = Pe, K || (K = !0, Ne());
    }
    function Me(Pe, Ze) {
      he = I(function() {
        Pe(r.unstable_now());
      }, Ze);
    }
    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(Pe) {
      Pe.callback = null;
    }, r.unstable_continueExecution = function() {
      N || O || (N = !0, Ct(F));
    }, r.unstable_forceFrameRate = function(Pe) {
      0 > Pe || 125 < Pe ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : pe = 0 < Pe ? Math.floor(1e3 / Pe) : 5;
    }, r.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, r.unstable_getFirstCallbackNode = function() {
      return i(g);
    }, r.unstable_next = function(Pe) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var Ze = 3;
          break;
        default:
          Ze = x;
      }
      var Ie = x;
      x = Ze;
      try {
        return Pe();
      } finally {
        x = Ie;
      }
    }, r.unstable_pauseExecution = function() {
    }, r.unstable_requestPaint = function() {
    }, r.unstable_runWithPriority = function(Pe, Ze) {
      switch (Pe) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Pe = 3;
      }
      var Ie = x;
      x = Pe;
      try {
        return Ze();
      } finally {
        x = Ie;
      }
    }, r.unstable_scheduleCallback = function(Pe, Ze, Ie) {
      var Y = r.unstable_now();
      switch (typeof Ie == "object" && Ie !== null ? (Ie = Ie.delay, Ie = typeof Ie == "number" && 0 < Ie ? Y + Ie : Y) : Ie = Y, Pe) {
        case 1:
          var ge = -1;
          break;
        case 2:
          ge = 250;
          break;
        case 5:
          ge = 1073741823;
          break;
        case 4:
          ge = 1e4;
          break;
        default:
          ge = 5e3;
      }
      return ge = Ie + ge, Pe = { id: C++, callback: Ze, priorityLevel: Pe, startTime: Ie, expirationTime: ge, sortIndex: -1 }, Ie > Y ? (Pe.sortIndex = Ie, t(b, Pe), i(g) === null && Pe === i(b) && (M ? (U(he), he = -1) : M = !0, Me(B, Ie - Y))) : (Pe.sortIndex = ge, t(g, Pe), N || O || (N = !0, Ct(F))), Pe;
    }, r.unstable_shouldYield = se, r.unstable_wrapCallback = function(Pe) {
      var Ze = x;
      return function() {
        var Ie = x;
        x = Ze;
        try {
          return Pe.apply(this, arguments);
        } finally {
          x = Ie;
        }
      };
    };
  }(Xk)), Xk;
}
var Zk = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var M_;
function s5() {
  return M_ || (M_ = 1, function(r) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, i = !1, o = 5;
      function u(Ae, at) {
        var _t = Ae.length;
        Ae.push(at), m(Ae, at, _t);
      }
      function d(Ae) {
        return Ae.length === 0 ? null : Ae[0];
      }
      function c(Ae) {
        if (Ae.length === 0)
          return null;
        var at = Ae[0], _t = Ae.pop();
        return _t !== at && (Ae[0] = _t, g(Ae, _t, 0)), at;
      }
      function m(Ae, at, _t) {
        for (var en = _t; en > 0; ) {
          var rn = en - 1 >>> 1, Kn = Ae[rn];
          if (b(Kn, at) > 0)
            Ae[rn] = at, Ae[en] = Kn, en = rn;
          else
            return;
        }
      }
      function g(Ae, at, _t) {
        for (var en = _t, rn = Ae.length, Kn = rn >>> 1; en < Kn; ) {
          var An = (en + 1) * 2 - 1, $r = Ae[An], cn = An + 1, ei = Ae[cn];
          if (b($r, at) < 0)
            cn < rn && b(ei, $r) < 0 ? (Ae[en] = ei, Ae[cn] = at, en = cn) : (Ae[en] = $r, Ae[An] = at, en = An);
          else if (cn < rn && b(ei, at) < 0)
            Ae[en] = ei, Ae[cn] = at, en = cn;
          else
            return;
        }
      }
      function b(Ae, at) {
        var _t = Ae.sortIndex - at.sortIndex;
        return _t !== 0 ? _t : Ae.id - at.id;
      }
      var C = 1, E = 2, x = 3, O = 4, N = 5;
      function M(Ae, at) {
      }
      var I = typeof performance == "object" && typeof performance.now == "function";
      if (I) {
        var U = performance;
        r.unstable_now = function() {
          return U.now();
        };
      } else {
        var ae = Date, Z = ae.now();
        r.unstable_now = function() {
          return ae.now() - Z;
        };
      }
      var B = 1073741823, F = -1, K = 250, te = 5e3, he = 1e4, pe = B, ye = [], se = [], Ee = 1, Ne = null, Je = x, vt = !1, Ct = !1, Me = !1, Pe = typeof setTimeout == "function" ? setTimeout : null, Ze = typeof clearTimeout == "function" ? clearTimeout : null, Ie = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Y(Ae) {
        for (var at = d(se); at !== null; ) {
          if (at.callback === null)
            c(se);
          else if (at.startTime <= Ae)
            c(se), at.sortIndex = at.expirationTime, u(ye, at);
          else
            return;
          at = d(se);
        }
      }
      function ge(Ae) {
        if (Me = !1, Y(Ae), !Ct)
          if (d(ye) !== null)
            Ct = !0, ki(lt);
          else {
            var at = d(se);
            at !== null && Ln(ge, at.startTime - Ae);
          }
      }
      function lt(Ae, at) {
        Ct = !1, Me && (Me = !1, Zr()), vt = !0;
        var _t = Je;
        try {
          var en;
          if (!i)
            return Be(Ae, at);
        } finally {
          Ne = null, Je = _t, vt = !1;
        }
      }
      function Be(Ae, at) {
        var _t = at;
        for (Y(_t), Ne = d(ye); Ne !== null && !t && !(Ne.expirationTime > _t && (!Ae || Si())); ) {
          var en = Ne.callback;
          if (typeof en == "function") {
            Ne.callback = null, Je = Ne.priorityLevel;
            var rn = Ne.expirationTime <= _t, Kn = en(rn);
            _t = r.unstable_now(), typeof Kn == "function" ? Ne.callback = Kn : Ne === d(ye) && c(ye), Y(_t);
          } else
            c(ye);
          Ne = d(ye);
        }
        if (Ne !== null)
          return !0;
        var An = d(se);
        return An !== null && Ln(ge, An.startTime - _t), !1;
      }
      function kt(Ae, at) {
        switch (Ae) {
          case C:
          case E:
          case x:
          case O:
          case N:
            break;
          default:
            Ae = x;
        }
        var _t = Je;
        Je = Ae;
        try {
          return at();
        } finally {
          Je = _t;
        }
      }
      function Rt(Ae) {
        var at;
        switch (Je) {
          case C:
          case E:
          case x:
            at = x;
            break;
          default:
            at = Je;
            break;
        }
        var _t = Je;
        Je = at;
        try {
          return Ae();
        } finally {
          Je = _t;
        }
      }
      function Ft(Ae) {
        var at = Je;
        return function() {
          var _t = Je;
          Je = at;
          try {
            return Ae.apply(this, arguments);
          } finally {
            Je = _t;
          }
        };
      }
      function Dt(Ae, at, _t) {
        var en = r.unstable_now(), rn;
        if (typeof _t == "object" && _t !== null) {
          var Kn = _t.delay;
          typeof Kn == "number" && Kn > 0 ? rn = en + Kn : rn = en;
        } else
          rn = en;
        var An;
        switch (Ae) {
          case C:
            An = F;
            break;
          case E:
            An = K;
            break;
          case N:
            An = pe;
            break;
          case O:
            An = he;
            break;
          case x:
          default:
            An = te;
            break;
        }
        var $r = rn + An, cn = {
          id: Ee++,
          callback: at,
          priorityLevel: Ae,
          startTime: rn,
          expirationTime: $r,
          sortIndex: -1
        };
        return rn > en ? (cn.sortIndex = rn, u(se, cn), d(ye) === null && cn === d(se) && (Me ? Zr() : Me = !0, Ln(ge, rn - en))) : (cn.sortIndex = $r, u(ye, cn), !Ct && !vt && (Ct = !0, ki(lt))), cn;
      }
      function Ot() {
      }
      function yn() {
        !Ct && !vt && (Ct = !0, ki(lt));
      }
      function Vr() {
        return d(ye);
      }
      function yi(Ae) {
        Ae.callback = null;
      }
      function Nn() {
        return Je;
      }
      var yr = !1, ur = null, er = -1, Yn = o, bi = -1;
      function Si() {
        var Ae = r.unstable_now() - bi;
        return !(Ae < Yn);
      }
      function br() {
      }
      function Br(Ae) {
        if (Ae < 0 || Ae > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ae > 0 ? Yn = Math.floor(1e3 / Ae) : Yn = o;
      }
      var Ci = function() {
        if (ur !== null) {
          var Ae = r.unstable_now();
          bi = Ae;
          var at = !0, _t = !0;
          try {
            _t = ur(at, Ae);
          } finally {
            _t ? Hr() : (yr = !1, ur = null);
          }
        } else
          yr = !1;
      }, Hr;
      if (typeof Ie == "function")
        Hr = function() {
          Ie(Ci);
        };
      else if (typeof MessageChannel < "u") {
        var qi = new MessageChannel(), xr = qi.port2;
        qi.port1.onmessage = Ci, Hr = function() {
          xr.postMessage(null);
        };
      } else
        Hr = function() {
          Pe(Ci, 0);
        };
      function ki(Ae) {
        ur = Ae, yr || (yr = !0, Hr());
      }
      function Ln(Ae, at) {
        er = Pe(function() {
          Ae(r.unstable_now());
        }, at);
      }
      function Zr() {
        Ze(er), er = -1;
      }
      var eo = br, Wi = null;
      r.unstable_IdlePriority = N, r.unstable_ImmediatePriority = C, r.unstable_LowPriority = O, r.unstable_NormalPriority = x, r.unstable_Profiling = Wi, r.unstable_UserBlockingPriority = E, r.unstable_cancelCallback = yi, r.unstable_continueExecution = yn, r.unstable_forceFrameRate = Br, r.unstable_getCurrentPriorityLevel = Nn, r.unstable_getFirstCallbackNode = Vr, r.unstable_next = Rt, r.unstable_pauseExecution = Ot, r.unstable_requestPaint = eo, r.unstable_runWithPriority = kt, r.unstable_scheduleCallback = Dt, r.unstable_shouldYield = Si, r.unstable_wrapCallback = Ft, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Zk)), Zk;
}
var N_;
function vP() {
  return N_ || (N_ = 1, process.env.NODE_ENV === "production" ? R0.exports = o5() : R0.exports = s5()), R0.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var L_;
function l5() {
  if (L_)
    return Oa;
  L_ = 1;
  var r = R, t = vP();
  function i(a) {
    for (var s = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, p = 1; p < arguments.length; p++)
      s += "&args[]=" + encodeURIComponent(arguments[p]);
    return "Minified React error #" + a + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var o = /* @__PURE__ */ new Set(), u = {};
  function d(a, s) {
    c(a, s), c(a + "Capture", s);
  }
  function c(a, s) {
    for (u[a] = s, a = 0; a < s.length; a++)
      o.add(s[a]);
  }
  var m = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), g = Object.prototype.hasOwnProperty, b = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, C = {}, E = {};
  function x(a) {
    return g.call(E, a) ? !0 : g.call(C, a) ? !1 : b.test(a) ? E[a] = !0 : (C[a] = !0, !1);
  }
  function O(a, s, p, v) {
    if (p !== null && p.type === 0)
      return !1;
    switch (typeof s) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return v ? !1 : p !== null ? !p.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function N(a, s, p, v) {
    if (s === null || typeof s > "u" || O(a, s, p, v))
      return !0;
    if (v)
      return !1;
    if (p !== null)
      switch (p.type) {
        case 3:
          return !s;
        case 4:
          return s === !1;
        case 5:
          return isNaN(s);
        case 6:
          return isNaN(s) || 1 > s;
      }
    return !1;
  }
  function M(a, s, p, v, S, T, D) {
    this.acceptsBooleans = s === 2 || s === 3 || s === 4, this.attributeName = v, this.attributeNamespace = S, this.mustUseProperty = p, this.propertyName = a, this.type = s, this.sanitizeURL = T, this.removeEmptyString = D;
  }
  var I = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    I[a] = new M(a, 0, !1, a, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var s = a[0];
    I[s] = new M(s, 1, !1, a[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    I[a] = new M(a, 2, !1, a.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    I[a] = new M(a, 2, !1, a, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    I[a] = new M(a, 3, !1, a.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    I[a] = new M(a, 3, !0, a, null, !1, !1);
  }), ["capture", "download"].forEach(function(a) {
    I[a] = new M(a, 4, !1, a, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(a) {
    I[a] = new M(a, 6, !1, a, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(a) {
    I[a] = new M(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var U = /[\-:]([a-z])/g;
  function ae(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var s = a.replace(
      U,
      ae
    );
    I[s] = new M(s, 1, !1, a, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var s = a.replace(U, ae);
    I[s] = new M(s, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var s = a.replace(U, ae);
    I[s] = new M(s, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(a) {
    I[a] = new M(a, 1, !1, a.toLowerCase(), null, !1, !1);
  }), I.xlinkHref = new M("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(a) {
    I[a] = new M(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });
  function Z(a, s, p, v) {
    var S = I.hasOwnProperty(s) ? I[s] : null;
    (S !== null ? S.type !== 0 : v || !(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (N(s, p, S, v) && (p = null), v || S === null ? x(s) && (p === null ? a.removeAttribute(s) : a.setAttribute(s, "" + p)) : S.mustUseProperty ? a[S.propertyName] = p === null ? S.type === 3 ? !1 : "" : p : (s = S.attributeName, v = S.attributeNamespace, p === null ? a.removeAttribute(s) : (S = S.type, p = S === 3 || S === 4 && p === !0 ? "" : "" + p, v ? a.setAttributeNS(v, s, p) : a.setAttribute(s, p))));
  }
  var B = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, F = Symbol.for("react.element"), K = Symbol.for("react.portal"), te = Symbol.for("react.fragment"), he = Symbol.for("react.strict_mode"), pe = Symbol.for("react.profiler"), ye = Symbol.for("react.provider"), se = Symbol.for("react.context"), Ee = Symbol.for("react.forward_ref"), Ne = Symbol.for("react.suspense"), Je = Symbol.for("react.suspense_list"), vt = Symbol.for("react.memo"), Ct = Symbol.for("react.lazy"), Me = Symbol.for("react.offscreen"), Pe = Symbol.iterator;
  function Ze(a) {
    return a === null || typeof a != "object" ? null : (a = Pe && a[Pe] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var Ie = Object.assign, Y;
  function ge(a) {
    if (Y === void 0)
      try {
        throw Error();
      } catch (p) {
        var s = p.stack.trim().match(/\n( *(at )?)/);
        Y = s && s[1] || "";
      }
    return `
` + Y + a;
  }
  var lt = !1;
  function Be(a, s) {
    if (!a || lt)
      return "";
    lt = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (s)
        if (s = function() {
          throw Error();
        }, Object.defineProperty(s.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(s, []);
          } catch (oe) {
            var v = oe;
          }
          Reflect.construct(a, [], s);
        } else {
          try {
            s.call();
          } catch (oe) {
            v = oe;
          }
          a.call(s.prototype);
        }
      else {
        try {
          throw Error();
        } catch (oe) {
          v = oe;
        }
        a();
      }
    } catch (oe) {
      if (oe && v && typeof oe.stack == "string") {
        for (var S = oe.stack.split(`
`), T = v.stack.split(`
`), D = S.length - 1, j = T.length - 1; 1 <= D && 0 <= j && S[D] !== T[j]; )
          j--;
        for (; 1 <= D && 0 <= j; D--, j--)
          if (S[D] !== T[j]) {
            if (D !== 1 || j !== 1)
              do
                if (D--, j--, 0 > j || S[D] !== T[j]) {
                  var H = `
` + S[D].replace(" at new ", " at ");
                  return a.displayName && H.includes("<anonymous>") && (H = H.replace("<anonymous>", a.displayName)), H;
                }
              while (1 <= D && 0 <= j);
            break;
          }
      }
    } finally {
      lt = !1, Error.prepareStackTrace = p;
    }
    return (a = a ? a.displayName || a.name : "") ? ge(a) : "";
  }
  function kt(a) {
    switch (a.tag) {
      case 5:
        return ge(a.type);
      case 16:
        return ge("Lazy");
      case 13:
        return ge("Suspense");
      case 19:
        return ge("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Be(a.type, !1), a;
      case 11:
        return a = Be(a.type.render, !1), a;
      case 1:
        return a = Be(a.type, !0), a;
      default:
        return "";
    }
  }
  function Rt(a) {
    if (a == null)
      return null;
    if (typeof a == "function")
      return a.displayName || a.name || null;
    if (typeof a == "string")
      return a;
    switch (a) {
      case te:
        return "Fragment";
      case K:
        return "Portal";
      case pe:
        return "Profiler";
      case he:
        return "StrictMode";
      case Ne:
        return "Suspense";
      case Je:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case se:
          return (a.displayName || "Context") + ".Consumer";
        case ye:
          return (a._context.displayName || "Context") + ".Provider";
        case Ee:
          var s = a.render;
          return a = a.displayName, a || (a = s.displayName || s.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case vt:
          return s = a.displayName || null, s !== null ? s : Rt(a.type) || "Memo";
        case Ct:
          s = a._payload, a = a._init;
          try {
            return Rt(a(s));
          } catch {
          }
      }
    return null;
  }
  function Ft(a) {
    var s = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (s.displayName || "Context") + ".Consumer";
      case 10:
        return (s._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = s.render, a = a.displayName || a.name || "", s.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return s;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Rt(s);
      case 8:
        return s === he ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof s == "function")
          return s.displayName || s.name || null;
        if (typeof s == "string")
          return s;
    }
    return null;
  }
  function Dt(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ot(a) {
    var s = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
  }
  function yn(a) {
    var s = Ot(a) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(a.constructor.prototype, s), v = "" + a[s];
    if (!a.hasOwnProperty(s) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
      var S = p.get, T = p.set;
      return Object.defineProperty(a, s, { configurable: !0, get: function() {
        return S.call(this);
      }, set: function(D) {
        v = "" + D, T.call(this, D);
      } }), Object.defineProperty(a, s, { enumerable: p.enumerable }), { getValue: function() {
        return v;
      }, setValue: function(D) {
        v = "" + D;
      }, stopTracking: function() {
        a._valueTracker = null, delete a[s];
      } };
    }
  }
  function Vr(a) {
    a._valueTracker || (a._valueTracker = yn(a));
  }
  function yi(a) {
    if (!a)
      return !1;
    var s = a._valueTracker;
    if (!s)
      return !0;
    var p = s.getValue(), v = "";
    return a && (v = Ot(a) ? a.checked ? "true" : "false" : a.value), a = v, a !== p ? (s.setValue(a), !0) : !1;
  }
  function Nn(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function yr(a, s) {
    var p = s.checked;
    return Ie({}, s, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: p ?? a._wrapperState.initialChecked });
  }
  function ur(a, s) {
    var p = s.defaultValue == null ? "" : s.defaultValue, v = s.checked != null ? s.checked : s.defaultChecked;
    p = Dt(s.value != null ? s.value : p), a._wrapperState = { initialChecked: v, initialValue: p, controlled: s.type === "checkbox" || s.type === "radio" ? s.checked != null : s.value != null };
  }
  function er(a, s) {
    s = s.checked, s != null && Z(a, "checked", s, !1);
  }
  function Yn(a, s) {
    er(a, s);
    var p = Dt(s.value), v = s.type;
    if (p != null)
      v === "number" ? (p === 0 && a.value === "" || a.value != p) && (a.value = "" + p) : a.value !== "" + p && (a.value = "" + p);
    else if (v === "submit" || v === "reset") {
      a.removeAttribute("value");
      return;
    }
    s.hasOwnProperty("value") ? Si(a, s.type, p) : s.hasOwnProperty("defaultValue") && Si(a, s.type, Dt(s.defaultValue)), s.checked == null && s.defaultChecked != null && (a.defaultChecked = !!s.defaultChecked);
  }
  function bi(a, s, p) {
    if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
      var v = s.type;
      if (!(v !== "submit" && v !== "reset" || s.value !== void 0 && s.value !== null))
        return;
      s = "" + a._wrapperState.initialValue, p || s === a.value || (a.value = s), a.defaultValue = s;
    }
    p = a.name, p !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, p !== "" && (a.name = p);
  }
  function Si(a, s, p) {
    (s !== "number" || Nn(a.ownerDocument) !== a) && (p == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + p && (a.defaultValue = "" + p));
  }
  var br = Array.isArray;
  function Br(a, s, p, v) {
    if (a = a.options, s) {
      s = {};
      for (var S = 0; S < p.length; S++)
        s["$" + p[S]] = !0;
      for (p = 0; p < a.length; p++)
        S = s.hasOwnProperty("$" + a[p].value), a[p].selected !== S && (a[p].selected = S), S && v && (a[p].defaultSelected = !0);
    } else {
      for (p = "" + Dt(p), s = null, S = 0; S < a.length; S++) {
        if (a[S].value === p) {
          a[S].selected = !0, v && (a[S].defaultSelected = !0);
          return;
        }
        s !== null || a[S].disabled || (s = a[S]);
      }
      s !== null && (s.selected = !0);
    }
  }
  function Ci(a, s) {
    if (s.dangerouslySetInnerHTML != null)
      throw Error(i(91));
    return Ie({}, s, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function Hr(a, s) {
    var p = s.value;
    if (p == null) {
      if (p = s.children, s = s.defaultValue, p != null) {
        if (s != null)
          throw Error(i(92));
        if (br(p)) {
          if (1 < p.length)
            throw Error(i(93));
          p = p[0];
        }
        s = p;
      }
      s == null && (s = ""), p = s;
    }
    a._wrapperState = { initialValue: Dt(p) };
  }
  function qi(a, s) {
    var p = Dt(s.value), v = Dt(s.defaultValue);
    p != null && (p = "" + p, p !== a.value && (a.value = p), s.defaultValue == null && a.defaultValue !== p && (a.defaultValue = p)), v != null && (a.defaultValue = "" + v);
  }
  function xr(a) {
    var s = a.textContent;
    s === a._wrapperState.initialValue && s !== "" && s !== null && (a.value = s);
  }
  function ki(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ln(a, s) {
    return a == null || a === "http://www.w3.org/1999/xhtml" ? ki(s) : a === "http://www.w3.org/2000/svg" && s === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
  }
  var Zr, eo = function(a) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(s, p, v, S) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(s, p, v, S);
      });
    } : a;
  }(function(a, s) {
    if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
      a.innerHTML = s;
    else {
      for (Zr = Zr || document.createElement("div"), Zr.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>", s = Zr.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; s.firstChild; )
        a.appendChild(s.firstChild);
    }
  });
  function Wi(a, s) {
    if (s) {
      var p = a.firstChild;
      if (p && p === a.lastChild && p.nodeType === 3) {
        p.nodeValue = s;
        return;
      }
    }
    a.textContent = s;
  }
  var Ae = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, at = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ae).forEach(function(a) {
    at.forEach(function(s) {
      s = s + a.charAt(0).toUpperCase() + a.substring(1), Ae[s] = Ae[a];
    });
  });
  function _t(a, s, p) {
    return s == null || typeof s == "boolean" || s === "" ? "" : p || typeof s != "number" || s === 0 || Ae.hasOwnProperty(a) && Ae[a] ? ("" + s).trim() : s + "px";
  }
  function en(a, s) {
    a = a.style;
    for (var p in s)
      if (s.hasOwnProperty(p)) {
        var v = p.indexOf("--") === 0, S = _t(p, s[p], v);
        p === "float" && (p = "cssFloat"), v ? a.setProperty(p, S) : a[p] = S;
      }
  }
  var rn = Ie({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Kn(a, s) {
    if (s) {
      if (rn[a] && (s.children != null || s.dangerouslySetInnerHTML != null))
        throw Error(i(137, a));
      if (s.dangerouslySetInnerHTML != null) {
        if (s.children != null)
          throw Error(i(60));
        if (typeof s.dangerouslySetInnerHTML != "object" || !("__html" in s.dangerouslySetInnerHTML))
          throw Error(i(61));
      }
      if (s.style != null && typeof s.style != "object")
        throw Error(i(62));
    }
  }
  function An(a, s) {
    if (a.indexOf("-") === -1)
      return typeof s.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var $r = null;
  function cn(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var ei = null, an = null, on = null;
  function ja(a) {
    if (a = Bc(a)) {
      if (typeof ei != "function")
        throw Error(i(280));
      var s = a.stateNode;
      s && (s = st(s), ei(a.stateNode, a.type, s));
    }
  }
  function la(a) {
    an ? on ? on.push(a) : on = [a] : an = a;
  }
  function hs() {
    if (an) {
      var a = an, s = on;
      if (on = an = null, ja(a), s)
        for (a = 0; a < s.length; a++)
          ja(s[a]);
    }
  }
  function ol(a, s) {
    return a(s);
  }
  function eu() {
  }
  var Ro = !1;
  function ms(a, s, p) {
    if (Ro)
      return a(s, p);
    Ro = !0;
    try {
      return ol(a, s, p);
    } finally {
      Ro = !1, (an !== null || on !== null) && (eu(), hs());
    }
  }
  function Gi(a, s) {
    var p = a.stateNode;
    if (p === null)
      return null;
    var v = st(p);
    if (v === null)
      return null;
    p = v[s];
    e:
      switch (s) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (v = !v.disabled) || (a = a.type, v = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !v;
          break e;
        default:
          a = !1;
      }
    if (a)
      return null;
    if (p && typeof p != "function")
      throw Error(i(231, s, typeof p));
    return p;
  }
  var to = !1;
  if (m)
    try {
      var Yi = {};
      Object.defineProperty(Yi, "passive", { get: function() {
        to = !0;
      } }), window.addEventListener("test", Yi, Yi), window.removeEventListener("test", Yi, Yi);
    } catch {
      to = !1;
    }
  function za(a, s, p, v, S, T, D, j, H) {
    var oe = Array.prototype.slice.call(arguments, 3);
    try {
      s.apply(p, oe);
    } catch (we) {
      this.onError(we);
    }
  }
  var ti = !1, Ki = null, no = !1, ro = null, V = { onError: function(a) {
    ti = !0, Ki = a;
  } };
  function ke(a, s, p, v, S, T, D, j, H) {
    ti = !1, Ki = null, za.apply(V, arguments);
  }
  function _e(a, s, p, v, S, T, D, j, H) {
    if (ke.apply(this, arguments), ti) {
      if (ti) {
        var oe = Ki;
        ti = !1, Ki = null;
      } else
        throw Error(i(198));
      no || (no = !0, ro = oe);
    }
  }
  function nt(a) {
    var s = a, p = a;
    if (a.alternate)
      for (; s.return; )
        s = s.return;
    else {
      a = s;
      do
        s = a, s.flags & 4098 && (p = s.return), a = s.return;
      while (a);
    }
    return s.tag === 3 ? p : null;
  }
  function Nt(a) {
    if (a.tag === 13) {
      var s = a.memoizedState;
      if (s === null && (a = a.alternate, a !== null && (s = a.memoizedState)), s !== null)
        return s.dehydrated;
    }
    return null;
  }
  function jt(a) {
    if (nt(a) !== a)
      throw Error(i(188));
  }
  function dt(a) {
    var s = a.alternate;
    if (!s) {
      if (s = nt(a), s === null)
        throw Error(i(188));
      return s !== a ? null : a;
    }
    for (var p = a, v = s; ; ) {
      var S = p.return;
      if (S === null)
        break;
      var T = S.alternate;
      if (T === null) {
        if (v = S.return, v !== null) {
          p = v;
          continue;
        }
        break;
      }
      if (S.child === T.child) {
        for (T = S.child; T; ) {
          if (T === p)
            return jt(S), a;
          if (T === v)
            return jt(S), s;
          T = T.sibling;
        }
        throw Error(i(188));
      }
      if (p.return !== v.return)
        p = S, v = T;
      else {
        for (var D = !1, j = S.child; j; ) {
          if (j === p) {
            D = !0, p = S, v = T;
            break;
          }
          if (j === v) {
            D = !0, v = S, p = T;
            break;
          }
          j = j.sibling;
        }
        if (!D) {
          for (j = T.child; j; ) {
            if (j === p) {
              D = !0, p = T, v = S;
              break;
            }
            if (j === v) {
              D = !0, v = T, p = S;
              break;
            }
            j = j.sibling;
          }
          if (!D)
            throw Error(i(189));
        }
      }
      if (p.alternate !== v)
        throw Error(i(190));
    }
    if (p.tag !== 3)
      throw Error(i(188));
    return p.stateNode.current === p ? a : s;
  }
  function xt(a) {
    return a = dt(a), a !== null ? tr(a) : null;
  }
  function tr(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      var s = tr(a);
      if (s !== null)
        return s;
      a = a.sibling;
    }
    return null;
  }
  var hn = t.unstable_scheduleCallback, kn = t.unstable_cancelCallback, qr = t.unstable_shouldYield, io = t.unstable_requestPaint, Kt = t.unstable_now, Sr = t.unstable_getCurrentPriorityLevel, ni = t.unstable_ImmediatePriority, Pt = t.unstable_UserBlockingPriority, ua = t.unstable_NormalPriority, vs = t.unstable_LowPriority, tu = t.unstable_IdlePriority, gs = null, Ti = null;
  function wc(a) {
    if (Ti && typeof Ti.onCommitFiberRoot == "function")
      try {
        Ti.onCommitFiberRoot(gs, a, void 0, (a.current.flags & 128) === 128);
      } catch {
      }
  }
  var ri = Math.clz32 ? Math.clz32 : Vd, Rc = Math.log, _c = Math.LN2;
  function Vd(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (Rc(a) / _c | 0) | 0;
  }
  var nu = 64, ys = 4194304;
  function Va(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function ii(a, s) {
    var p = a.pendingLanes;
    if (p === 0)
      return 0;
    var v = 0, S = a.suspendedLanes, T = a.pingedLanes, D = p & 268435455;
    if (D !== 0) {
      var j = D & ~S;
      j !== 0 ? v = Va(j) : (T &= D, T !== 0 && (v = Va(T)));
    } else
      D = p & ~S, D !== 0 ? v = Va(D) : T !== 0 && (v = Va(T));
    if (v === 0)
      return 0;
    if (s !== 0 && s !== v && !(s & S) && (S = v & -v, T = s & -s, S >= T || S === 16 && (T & 4194240) !== 0))
      return s;
    if (v & 4 && (v |= p & 16), s = a.entangledLanes, s !== 0)
      for (a = a.entanglements, s &= v; 0 < s; )
        p = 31 - ri(s), S = 1 << p, v |= a[p], s &= ~S;
    return v;
  }
  function bs(a, s) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return s + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ss(a, s) {
    for (var p = a.suspendedLanes, v = a.pingedLanes, S = a.expirationTimes, T = a.pendingLanes; 0 < T; ) {
      var D = 31 - ri(T), j = 1 << D, H = S[D];
      H === -1 ? (!(j & p) || j & v) && (S[D] = bs(j, s)) : H <= s && (a.expiredLanes |= j), T &= ~j;
    }
  }
  function Cs(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function ru() {
    var a = nu;
    return nu <<= 1, !(nu & 4194240) && (nu = 64), a;
  }
  function iu(a) {
    for (var s = [], p = 0; 31 > p; p++)
      s.push(a);
    return s;
  }
  function _o(a, s, p) {
    a.pendingLanes |= s, s !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, s = 31 - ri(s), a[s] = p;
  }
  function ih(a, s) {
    var p = a.pendingLanes & ~s;
    a.pendingLanes = s, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= s, a.mutableReadLanes &= s, a.entangledLanes &= s, s = a.entanglements;
    var v = a.eventTimes;
    for (a = a.expirationTimes; 0 < p; ) {
      var S = 31 - ri(p), T = 1 << S;
      s[S] = 0, v[S] = -1, a[S] = -1, p &= ~T;
    }
  }
  function ao(a, s) {
    var p = a.entangledLanes |= s;
    for (a = a.entanglements; p; ) {
      var v = 31 - ri(p), S = 1 << v;
      S & s | a[v] & s && (a[v] |= s), p &= ~S;
    }
  }
  var Qt = 0;
  function au(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var sl, ou, zt, su, lu, bt = !1, ll = [], In = null, Ei = null, ai = null, ks = /* @__PURE__ */ new Map(), Vn = /* @__PURE__ */ new Map(), sn = [], Bd = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function wi(a, s) {
    switch (a) {
      case "focusin":
      case "focusout":
        In = null;
        break;
      case "dragenter":
      case "dragleave":
        Ei = null;
        break;
      case "mouseover":
      case "mouseout":
        ai = null;
        break;
      case "pointerover":
      case "pointerout":
        ks.delete(s.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Vn.delete(s.pointerId);
    }
  }
  function Cr(a, s, p, v, S, T) {
    return a === null || a.nativeEvent !== T ? (a = { blockedOn: s, domEventName: p, eventSystemFlags: v, nativeEvent: T, targetContainers: [S] }, s !== null && (s = Bc(s), s !== null && ou(s)), a) : (a.eventSystemFlags |= v, s = a.targetContainers, S !== null && s.indexOf(S) === -1 && s.push(S), a);
  }
  function oo(a, s, p, v, S) {
    switch (s) {
      case "focusin":
        return In = Cr(In, a, s, p, v, S), !0;
      case "dragenter":
        return Ei = Cr(Ei, a, s, p, v, S), !0;
      case "mouseover":
        return ai = Cr(ai, a, s, p, v, S), !0;
      case "pointerover":
        var T = S.pointerId;
        return ks.set(T, Cr(ks.get(T) || null, a, s, p, v, S)), !0;
      case "gotpointercapture":
        return T = S.pointerId, Vn.set(T, Cr(Vn.get(T) || null, a, s, p, v, S)), !0;
    }
    return !1;
  }
  function Hd(a) {
    var s = pa(a.target);
    if (s !== null) {
      var p = nt(s);
      if (p !== null) {
        if (s = p.tag, s === 13) {
          if (s = Nt(p), s !== null) {
            a.blockedOn = s, lu(a.priority, function() {
              zt(p);
            });
            return;
          }
        } else if (s === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function xo(a) {
    if (a.blockedOn !== null)
      return !1;
    for (var s = a.targetContainers; 0 < s.length; ) {
      var p = cu(a.domEventName, a.eventSystemFlags, s[0], a.nativeEvent);
      if (p === null) {
        p = a.nativeEvent;
        var v = new p.constructor(p.type, p);
        $r = v, p.target.dispatchEvent(v), $r = null;
      } else
        return s = Bc(p), s !== null && ou(s), a.blockedOn = p, !1;
      s.shift();
    }
    return !0;
  }
  function Ts(a, s, p) {
    xo(a) && p.delete(s);
  }
  function $d() {
    bt = !1, In !== null && xo(In) && (In = null), Ei !== null && xo(Ei) && (Ei = null), ai !== null && xo(ai) && (ai = null), ks.forEach(Ts), Vn.forEach(Ts);
  }
  function ca(a, s) {
    a.blockedOn === s && (a.blockedOn = null, bt || (bt = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, $d)));
  }
  function Es(a) {
    function s(S) {
      return ca(S, a);
    }
    if (0 < ll.length) {
      ca(ll[0], a);
      for (var p = 1; p < ll.length; p++) {
        var v = ll[p];
        v.blockedOn === a && (v.blockedOn = null);
      }
    }
    for (In !== null && ca(In, a), Ei !== null && ca(Ei, a), ai !== null && ca(ai, a), ks.forEach(s), Vn.forEach(s), p = 0; p < sn.length; p++)
      v = sn[p], v.blockedOn === a && (v.blockedOn = null);
    for (; 0 < sn.length && (p = sn[0], p.blockedOn === null); )
      Hd(p), p.blockedOn === null && sn.shift();
  }
  var Po = B.ReactCurrentBatchConfig, da = !0;
  function uu(a, s, p, v) {
    var S = Qt, T = Po.transition;
    Po.transition = null;
    try {
      Qt = 1, Rs(a, s, p, v);
    } finally {
      Qt = S, Po.transition = T;
    }
  }
  function ws(a, s, p, v) {
    var S = Qt, T = Po.transition;
    Po.transition = null;
    try {
      Qt = 4, Rs(a, s, p, v);
    } finally {
      Qt = S, Po.transition = T;
    }
  }
  function Rs(a, s, p, v) {
    if (da) {
      var S = cu(a, s, p, v);
      if (S === null)
        Zd(a, s, v, ul, p), wi(a, v);
      else if (oo(S, a, s, p, v))
        v.stopPropagation();
      else if (wi(a, v), s & 4 && -1 < Bd.indexOf(a)) {
        for (; S !== null; ) {
          var T = Bc(S);
          if (T !== null && sl(T), T = cu(a, s, p, v), T === null && Zd(a, s, v, ul, p), T === S)
            break;
          S = T;
        }
        S !== null && v.stopPropagation();
      } else
        Zd(a, s, v, null, p);
    }
  }
  var ul = null;
  function cu(a, s, p, v) {
    if (ul = null, a = cn(v), a = pa(a), a !== null)
      if (s = nt(a), s === null)
        a = null;
      else if (p = s.tag, p === 13) {
        if (a = Nt(s), a !== null)
          return a;
        a = null;
      } else if (p === 3) {
        if (s.stateNode.current.memoizedState.isDehydrated)
          return s.tag === 3 ? s.stateNode.containerInfo : null;
        a = null;
      } else
        s !== a && (a = null);
    return ul = a, null;
  }
  function xc(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Sr()) {
          case ni:
            return 1;
          case Pt:
            return 4;
          case ua:
          case vs:
            return 16;
          case tu:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ba = null, P = null, z = null;
  function ie() {
    if (z)
      return z;
    var a, s = P, p = s.length, v, S = "value" in Ba ? Ba.value : Ba.textContent, T = S.length;
    for (a = 0; a < p && s[a] === S[a]; a++)
      ;
    var D = p - a;
    for (v = 1; v <= D && s[p - v] === S[T - v]; v++)
      ;
    return z = S.slice(a, 1 < v ? 1 - v : void 0);
  }
  function de(a) {
    var s = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && s === 13 && (a = 13)) : a = s, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function De() {
    return !0;
  }
  function ft() {
    return !1;
  }
  function je(a) {
    function s(p, v, S, T, D) {
      this._reactName = p, this._targetInst = S, this.type = v, this.nativeEvent = T, this.target = D, this.currentTarget = null;
      for (var j in a)
        a.hasOwnProperty(j) && (p = a[j], this[j] = p ? p(T) : T[j]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? De : ft, this.isPropagationStopped = ft, this;
    }
    return Ie(s.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var p = this.nativeEvent;
      p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = De);
    }, stopPropagation: function() {
      var p = this.nativeEvent;
      p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = De);
    }, persist: function() {
    }, isPersistent: De }), s;
  }
  var ct = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Lt = je(ct), Gt = Ie({}, ct, { view: 0, detail: 0 }), mn = je(Gt), dn, vn, bn, Vt = Ie({}, Gt, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: uh, button: 0, buttons: 0, relatedTarget: function(a) {
    return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    return "movementX" in a ? a.movementX : (a !== bn && (bn && a.type === "mousemove" ? (dn = a.screenX - bn.screenX, vn = a.screenY - bn.screenY) : vn = dn = 0, bn = a), dn);
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : vn;
  } }), Do = je(Vt), du = Ie({}, Vt, { dataTransfer: 0 }), Pc = je(du), ah = Ie({}, Gt, { relatedTarget: 0 }), Ha = je(ah), Dc = Ie({}, ct, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Oc = je(Dc), oh = Ie({}, ct, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Pb = je(oh), Db = Ie({}, ct, { data: 0 }), sh = je(Db), lh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Uv = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Fv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function jv(a) {
    var s = this.nativeEvent;
    return s.getModifierState ? s.getModifierState(a) : (a = Fv[a]) ? !!s[a] : !1;
  }
  function uh() {
    return jv;
  }
  var Oo = Ie({}, Gt, { key: function(a) {
    if (a.key) {
      var s = lh[a.key] || a.key;
      if (s !== "Unidentified")
        return s;
    }
    return a.type === "keypress" ? (a = de(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Uv[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: uh, charCode: function(a) {
    return a.type === "keypress" ? de(a) : 0;
  }, keyCode: function(a) {
    return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  }, which: function(a) {
    return a.type === "keypress" ? de(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  } }), Ob = je(Oo), ch = Ie({}, Vt, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), qd = je(ch), dh = Ie({}, Gt, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: uh }), Mb = je(dh), Wd = Ie({}, ct, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zv = je(Wd), Ri = Ie({}, Vt, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Mo = je(Ri), nr = [9, 13, 27, 32], $a = m && "CompositionEvent" in window, cl = null;
  m && "documentMode" in document && (cl = document.documentMode);
  var Gd = m && "TextEvent" in window && !cl, Vv = m && (!$a || cl && 8 < cl && 11 >= cl), fu = String.fromCharCode(32), Bv = !1;
  function Hv(a, s) {
    switch (a) {
      case "keyup":
        return nr.indexOf(s.keyCode) !== -1;
      case "keydown":
        return s.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Yd(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var pu = !1;
  function Nb(a, s) {
    switch (a) {
      case "compositionend":
        return Yd(s);
      case "keypress":
        return s.which !== 32 ? null : (Bv = !0, fu);
      case "textInput":
        return a = s.data, a === fu && Bv ? null : a;
      default:
        return null;
    }
  }
  function Lb(a, s) {
    if (pu)
      return a === "compositionend" || !$a && Hv(a, s) ? (a = ie(), z = P = Ba = null, pu = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
          if (s.char && 1 < s.char.length)
            return s.char;
          if (s.which)
            return String.fromCharCode(s.which);
        }
        return null;
      case "compositionend":
        return Vv && s.locale !== "ko" ? null : s.data;
      default:
        return null;
    }
  }
  var $v = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function qv(a) {
    var s = a && a.nodeName && a.nodeName.toLowerCase();
    return s === "input" ? !!$v[a.type] : s === "textarea";
  }
  function Wv(a, s, p, v) {
    la(v), s = jc(s, "onChange"), 0 < s.length && (p = new Lt("onChange", "change", null, p, v), a.push({ event: p, listeners: s }));
  }
  var Mc = null, hu = null;
  function mu(a) {
    Xd(a, 0);
  }
  function vu(a) {
    var s = yu(a);
    if (yi(s))
      return a;
  }
  function Gv(a, s) {
    if (a === "change")
      return s;
  }
  var fh = !1;
  if (m) {
    var ph;
    if (m) {
      var hh = "oninput" in document;
      if (!hh) {
        var Yv = document.createElement("div");
        Yv.setAttribute("oninput", "return;"), hh = typeof Yv.oninput == "function";
      }
      ph = hh;
    } else
      ph = !1;
    fh = ph && (!document.documentMode || 9 < document.documentMode);
  }
  function Kv() {
    Mc && (Mc.detachEvent("onpropertychange", Qv), hu = Mc = null);
  }
  function Qv(a) {
    if (a.propertyName === "value" && vu(hu)) {
      var s = [];
      Wv(s, hu, a, cn(a)), ms(mu, s);
    }
  }
  function Ab(a, s, p) {
    a === "focusin" ? (Kv(), Mc = s, hu = p, Mc.attachEvent("onpropertychange", Qv)) : a === "focusout" && Kv();
  }
  function Ib(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return vu(hu);
  }
  function Ub(a, s) {
    if (a === "click")
      return vu(s);
  }
  function Jv(a, s) {
    if (a === "input" || a === "change")
      return vu(s);
  }
  function Fb(a, s) {
    return a === s && (a !== 0 || 1 / a === 1 / s) || a !== a && s !== s;
  }
  var fa = typeof Object.is == "function" ? Object.is : Fb;
  function Nc(a, s) {
    if (fa(a, s))
      return !0;
    if (typeof a != "object" || a === null || typeof s != "object" || s === null)
      return !1;
    var p = Object.keys(a), v = Object.keys(s);
    if (p.length !== v.length)
      return !1;
    for (v = 0; v < p.length; v++) {
      var S = p[v];
      if (!g.call(s, S) || !fa(a[S], s[S]))
        return !1;
    }
    return !0;
  }
  function Xv(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function Zv(a, s) {
    var p = Xv(a);
    a = 0;
    for (var v; p; ) {
      if (p.nodeType === 3) {
        if (v = a + p.textContent.length, a <= s && v >= s)
          return { node: p, offset: s - a };
        a = v;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = Xv(p);
    }
  }
  function eg(a, s) {
    return a && s ? a === s ? !0 : a && a.nodeType === 3 ? !1 : s && s.nodeType === 3 ? eg(a, s.parentNode) : "contains" in a ? a.contains(s) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(s) & 16) : !1 : !1;
  }
  function Kd() {
    for (var a = window, s = Nn(); s instanceof a.HTMLIFrameElement; ) {
      try {
        var p = typeof s.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p)
        a = s.contentWindow;
      else
        break;
      s = Nn(a.document);
    }
    return s;
  }
  function No(a) {
    var s = a && a.nodeName && a.nodeName.toLowerCase();
    return s && (s === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || s === "textarea" || a.contentEditable === "true");
  }
  function Qd(a) {
    var s = Kd(), p = a.focusedElem, v = a.selectionRange;
    if (s !== p && p && p.ownerDocument && eg(p.ownerDocument.documentElement, p)) {
      if (v !== null && No(p)) {
        if (s = v.start, a = v.end, a === void 0 && (a = s), "selectionStart" in p)
          p.selectionStart = s, p.selectionEnd = Math.min(a, p.value.length);
        else if (a = (s = p.ownerDocument || document) && s.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var S = p.textContent.length, T = Math.min(v.start, S);
          v = v.end === void 0 ? T : Math.min(v.end, S), !a.extend && T > v && (S = v, v = T, T = S), S = Zv(p, T);
          var D = Zv(
            p,
            v
          );
          S && D && (a.rangeCount !== 1 || a.anchorNode !== S.node || a.anchorOffset !== S.offset || a.focusNode !== D.node || a.focusOffset !== D.offset) && (s = s.createRange(), s.setStart(S.node, S.offset), a.removeAllRanges(), T > v ? (a.addRange(s), a.extend(D.node, D.offset)) : (s.setEnd(D.node, D.offset), a.addRange(s)));
        }
      }
      for (s = [], a = p; a = a.parentNode; )
        a.nodeType === 1 && s.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof p.focus == "function" && p.focus(), p = 0; p < s.length; p++)
        a = s[p], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var tg = m && "documentMode" in document && 11 >= document.documentMode, qa = null, mh = null, Lc = null, vh = !1;
  function ng(a, s, p) {
    var v = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    vh || qa == null || qa !== Nn(v) || (v = qa, "selectionStart" in v && No(v) ? v = { start: v.selectionStart, end: v.selectionEnd } : (v = (v.ownerDocument && v.ownerDocument.defaultView || window).getSelection(), v = { anchorNode: v.anchorNode, anchorOffset: v.anchorOffset, focusNode: v.focusNode, focusOffset: v.focusOffset }), Lc && Nc(Lc, v) || (Lc = v, v = jc(mh, "onSelect"), 0 < v.length && (s = new Lt("onSelect", "select", null, s, p), a.push({ event: s, listeners: v }), s.target = qa)));
  }
  function Jd(a, s) {
    var p = {};
    return p[a.toLowerCase()] = s.toLowerCase(), p["Webkit" + a] = "webkit" + s, p["Moz" + a] = "moz" + s, p;
  }
  var dl = { animationend: Jd("Animation", "AnimationEnd"), animationiteration: Jd("Animation", "AnimationIteration"), animationstart: Jd("Animation", "AnimationStart"), transitionend: Jd("Transition", "TransitionEnd") }, gh = {}, yh = {};
  m && (yh = document.createElement("div").style, "AnimationEvent" in window || (delete dl.animationend.animation, delete dl.animationiteration.animation, delete dl.animationstart.animation), "TransitionEvent" in window || delete dl.transitionend.transition);
  function kr(a) {
    if (gh[a])
      return gh[a];
    if (!dl[a])
      return a;
    var s = dl[a], p;
    for (p in s)
      if (s.hasOwnProperty(p) && p in yh)
        return gh[a] = s[p];
    return a;
  }
  var bh = kr("animationend"), rg = kr("animationiteration"), ig = kr("animationstart"), ag = kr("transitionend"), og = /* @__PURE__ */ new Map(), sg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Lo(a, s) {
    og.set(a, s), d(s, [a]);
  }
  for (var Ac = 0; Ac < sg.length; Ac++) {
    var fl = sg[Ac], jb = fl.toLowerCase(), Ic = fl[0].toUpperCase() + fl.slice(1);
    Lo(jb, "on" + Ic);
  }
  Lo(bh, "onAnimationEnd"), Lo(rg, "onAnimationIteration"), Lo(ig, "onAnimationStart"), Lo("dblclick", "onDoubleClick"), Lo("focusin", "onFocus"), Lo("focusout", "onBlur"), Lo(ag, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), d("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), d("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), d("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), d("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Uc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), zb = new Set("cancel close invalid load scroll toggle".split(" ").concat(Uc));
  function lg(a, s, p) {
    var v = a.type || "unknown-event";
    a.currentTarget = p, _e(v, s, void 0, a), a.currentTarget = null;
  }
  function Xd(a, s) {
    s = (s & 4) !== 0;
    for (var p = 0; p < a.length; p++) {
      var v = a[p], S = v.event;
      v = v.listeners;
      e: {
        var T = void 0;
        if (s)
          for (var D = v.length - 1; 0 <= D; D--) {
            var j = v[D], H = j.instance, oe = j.currentTarget;
            if (j = j.listener, H !== T && S.isPropagationStopped())
              break e;
            lg(S, j, oe), T = H;
          }
        else
          for (D = 0; D < v.length; D++) {
            if (j = v[D], H = j.instance, oe = j.currentTarget, j = j.listener, H !== T && S.isPropagationStopped())
              break e;
            lg(S, j, oe), T = H;
          }
      }
    }
    if (no)
      throw a = ro, no = !1, ro = null, a;
  }
  function gn(a, s) {
    var p = s[Rh];
    p === void 0 && (p = s[Rh] = /* @__PURE__ */ new Set());
    var v = a + "__bubble";
    p.has(v) || (ug(s, a, 2, !1), p.add(v));
  }
  function _s(a, s, p) {
    var v = 0;
    s && (v |= 4), ug(p, a, v, s);
  }
  var Ao = "_reactListening" + Math.random().toString(36).slice(2);
  function gu(a) {
    if (!a[Ao]) {
      a[Ao] = !0, o.forEach(function(p) {
        p !== "selectionchange" && (zb.has(p) || _s(p, !1, a), _s(p, !0, a));
      });
      var s = a.nodeType === 9 ? a : a.ownerDocument;
      s === null || s[Ao] || (s[Ao] = !0, _s("selectionchange", !1, s));
    }
  }
  function ug(a, s, p, v) {
    switch (xc(s)) {
      case 1:
        var S = uu;
        break;
      case 4:
        S = ws;
        break;
      default:
        S = Rs;
    }
    p = S.bind(null, s, p, a), S = void 0, !to || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (S = !0), v ? S !== void 0 ? a.addEventListener(s, p, { capture: !0, passive: S }) : a.addEventListener(s, p, !0) : S !== void 0 ? a.addEventListener(s, p, { passive: S }) : a.addEventListener(s, p, !1);
  }
  function Zd(a, s, p, v, S) {
    var T = v;
    if (!(s & 1) && !(s & 2) && v !== null)
      e:
        for (; ; ) {
          if (v === null)
            return;
          var D = v.tag;
          if (D === 3 || D === 4) {
            var j = v.stateNode.containerInfo;
            if (j === S || j.nodeType === 8 && j.parentNode === S)
              break;
            if (D === 4)
              for (D = v.return; D !== null; ) {
                var H = D.tag;
                if ((H === 3 || H === 4) && (H = D.stateNode.containerInfo, H === S || H.nodeType === 8 && H.parentNode === S))
                  return;
                D = D.return;
              }
            for (; j !== null; ) {
              if (D = pa(j), D === null)
                return;
              if (H = D.tag, H === 5 || H === 6) {
                v = T = D;
                continue e;
              }
              j = j.parentNode;
            }
          }
          v = v.return;
        }
    ms(function() {
      var oe = T, we = cn(p), Re = [];
      e: {
        var Te = og.get(a);
        if (Te !== void 0) {
          var He = Lt, Ye = a;
          switch (a) {
            case "keypress":
              if (de(p) === 0)
                break e;
            case "keydown":
            case "keyup":
              He = Ob;
              break;
            case "focusin":
              Ye = "focus", He = Ha;
              break;
            case "focusout":
              Ye = "blur", He = Ha;
              break;
            case "beforeblur":
            case "afterblur":
              He = Ha;
              break;
            case "click":
              if (p.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              He = Do;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              He = Pc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              He = Mb;
              break;
            case bh:
            case rg:
            case ig:
              He = Oc;
              break;
            case ag:
              He = zv;
              break;
            case "scroll":
              He = mn;
              break;
            case "wheel":
              He = Mo;
              break;
            case "copy":
            case "cut":
            case "paste":
              He = Pb;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              He = qd;
          }
          var Xe = (s & 4) !== 0, Xn = !Xe && a === "scroll", Q = Xe ? Te !== null ? Te + "Capture" : null : Te;
          Xe = [];
          for (var q = oe, ee; q !== null; ) {
            ee = q;
            var Oe = ee.stateNode;
            if (ee.tag === 5 && Oe !== null && (ee = Oe, Q !== null && (Oe = Gi(q, Q), Oe != null && Xe.push(Fc(q, Oe, ee)))), Xn)
              break;
            q = q.return;
          }
          0 < Xe.length && (Te = new He(Te, Ye, null, p, we), Re.push({ event: Te, listeners: Xe }));
        }
      }
      if (!(s & 7)) {
        e: {
          if (Te = a === "mouseover" || a === "pointerover", He = a === "mouseout" || a === "pointerout", Te && p !== $r && (Ye = p.relatedTarget || p.fromElement) && (pa(Ye) || Ye[Io]))
            break e;
          if ((He || Te) && (Te = we.window === we ? we : (Te = we.ownerDocument) ? Te.defaultView || Te.parentWindow : window, He ? (Ye = p.relatedTarget || p.toElement, He = oe, Ye = Ye ? pa(Ye) : null, Ye !== null && (Xn = nt(Ye), Ye !== Xn || Ye.tag !== 5 && Ye.tag !== 6) && (Ye = null)) : (He = null, Ye = oe), He !== Ye)) {
            if (Xe = Do, Oe = "onMouseLeave", Q = "onMouseEnter", q = "mouse", (a === "pointerout" || a === "pointerover") && (Xe = qd, Oe = "onPointerLeave", Q = "onPointerEnter", q = "pointer"), Xn = He == null ? Te : yu(He), ee = Ye == null ? Te : yu(Ye), Te = new Xe(Oe, q + "leave", He, p, we), Te.target = Xn, Te.relatedTarget = ee, Oe = null, pa(we) === oe && (Xe = new Xe(Q, q + "enter", Ye, p, we), Xe.target = ee, Xe.relatedTarget = Xn, Oe = Xe), Xn = Oe, He && Ye)
              t: {
                for (Xe = He, Q = Ye, q = 0, ee = Xe; ee; ee = pl(ee))
                  q++;
                for (ee = 0, Oe = Q; Oe; Oe = pl(Oe))
                  ee++;
                for (; 0 < q - ee; )
                  Xe = pl(Xe), q--;
                for (; 0 < ee - q; )
                  Q = pl(Q), ee--;
                for (; q--; ) {
                  if (Xe === Q || Q !== null && Xe === Q.alternate)
                    break t;
                  Xe = pl(Xe), Q = pl(Q);
                }
                Xe = null;
              }
            else
              Xe = null;
            He !== null && Sh(Re, Te, He, Xe, !1), Ye !== null && Xn !== null && Sh(Re, Xn, Ye, Xe, !0);
          }
        }
        e: {
          if (Te = oe ? yu(oe) : window, He = Te.nodeName && Te.nodeName.toLowerCase(), He === "select" || He === "input" && Te.type === "file")
            var tt = Gv;
          else if (qv(Te))
            if (fh)
              tt = Jv;
            else {
              tt = Ib;
              var pt = Ab;
            }
          else
            (He = Te.nodeName) && He.toLowerCase() === "input" && (Te.type === "checkbox" || Te.type === "radio") && (tt = Ub);
          if (tt && (tt = tt(a, oe))) {
            Wv(Re, tt, p, we);
            break e;
          }
          pt && pt(a, Te, oe), a === "focusout" && (pt = Te._wrapperState) && pt.controlled && Te.type === "number" && Si(Te, "number", Te.value);
        }
        switch (pt = oe ? yu(oe) : window, a) {
          case "focusin":
            (qv(pt) || pt.contentEditable === "true") && (qa = pt, mh = oe, Lc = null);
            break;
          case "focusout":
            Lc = mh = qa = null;
            break;
          case "mousedown":
            vh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            vh = !1, ng(Re, p, we);
            break;
          case "selectionchange":
            if (tg)
              break;
          case "keydown":
          case "keyup":
            ng(Re, p, we);
        }
        var Ke;
        if ($a)
          e: {
            switch (a) {
              case "compositionstart":
                var ht = "onCompositionStart";
                break e;
              case "compositionend":
                ht = "onCompositionEnd";
                break e;
              case "compositionupdate":
                ht = "onCompositionUpdate";
                break e;
            }
            ht = void 0;
          }
        else
          pu ? Hv(a, p) && (ht = "onCompositionEnd") : a === "keydown" && p.keyCode === 229 && (ht = "onCompositionStart");
        ht && (Vv && p.locale !== "ko" && (pu || ht !== "onCompositionStart" ? ht === "onCompositionEnd" && pu && (Ke = ie()) : (Ba = we, P = "value" in Ba ? Ba.value : Ba.textContent, pu = !0)), pt = jc(oe, ht), 0 < pt.length && (ht = new sh(ht, a, null, p, we), Re.push({ event: ht, listeners: pt }), Ke ? ht.data = Ke : (Ke = Yd(p), Ke !== null && (ht.data = Ke)))), (Ke = Gd ? Nb(a, p) : Lb(a, p)) && (oe = jc(oe, "onBeforeInput"), 0 < oe.length && (we = new sh("onBeforeInput", "beforeinput", null, p, we), Re.push({ event: we, listeners: oe }), we.data = Ke));
      }
      Xd(Re, s);
    });
  }
  function Fc(a, s, p) {
    return { instance: a, listener: s, currentTarget: p };
  }
  function jc(a, s) {
    for (var p = s + "Capture", v = []; a !== null; ) {
      var S = a, T = S.stateNode;
      S.tag === 5 && T !== null && (S = T, T = Gi(a, p), T != null && v.unshift(Fc(a, T, S)), T = Gi(a, s), T != null && v.push(Fc(a, T, S))), a = a.return;
    }
    return v;
  }
  function pl(a) {
    if (a === null)
      return null;
    do
      a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function Sh(a, s, p, v, S) {
    for (var T = s._reactName, D = []; p !== null && p !== v; ) {
      var j = p, H = j.alternate, oe = j.stateNode;
      if (H !== null && H === v)
        break;
      j.tag === 5 && oe !== null && (j = oe, S ? (H = Gi(p, T), H != null && D.unshift(Fc(p, H, j))) : S || (H = Gi(p, T), H != null && D.push(Fc(p, H, j)))), p = p.return;
    }
    D.length !== 0 && a.push({ event: s, listeners: D });
  }
  var Ch = /\r\n?/g, Vb = /\u0000|\uFFFD/g;
  function kh(a) {
    return (typeof a == "string" ? a : "" + a).replace(Ch, `
`).replace(Vb, "");
  }
  function ef(a, s, p) {
    if (s = kh(s), kh(a) !== s && p)
      throw Error(i(425));
  }
  function tf() {
  }
  var Th = null, hl = null;
  function zc(a, s) {
    return a === "textarea" || a === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
  }
  var ml = typeof setTimeout == "function" ? setTimeout : void 0, cg = typeof clearTimeout == "function" ? clearTimeout : void 0, Eh = typeof Promise == "function" ? Promise : void 0, wh = typeof queueMicrotask == "function" ? queueMicrotask : typeof Eh < "u" ? function(a) {
    return Eh.resolve(null).then(a).catch(Bb);
  } : ml;
  function Bb(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function xs(a, s) {
    var p = s, v = 0;
    do {
      var S = p.nextSibling;
      if (a.removeChild(p), S && S.nodeType === 8)
        if (p = S.data, p === "/$") {
          if (v === 0) {
            a.removeChild(S), Es(s);
            return;
          }
          v--;
        } else
          p !== "$" && p !== "$?" && p !== "$!" || v++;
      p = S;
    } while (p);
    Es(s);
  }
  function Wa(a) {
    for (; a != null; a = a.nextSibling) {
      var s = a.nodeType;
      if (s === 1 || s === 3)
        break;
      if (s === 8) {
        if (s = a.data, s === "$" || s === "$!" || s === "$?")
          break;
        if (s === "/$")
          return null;
      }
    }
    return a;
  }
  function Vc(a) {
    a = a.previousSibling;
    for (var s = 0; a; ) {
      if (a.nodeType === 8) {
        var p = a.data;
        if (p === "$" || p === "$!" || p === "$?") {
          if (s === 0)
            return a;
          s--;
        } else
          p === "/$" && s++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Ps = Math.random().toString(36).slice(2), so = "__reactFiber$" + Ps, vl = "__reactProps$" + Ps, Io = "__reactContainer$" + Ps, Rh = "__reactEvents$" + Ps, Hb = "__reactListeners$" + Ps, _h = "__reactHandles$" + Ps;
  function pa(a) {
    var s = a[so];
    if (s)
      return s;
    for (var p = a.parentNode; p; ) {
      if (s = p[Io] || p[so]) {
        if (p = s.alternate, s.child !== null || p !== null && p.child !== null)
          for (a = Vc(a); a !== null; ) {
            if (p = a[so])
              return p;
            a = Vc(a);
          }
        return s;
      }
      a = p, p = a.parentNode;
    }
    return null;
  }
  function Bc(a) {
    return a = a[so] || a[Io], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
  }
  function yu(a) {
    if (a.tag === 5 || a.tag === 6)
      return a.stateNode;
    throw Error(i(33));
  }
  function st(a) {
    return a[vl] || null;
  }
  var Ds = [], Tn = -1;
  function wt(a) {
    return { current: a };
  }
  function tn(a) {
    0 > Tn || (a.current = Ds[Tn], Ds[Tn] = null, Tn--);
  }
  function ln(a, s) {
    Tn++, Ds[Tn] = a.current, a.current = s;
  }
  var lo = {}, gt = wt(lo), Bn = wt(!1), _i = lo;
  function ha(a, s) {
    var p = a.type.contextTypes;
    if (!p)
      return lo;
    var v = a.stateNode;
    if (v && v.__reactInternalMemoizedUnmaskedChildContext === s)
      return v.__reactInternalMemoizedMaskedChildContext;
    var S = {}, T;
    for (T in p)
      S[T] = s[T];
    return v && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = s, a.__reactInternalMemoizedMaskedChildContext = S), S;
  }
  function Pn(a) {
    return a = a.childContextTypes, a != null;
  }
  function ma() {
    tn(Bn), tn(gt);
  }
  function Os(a, s, p) {
    if (gt.current !== lo)
      throw Error(i(168));
    ln(gt, s), ln(Bn, p);
  }
  function Hc(a, s, p) {
    var v = a.stateNode;
    if (s = s.childContextTypes, typeof v.getChildContext != "function")
      return p;
    v = v.getChildContext();
    for (var S in v)
      if (!(S in s))
        throw Error(i(108, Ft(a) || "Unknown", S));
    return Ie({}, p, v);
  }
  function nf(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || lo, _i = gt.current, ln(gt, a), ln(Bn, Bn.current), !0;
  }
  function dg(a, s, p) {
    var v = a.stateNode;
    if (!v)
      throw Error(i(169));
    p ? (a = Hc(a, s, _i), v.__reactInternalMemoizedMergedChildContext = a, tn(Bn), tn(gt), ln(gt, a)) : tn(Bn), ln(Bn, p);
  }
  var Qi = null, Tr = !1, $c = !1;
  function xh(a) {
    Qi === null ? Qi = [a] : Qi.push(a);
  }
  function Ph(a) {
    Tr = !0, xh(a);
  }
  function xi() {
    if (!$c && Qi !== null) {
      $c = !0;
      var a = 0, s = Qt;
      try {
        var p = Qi;
        for (Qt = 1; a < p.length; a++) {
          var v = p[a];
          do
            v = v(!0);
          while (v !== null);
        }
        Qi = null, Tr = !1;
      } catch (S) {
        throw Qi !== null && (Qi = Qi.slice(a + 1)), hn(ni, xi), S;
      } finally {
        Qt = s, $c = !1;
      }
    }
    return null;
  }
  var Ms = [], Pi = 0, gl = null, bu = 0, Di = [], Wr = 0, va = null, Pr = 1, Uo = "";
  function Ji(a, s) {
    Ms[Pi++] = bu, Ms[Pi++] = gl, gl = a, bu = s;
  }
  function Dh(a, s, p) {
    Di[Wr++] = Pr, Di[Wr++] = Uo, Di[Wr++] = va, va = a;
    var v = Pr;
    a = Uo;
    var S = 32 - ri(v) - 1;
    v &= ~(1 << S), p += 1;
    var T = 32 - ri(s) + S;
    if (30 < T) {
      var D = S - S % 5;
      T = (v & (1 << D) - 1).toString(32), v >>= D, S -= D, Pr = 1 << 32 - ri(s) + S | p << S | v, Uo = T + a;
    } else
      Pr = 1 << T | p << S | v, Uo = a;
  }
  function rf(a) {
    a.return !== null && (Ji(a, 1), Dh(a, 1, 0));
  }
  function Oh(a) {
    for (; a === gl; )
      gl = Ms[--Pi], Ms[Pi] = null, bu = Ms[--Pi], Ms[Pi] = null;
    for (; a === va; )
      va = Di[--Wr], Di[Wr] = null, Uo = Di[--Wr], Di[Wr] = null, Pr = Di[--Wr], Di[Wr] = null;
  }
  var Xi = null, Oi = null, En = !1, ga = null;
  function Mh(a, s) {
    var p = wa(5, null, null, 0);
    p.elementType = "DELETED", p.stateNode = s, p.return = a, s = a.deletions, s === null ? (a.deletions = [p], a.flags |= 16) : s.push(p);
  }
  function fg(a, s) {
    switch (a.tag) {
      case 5:
        var p = a.type;
        return s = s.nodeType !== 1 || p.toLowerCase() !== s.nodeName.toLowerCase() ? null : s, s !== null ? (a.stateNode = s, Xi = a, Oi = Wa(s.firstChild), !0) : !1;
      case 6:
        return s = a.pendingProps === "" || s.nodeType !== 3 ? null : s, s !== null ? (a.stateNode = s, Xi = a, Oi = null, !0) : !1;
      case 13:
        return s = s.nodeType !== 8 ? null : s, s !== null ? (p = va !== null ? { id: Pr, overflow: Uo } : null, a.memoizedState = { dehydrated: s, treeContext: p, retryLane: 1073741824 }, p = wa(18, null, null, 0), p.stateNode = s, p.return = a, a.child = p, Xi = a, Oi = null, !0) : !1;
      default:
        return !1;
    }
  }
  function af(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function of(a) {
    if (En) {
      var s = Oi;
      if (s) {
        var p = s;
        if (!fg(a, s)) {
          if (af(a))
            throw Error(i(418));
          s = Wa(p.nextSibling);
          var v = Xi;
          s && fg(a, s) ? Mh(v, p) : (a.flags = a.flags & -4097 | 2, En = !1, Xi = a);
        }
      } else {
        if (af(a))
          throw Error(i(418));
        a.flags = a.flags & -4097 | 2, En = !1, Xi = a;
      }
    }
  }
  function pg(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
      a = a.return;
    Xi = a;
  }
  function sf(a) {
    if (a !== Xi)
      return !1;
    if (!En)
      return pg(a), En = !0, !1;
    var s;
    if ((s = a.tag !== 3) && !(s = a.tag !== 5) && (s = a.type, s = s !== "head" && s !== "body" && !zc(a.type, a.memoizedProps)), s && (s = Oi)) {
      if (af(a))
        throw hg(), Error(i(418));
      for (; s; )
        Mh(a, s), s = Wa(s.nextSibling);
    }
    if (pg(a), a.tag === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
        throw Error(i(317));
      e: {
        for (a = a.nextSibling, s = 0; a; ) {
          if (a.nodeType === 8) {
            var p = a.data;
            if (p === "/$") {
              if (s === 0) {
                Oi = Wa(a.nextSibling);
                break e;
              }
              s--;
            } else
              p !== "$" && p !== "$!" && p !== "$?" || s++;
          }
          a = a.nextSibling;
        }
        Oi = null;
      }
    } else
      Oi = Xi ? Wa(a.stateNode.nextSibling) : null;
    return !0;
  }
  function hg() {
    for (var a = Oi; a; )
      a = Wa(a.nextSibling);
  }
  function Un() {
    Oi = Xi = null, En = !1;
  }
  function Nh(a) {
    ga === null ? ga = [a] : ga.push(a);
  }
  var lf = B.ReactCurrentBatchConfig;
  function yl(a, s, p) {
    if (a = p.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (p._owner) {
        if (p = p._owner, p) {
          if (p.tag !== 1)
            throw Error(i(309));
          var v = p.stateNode;
        }
        if (!v)
          throw Error(i(147, a));
        var S = v, T = "" + a;
        return s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === T ? s.ref : (s = function(D) {
          var j = S.refs;
          D === null ? delete j[T] : j[T] = D;
        }, s._stringRef = T, s);
      }
      if (typeof a != "string")
        throw Error(i(284));
      if (!p._owner)
        throw Error(i(290, a));
    }
    return a;
  }
  function uo(a, s) {
    throw a = Object.prototype.toString.call(s), Error(i(31, a === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : a));
  }
  function mg(a) {
    var s = a._init;
    return s(a._payload);
  }
  function uf(a) {
    function s(Q, q) {
      if (a) {
        var ee = Q.deletions;
        ee === null ? (Q.deletions = [q], Q.flags |= 16) : ee.push(q);
      }
    }
    function p(Q, q) {
      if (!a)
        return null;
      for (; q !== null; )
        s(Q, q), q = q.sibling;
      return null;
    }
    function v(Q, q) {
      for (Q = /* @__PURE__ */ new Map(); q !== null; )
        q.key !== null ? Q.set(q.key, q) : Q.set(q.index, q), q = q.sibling;
      return Q;
    }
    function S(Q, q) {
      return Q = zs(Q, q), Q.index = 0, Q.sibling = null, Q;
    }
    function T(Q, q, ee) {
      return Q.index = ee, a ? (ee = Q.alternate, ee !== null ? (ee = ee.index, ee < q ? (Q.flags |= 2, q) : ee) : (Q.flags |= 2, q)) : (Q.flags |= 1048576, q);
    }
    function D(Q) {
      return a && Q.alternate === null && (Q.flags |= 2), Q;
    }
    function j(Q, q, ee, Oe) {
      return q === null || q.tag !== 6 ? (q = Qf(ee, Q.mode, Oe), q.return = Q, q) : (q = S(q, ee), q.return = Q, q);
    }
    function H(Q, q, ee, Oe) {
      var tt = ee.type;
      return tt === te ? we(Q, q, ee.props.children, Oe, ee.key) : q !== null && (q.elementType === tt || typeof tt == "object" && tt !== null && tt.$$typeof === Ct && mg(tt) === q.type) ? (Oe = S(q, ee.props), Oe.ref = yl(Q, q, ee), Oe.return = Q, Oe) : (Oe = Yf(ee.type, ee.key, ee.props, null, Q.mode, Oe), Oe.ref = yl(Q, q, ee), Oe.return = Q, Oe);
    }
    function oe(Q, q, ee, Oe) {
      return q === null || q.tag !== 4 || q.stateNode.containerInfo !== ee.containerInfo || q.stateNode.implementation !== ee.implementation ? (q = ld(ee, Q.mode, Oe), q.return = Q, q) : (q = S(q, ee.children || []), q.return = Q, q);
    }
    function we(Q, q, ee, Oe, tt) {
      return q === null || q.tag !== 7 ? (q = Nl(ee, Q.mode, Oe, tt), q.return = Q, q) : (q = S(q, ee), q.return = Q, q);
    }
    function Re(Q, q, ee) {
      if (typeof q == "string" && q !== "" || typeof q == "number")
        return q = Qf("" + q, Q.mode, ee), q.return = Q, q;
      if (typeof q == "object" && q !== null) {
        switch (q.$$typeof) {
          case F:
            return ee = Yf(q.type, q.key, q.props, null, Q.mode, ee), ee.ref = yl(Q, null, q), ee.return = Q, ee;
          case K:
            return q = ld(q, Q.mode, ee), q.return = Q, q;
          case Ct:
            var Oe = q._init;
            return Re(Q, Oe(q._payload), ee);
        }
        if (br(q) || Ze(q))
          return q = Nl(q, Q.mode, ee, null), q.return = Q, q;
        uo(Q, q);
      }
      return null;
    }
    function Te(Q, q, ee, Oe) {
      var tt = q !== null ? q.key : null;
      if (typeof ee == "string" && ee !== "" || typeof ee == "number")
        return tt !== null ? null : j(Q, q, "" + ee, Oe);
      if (typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case F:
            return ee.key === tt ? H(Q, q, ee, Oe) : null;
          case K:
            return ee.key === tt ? oe(Q, q, ee, Oe) : null;
          case Ct:
            return tt = ee._init, Te(
              Q,
              q,
              tt(ee._payload),
              Oe
            );
        }
        if (br(ee) || Ze(ee))
          return tt !== null ? null : we(Q, q, ee, Oe, null);
        uo(Q, ee);
      }
      return null;
    }
    function He(Q, q, ee, Oe, tt) {
      if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number")
        return Q = Q.get(ee) || null, j(q, Q, "" + Oe, tt);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case F:
            return Q = Q.get(Oe.key === null ? ee : Oe.key) || null, H(q, Q, Oe, tt);
          case K:
            return Q = Q.get(Oe.key === null ? ee : Oe.key) || null, oe(q, Q, Oe, tt);
          case Ct:
            var pt = Oe._init;
            return He(Q, q, ee, pt(Oe._payload), tt);
        }
        if (br(Oe) || Ze(Oe))
          return Q = Q.get(ee) || null, we(q, Q, Oe, tt, null);
        uo(q, Oe);
      }
      return null;
    }
    function Ye(Q, q, ee, Oe) {
      for (var tt = null, pt = null, Ke = q, ht = q = 0, hr = null; Ke !== null && ht < ee.length; ht++) {
        Ke.index > ht ? (hr = Ke, Ke = null) : hr = Ke.sibling;
        var Jt = Te(Q, Ke, ee[ht], Oe);
        if (Jt === null) {
          Ke === null && (Ke = hr);
          break;
        }
        a && Ke && Jt.alternate === null && s(Q, Ke), q = T(Jt, q, ht), pt === null ? tt = Jt : pt.sibling = Jt, pt = Jt, Ke = hr;
      }
      if (ht === ee.length)
        return p(Q, Ke), En && Ji(Q, ht), tt;
      if (Ke === null) {
        for (; ht < ee.length; ht++)
          Ke = Re(Q, ee[ht], Oe), Ke !== null && (q = T(Ke, q, ht), pt === null ? tt = Ke : pt.sibling = Ke, pt = Ke);
        return En && Ji(Q, ht), tt;
      }
      for (Ke = v(Q, Ke); ht < ee.length; ht++)
        hr = He(Ke, Q, ht, ee[ht], Oe), hr !== null && (a && hr.alternate !== null && Ke.delete(hr.key === null ? ht : hr.key), q = T(hr, q, ht), pt === null ? tt = hr : pt.sibling = hr, pt = hr);
      return a && Ke.forEach(function($o) {
        return s(Q, $o);
      }), En && Ji(Q, ht), tt;
    }
    function Xe(Q, q, ee, Oe) {
      var tt = Ze(ee);
      if (typeof tt != "function")
        throw Error(i(150));
      if (ee = tt.call(ee), ee == null)
        throw Error(i(151));
      for (var pt = tt = null, Ke = q, ht = q = 0, hr = null, Jt = ee.next(); Ke !== null && !Jt.done; ht++, Jt = ee.next()) {
        Ke.index > ht ? (hr = Ke, Ke = null) : hr = Ke.sibling;
        var $o = Te(Q, Ke, Jt.value, Oe);
        if ($o === null) {
          Ke === null && (Ke = hr);
          break;
        }
        a && Ke && $o.alternate === null && s(Q, Ke), q = T($o, q, ht), pt === null ? tt = $o : pt.sibling = $o, pt = $o, Ke = hr;
      }
      if (Jt.done)
        return p(
          Q,
          Ke
        ), En && Ji(Q, ht), tt;
      if (Ke === null) {
        for (; !Jt.done; ht++, Jt = ee.next())
          Jt = Re(Q, Jt.value, Oe), Jt !== null && (q = T(Jt, q, ht), pt === null ? tt = Jt : pt.sibling = Jt, pt = Jt);
        return En && Ji(Q, ht), tt;
      }
      for (Ke = v(Q, Ke); !Jt.done; ht++, Jt = ee.next())
        Jt = He(Ke, Q, ht, Jt.value, Oe), Jt !== null && (a && Jt.alternate !== null && Ke.delete(Jt.key === null ? ht : Jt.key), q = T(Jt, q, ht), pt === null ? tt = Jt : pt.sibling = Jt, pt = Jt);
      return a && Ke.forEach(function(sS) {
        return s(Q, sS);
      }), En && Ji(Q, ht), tt;
    }
    function Xn(Q, q, ee, Oe) {
      if (typeof ee == "object" && ee !== null && ee.type === te && ee.key === null && (ee = ee.props.children), typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case F:
            e: {
              for (var tt = ee.key, pt = q; pt !== null; ) {
                if (pt.key === tt) {
                  if (tt = ee.type, tt === te) {
                    if (pt.tag === 7) {
                      p(Q, pt.sibling), q = S(pt, ee.props.children), q.return = Q, Q = q;
                      break e;
                    }
                  } else if (pt.elementType === tt || typeof tt == "object" && tt !== null && tt.$$typeof === Ct && mg(tt) === pt.type) {
                    p(Q, pt.sibling), q = S(pt, ee.props), q.ref = yl(Q, pt, ee), q.return = Q, Q = q;
                    break e;
                  }
                  p(Q, pt);
                  break;
                } else
                  s(Q, pt);
                pt = pt.sibling;
              }
              ee.type === te ? (q = Nl(ee.props.children, Q.mode, Oe, ee.key), q.return = Q, Q = q) : (Oe = Yf(ee.type, ee.key, ee.props, null, Q.mode, Oe), Oe.ref = yl(Q, q, ee), Oe.return = Q, Q = Oe);
            }
            return D(Q);
          case K:
            e: {
              for (pt = ee.key; q !== null; ) {
                if (q.key === pt)
                  if (q.tag === 4 && q.stateNode.containerInfo === ee.containerInfo && q.stateNode.implementation === ee.implementation) {
                    p(Q, q.sibling), q = S(q, ee.children || []), q.return = Q, Q = q;
                    break e;
                  } else {
                    p(Q, q);
                    break;
                  }
                else
                  s(Q, q);
                q = q.sibling;
              }
              q = ld(ee, Q.mode, Oe), q.return = Q, Q = q;
            }
            return D(Q);
          case Ct:
            return pt = ee._init, Xn(Q, q, pt(ee._payload), Oe);
        }
        if (br(ee))
          return Ye(Q, q, ee, Oe);
        if (Ze(ee))
          return Xe(Q, q, ee, Oe);
        uo(Q, ee);
      }
      return typeof ee == "string" && ee !== "" || typeof ee == "number" ? (ee = "" + ee, q !== null && q.tag === 6 ? (p(Q, q.sibling), q = S(q, ee), q.return = Q, Q = q) : (p(Q, q), q = Qf(ee, Q.mode, Oe), q.return = Q, Q = q), D(Q)) : p(Q, q);
    }
    return Xn;
  }
  var Su = uf(!0), vg = uf(!1), Fo = wt(null), cr = null, Ue = null, ya = null;
  function Zi() {
    ya = Ue = cr = null;
  }
  function Lh(a) {
    var s = Fo.current;
    tn(Fo), a._currentValue = s;
  }
  function Ah(a, s, p) {
    for (; a !== null; ) {
      var v = a.alternate;
      if ((a.childLanes & s) !== s ? (a.childLanes |= s, v !== null && (v.childLanes |= s)) : v !== null && (v.childLanes & s) !== s && (v.childLanes |= s), a === p)
        break;
      a = a.return;
    }
  }
  function Cu(a, s) {
    cr = a, ya = Ue = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & s && (Li = !0), a.firstContext = null);
  }
  function ba(a) {
    var s = a._currentValue;
    if (ya !== a)
      if (a = { context: a, memoizedValue: s, next: null }, Ue === null) {
        if (cr === null)
          throw Error(i(308));
        Ue = a, cr.dependencies = { lanes: 0, firstContext: a };
      } else
        Ue = Ue.next = a;
    return s;
  }
  var bl = null;
  function rr(a) {
    bl === null ? bl = [a] : bl.push(a);
  }
  function gg(a, s, p, v) {
    var S = s.interleaved;
    return S === null ? (p.next = p, rr(s)) : (p.next = S.next, S.next = p), s.interleaved = p, jo(a, v);
  }
  function jo(a, s) {
    a.lanes |= s;
    var p = a.alternate;
    for (p !== null && (p.lanes |= s), p = a, a = a.return; a !== null; )
      a.childLanes |= s, p = a.alternate, p !== null && (p.childLanes |= s), p = a, a = a.return;
    return p.tag === 3 ? p.stateNode : null;
  }
  var Ns = !1;
  function cf(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function ku(a, s) {
    a = a.updateQueue, s.updateQueue === a && (s.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function Mi(a, s) {
    return { eventTime: a, lane: s, tag: 0, payload: null, callback: null, next: null };
  }
  function Ls(a, s, p) {
    var v = a.updateQueue;
    if (v === null)
      return null;
    if (v = v.shared, It & 2) {
      var S = v.pending;
      return S === null ? s.next = s : (s.next = S.next, S.next = s), v.pending = s, jo(a, p);
    }
    return S = v.interleaved, S === null ? (s.next = s, rr(v)) : (s.next = S.next, S.next = s), v.interleaved = s, jo(a, p);
  }
  function df(a, s, p) {
    if (s = s.updateQueue, s !== null && (s = s.shared, (p & 4194240) !== 0)) {
      var v = s.lanes;
      v &= a.pendingLanes, p |= v, s.lanes = p, ao(a, p);
    }
  }
  function yg(a, s) {
    var p = a.updateQueue, v = a.alternate;
    if (v !== null && (v = v.updateQueue, p === v)) {
      var S = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var D = { eventTime: p.eventTime, lane: p.lane, tag: p.tag, payload: p.payload, callback: p.callback, next: null };
          T === null ? S = T = D : T = T.next = D, p = p.next;
        } while (p !== null);
        T === null ? S = T = s : T = T.next = s;
      } else
        S = T = s;
      p = { baseState: v.baseState, firstBaseUpdate: S, lastBaseUpdate: T, shared: v.shared, effects: v.effects }, a.updateQueue = p;
      return;
    }
    a = p.lastBaseUpdate, a === null ? p.firstBaseUpdate = s : a.next = s, p.lastBaseUpdate = s;
  }
  function ff(a, s, p, v) {
    var S = a.updateQueue;
    Ns = !1;
    var T = S.firstBaseUpdate, D = S.lastBaseUpdate, j = S.shared.pending;
    if (j !== null) {
      S.shared.pending = null;
      var H = j, oe = H.next;
      H.next = null, D === null ? T = oe : D.next = oe, D = H;
      var we = a.alternate;
      we !== null && (we = we.updateQueue, j = we.lastBaseUpdate, j !== D && (j === null ? we.firstBaseUpdate = oe : j.next = oe, we.lastBaseUpdate = H));
    }
    if (T !== null) {
      var Re = S.baseState;
      D = 0, we = oe = H = null, j = T;
      do {
        var Te = j.lane, He = j.eventTime;
        if ((v & Te) === Te) {
          we !== null && (we = we.next = {
            eventTime: He,
            lane: 0,
            tag: j.tag,
            payload: j.payload,
            callback: j.callback,
            next: null
          });
          e: {
            var Ye = a, Xe = j;
            switch (Te = s, He = p, Xe.tag) {
              case 1:
                if (Ye = Xe.payload, typeof Ye == "function") {
                  Re = Ye.call(He, Re, Te);
                  break e;
                }
                Re = Ye;
                break e;
              case 3:
                Ye.flags = Ye.flags & -65537 | 128;
              case 0:
                if (Ye = Xe.payload, Te = typeof Ye == "function" ? Ye.call(He, Re, Te) : Ye, Te == null)
                  break e;
                Re = Ie({}, Re, Te);
                break e;
              case 2:
                Ns = !0;
            }
          }
          j.callback !== null && j.lane !== 0 && (a.flags |= 64, Te = S.effects, Te === null ? S.effects = [j] : Te.push(j));
        } else
          He = { eventTime: He, lane: Te, tag: j.tag, payload: j.payload, callback: j.callback, next: null }, we === null ? (oe = we = He, H = Re) : we = we.next = He, D |= Te;
        if (j = j.next, j === null) {
          if (j = S.shared.pending, j === null)
            break;
          Te = j, j = Te.next, Te.next = null, S.lastBaseUpdate = Te, S.shared.pending = null;
        }
      } while (1);
      if (we === null && (H = Re), S.baseState = H, S.firstBaseUpdate = oe, S.lastBaseUpdate = we, s = S.shared.interleaved, s !== null) {
        S = s;
        do
          D |= S.lane, S = S.next;
        while (S !== s);
      } else
        T === null && (S.shared.lanes = 0);
      Pl |= D, a.lanes = D, a.memoizedState = Re;
    }
  }
  function bg(a, s, p) {
    if (a = s.effects, s.effects = null, a !== null)
      for (s = 0; s < a.length; s++) {
        var v = a[s], S = v.callback;
        if (S !== null) {
          if (v.callback = null, v = p, typeof S != "function")
            throw Error(i(191, S));
          S.call(v);
        }
      }
  }
  var qc = {}, Ga = wt(qc), Tu = wt(qc), Wc = wt(qc);
  function Sl(a) {
    if (a === qc)
      throw Error(i(174));
    return a;
  }
  function Ih(a, s) {
    switch (ln(Wc, s), ln(Tu, a), ln(Ga, qc), a = s.nodeType, a) {
      case 9:
      case 11:
        s = (s = s.documentElement) ? s.namespaceURI : Ln(null, "");
        break;
      default:
        a = a === 8 ? s.parentNode : s, s = a.namespaceURI || null, a = a.tagName, s = Ln(s, a);
    }
    tn(Ga), ln(Ga, s);
  }
  function Eu() {
    tn(Ga), tn(Tu), tn(Wc);
  }
  function Sg(a) {
    Sl(Wc.current);
    var s = Sl(Ga.current), p = Ln(s, a.type);
    s !== p && (ln(Tu, a), ln(Ga, p));
  }
  function Uh(a) {
    Tu.current === a && (tn(Ga), tn(Tu));
  }
  var Dn = wt(0);
  function pf(a) {
    for (var s = a; s !== null; ) {
      if (s.tag === 13) {
        var p = s.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || p.data === "$?" || p.data === "$!"))
          return s;
      } else if (s.tag === 19 && s.memoizedProps.revealOrder !== void 0) {
        if (s.flags & 128)
          return s;
      } else if (s.child !== null) {
        s.child.return = s, s = s.child;
        continue;
      }
      if (s === a)
        break;
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === a)
          return null;
        s = s.return;
      }
      s.sibling.return = s.return, s = s.sibling;
    }
    return null;
  }
  var hf = [];
  function Fh() {
    for (var a = 0; a < hf.length; a++)
      hf[a]._workInProgressVersionPrimary = null;
    hf.length = 0;
  }
  var mf = B.ReactCurrentDispatcher, Gc = B.ReactCurrentBatchConfig, et = 0, rt = null, yt = null, At = null, ea = !1, wu = !1, Yc = 0, $b = 0;
  function Gr() {
    throw Error(i(321));
  }
  function Kc(a, s) {
    if (s === null)
      return !1;
    for (var p = 0; p < s.length && p < a.length; p++)
      if (!fa(a[p], s[p]))
        return !1;
    return !0;
  }
  function Se(a, s, p, v, S, T) {
    if (et = T, rt = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, mf.current = a === null || a.memoizedState === null ? qb : Sn, a = p(v, S), wu) {
      T = 0;
      do {
        if (wu = !1, Yc = 0, 25 <= T)
          throw Error(i(301));
        T += 1, At = yt = null, s.updateQueue = null, mf.current = Df, a = p(v, S);
      } while (wu);
    }
    if (mf.current = Yr, s = yt !== null && yt.next !== null, et = 0, At = yt = rt = null, ea = !1, s)
      throw Error(i(300));
    return a;
  }
  function ir() {
    var a = Yc !== 0;
    return Yc = 0, a;
  }
  function ot() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return At === null ? rt.memoizedState = At = a : At = At.next = a, At;
  }
  function Dr() {
    if (yt === null) {
      var a = rt.alternate;
      a = a !== null ? a.memoizedState : null;
    } else
      a = yt.next;
    var s = At === null ? rt.memoizedState : At.next;
    if (s !== null)
      At = s, yt = a;
    else {
      if (a === null)
        throw Error(i(310));
      yt = a, a = { memoizedState: yt.memoizedState, baseState: yt.baseState, baseQueue: yt.baseQueue, queue: yt.queue, next: null }, At === null ? rt.memoizedState = At = a : At = At.next = a;
    }
    return At;
  }
  function ta(a, s) {
    return typeof s == "function" ? s(a) : s;
  }
  function zo(a) {
    var s = Dr(), p = s.queue;
    if (p === null)
      throw Error(i(311));
    p.lastRenderedReducer = a;
    var v = yt, S = v.baseQueue, T = p.pending;
    if (T !== null) {
      if (S !== null) {
        var D = S.next;
        S.next = T.next, T.next = D;
      }
      v.baseQueue = S = T, p.pending = null;
    }
    if (S !== null) {
      T = S.next, v = v.baseState;
      var j = D = null, H = null, oe = T;
      do {
        var we = oe.lane;
        if ((et & we) === we)
          H !== null && (H = H.next = { lane: 0, action: oe.action, hasEagerState: oe.hasEagerState, eagerState: oe.eagerState, next: null }), v = oe.hasEagerState ? oe.eagerState : a(v, oe.action);
        else {
          var Re = {
            lane: we,
            action: oe.action,
            hasEagerState: oe.hasEagerState,
            eagerState: oe.eagerState,
            next: null
          };
          H === null ? (j = H = Re, D = v) : H = H.next = Re, rt.lanes |= we, Pl |= we;
        }
        oe = oe.next;
      } while (oe !== null && oe !== T);
      H === null ? D = v : H.next = j, fa(v, s.memoizedState) || (Li = !0), s.memoizedState = v, s.baseState = D, s.baseQueue = H, p.lastRenderedState = v;
    }
    if (a = p.interleaved, a !== null) {
      S = a;
      do
        T = S.lane, rt.lanes |= T, Pl |= T, S = S.next;
      while (S !== a);
    } else
      S === null && (p.lanes = 0);
    return [s.memoizedState, p.dispatch];
  }
  function Sa(a) {
    var s = Dr(), p = s.queue;
    if (p === null)
      throw Error(i(311));
    p.lastRenderedReducer = a;
    var v = p.dispatch, S = p.pending, T = s.memoizedState;
    if (S !== null) {
      p.pending = null;
      var D = S = S.next;
      do
        T = a(T, D.action), D = D.next;
      while (D !== S);
      fa(T, s.memoizedState) || (Li = !0), s.memoizedState = T, s.baseQueue === null && (s.baseState = T), p.lastRenderedState = T;
    }
    return [T, v];
  }
  function Ru() {
  }
  function Cl(a, s) {
    var p = rt, v = Dr(), S = s(), T = !fa(v.memoizedState, S);
    if (T && (v.memoizedState = S, Li = !0), v = v.queue, Qc(gf.bind(null, p, v, a), [a]), v.getSnapshot !== s || T || At !== null && At.memoizedState.tag & 1) {
      if (p.flags |= 2048, kl(9, vf.bind(null, p, v, S, s), void 0, null), $n === null)
        throw Error(i(349));
      et & 30 || _u(p, s, S);
    }
    return S;
  }
  function _u(a, s, p) {
    a.flags |= 16384, a = { getSnapshot: s, value: p }, s = rt.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, rt.updateQueue = s, s.stores = [a]) : (p = s.stores, p === null ? s.stores = [a] : p.push(a));
  }
  function vf(a, s, p, v) {
    s.value = p, s.getSnapshot = v, yf(s) && bf(a);
  }
  function gf(a, s, p) {
    return p(function() {
      yf(s) && bf(a);
    });
  }
  function yf(a) {
    var s = a.getSnapshot;
    a = a.value;
    try {
      var p = s();
      return !fa(a, p);
    } catch {
      return !0;
    }
  }
  function bf(a) {
    var s = jo(a, 1);
    s !== null && Fn(s, a, 1, -1);
  }
  function Sf(a) {
    var s = ot();
    return typeof a == "function" && (a = a()), s.memoizedState = s.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ta, lastRenderedState: a }, s.queue = a, a = a.dispatch = Jc.bind(null, rt, a), [s.memoizedState, a];
  }
  function kl(a, s, p, v) {
    return a = { tag: a, create: s, destroy: p, deps: v, next: null }, s = rt.updateQueue, s === null ? (s = { lastEffect: null, stores: null }, rt.updateQueue = s, s.lastEffect = a.next = a) : (p = s.lastEffect, p === null ? s.lastEffect = a.next = a : (v = p.next, p.next = a, a.next = v, s.lastEffect = a)), a;
  }
  function Cf() {
    return Dr().memoizedState;
  }
  function xu(a, s, p, v) {
    var S = ot();
    rt.flags |= a, S.memoizedState = kl(1 | s, p, void 0, v === void 0 ? null : v);
  }
  function Pu(a, s, p, v) {
    var S = Dr();
    v = v === void 0 ? null : v;
    var T = void 0;
    if (yt !== null) {
      var D = yt.memoizedState;
      if (T = D.destroy, v !== null && Kc(v, D.deps)) {
        S.memoizedState = kl(s, p, T, v);
        return;
      }
    }
    rt.flags |= a, S.memoizedState = kl(1 | s, p, T, v);
  }
  function kf(a, s) {
    return xu(8390656, 8, a, s);
  }
  function Qc(a, s) {
    return Pu(2048, 8, a, s);
  }
  function Tf(a, s) {
    return Pu(4, 2, a, s);
  }
  function Ef(a, s) {
    return Pu(4, 4, a, s);
  }
  function wf(a, s) {
    if (typeof s == "function")
      return a = a(), s(a), function() {
        s(null);
      };
    if (s != null)
      return a = a(), s.current = a, function() {
        s.current = null;
      };
  }
  function Rf(a, s, p) {
    return p = p != null ? p.concat([a]) : null, Pu(4, 4, wf.bind(null, s, a), p);
  }
  function Du() {
  }
  function Tl(a, s) {
    var p = Dr();
    s = s === void 0 ? null : s;
    var v = p.memoizedState;
    return v !== null && s !== null && Kc(s, v[1]) ? v[0] : (p.memoizedState = [a, s], a);
  }
  function _f(a, s) {
    var p = Dr();
    s = s === void 0 ? null : s;
    var v = p.memoizedState;
    return v !== null && s !== null && Kc(s, v[1]) ? v[0] : (a = a(), p.memoizedState = [a, s], a);
  }
  function xf(a, s, p) {
    return et & 21 ? (fa(p, s) || (p = ru(), rt.lanes |= p, Pl |= p, a.baseState = !0), s) : (a.baseState && (a.baseState = !1, Li = !0), a.memoizedState = p);
  }
  function jh(a, s) {
    var p = Qt;
    Qt = p !== 0 && 4 > p ? p : 4, a(!0);
    var v = Gc.transition;
    Gc.transition = {};
    try {
      a(!1), s();
    } finally {
      Qt = p, Gc.transition = v;
    }
  }
  function Pf() {
    return Dr().memoizedState;
  }
  function Cg(a, s, p) {
    var v = Ho(a);
    if (p = { lane: v, action: p, hasEagerState: !1, eagerState: null, next: null }, zh(a))
      Ou(s, p);
    else if (p = gg(a, s, p, v), p !== null) {
      var S = Rr();
      Fn(p, a, v, S), As(p, s, v);
    }
  }
  function Jc(a, s, p) {
    var v = Ho(a), S = { lane: v, action: p, hasEagerState: !1, eagerState: null, next: null };
    if (zh(a))
      Ou(s, S);
    else {
      var T = a.alternate;
      if (a.lanes === 0 && (T === null || T.lanes === 0) && (T = s.lastRenderedReducer, T !== null))
        try {
          var D = s.lastRenderedState, j = T(D, p);
          if (S.hasEagerState = !0, S.eagerState = j, fa(j, D)) {
            var H = s.interleaved;
            H === null ? (S.next = S, rr(s)) : (S.next = H.next, H.next = S), s.interleaved = S;
            return;
          }
        } catch {
        } finally {
        }
      p = gg(a, s, S, v), p !== null && (S = Rr(), Fn(p, a, v, S), As(p, s, v));
    }
  }
  function zh(a) {
    var s = a.alternate;
    return a === rt || s !== null && s === rt;
  }
  function Ou(a, s) {
    wu = ea = !0;
    var p = a.pending;
    p === null ? s.next = s : (s.next = p.next, p.next = s), a.pending = s;
  }
  function As(a, s, p) {
    if (p & 4194240) {
      var v = s.lanes;
      v &= a.pendingLanes, p |= v, s.lanes = p, ao(a, p);
    }
  }
  var Yr = { readContext: ba, useCallback: Gr, useContext: Gr, useEffect: Gr, useImperativeHandle: Gr, useInsertionEffect: Gr, useLayoutEffect: Gr, useMemo: Gr, useReducer: Gr, useRef: Gr, useState: Gr, useDebugValue: Gr, useDeferredValue: Gr, useTransition: Gr, useMutableSource: Gr, useSyncExternalStore: Gr, useId: Gr, unstable_isNewReconciler: !1 }, qb = { readContext: ba, useCallback: function(a, s) {
    return ot().memoizedState = [a, s === void 0 ? null : s], a;
  }, useContext: ba, useEffect: kf, useImperativeHandle: function(a, s, p) {
    return p = p != null ? p.concat([a]) : null, xu(
      4194308,
      4,
      wf.bind(null, s, a),
      p
    );
  }, useLayoutEffect: function(a, s) {
    return xu(4194308, 4, a, s);
  }, useInsertionEffect: function(a, s) {
    return xu(4, 2, a, s);
  }, useMemo: function(a, s) {
    var p = ot();
    return s = s === void 0 ? null : s, a = a(), p.memoizedState = [a, s], a;
  }, useReducer: function(a, s, p) {
    var v = ot();
    return s = p !== void 0 ? p(s) : s, v.memoizedState = v.baseState = s, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: s }, v.queue = a, a = a.dispatch = Cg.bind(null, rt, a), [v.memoizedState, a];
  }, useRef: function(a) {
    var s = ot();
    return a = { current: a }, s.memoizedState = a;
  }, useState: Sf, useDebugValue: Du, useDeferredValue: function(a) {
    return ot().memoizedState = a;
  }, useTransition: function() {
    var a = Sf(!1), s = a[0];
    return a = jh.bind(null, a[1]), ot().memoizedState = a, [s, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, s, p) {
    var v = rt, S = ot();
    if (En) {
      if (p === void 0)
        throw Error(i(407));
      p = p();
    } else {
      if (p = s(), $n === null)
        throw Error(i(349));
      et & 30 || _u(v, s, p);
    }
    S.memoizedState = p;
    var T = { value: p, getSnapshot: s };
    return S.queue = T, kf(gf.bind(
      null,
      v,
      T,
      a
    ), [a]), v.flags |= 2048, kl(9, vf.bind(null, v, T, p, s), void 0, null), p;
  }, useId: function() {
    var a = ot(), s = $n.identifierPrefix;
    if (En) {
      var p = Uo, v = Pr;
      p = (v & ~(1 << 32 - ri(v) - 1)).toString(32) + p, s = ":" + s + "R" + p, p = Yc++, 0 < p && (s += "H" + p.toString(32)), s += ":";
    } else
      p = $b++, s = ":" + s + "r" + p.toString(32) + ":";
    return a.memoizedState = s;
  }, unstable_isNewReconciler: !1 }, Sn = {
    readContext: ba,
    useCallback: Tl,
    useContext: ba,
    useEffect: Qc,
    useImperativeHandle: Rf,
    useInsertionEffect: Tf,
    useLayoutEffect: Ef,
    useMemo: _f,
    useReducer: zo,
    useRef: Cf,
    useState: function() {
      return zo(ta);
    },
    useDebugValue: Du,
    useDeferredValue: function(a) {
      var s = Dr();
      return xf(s, yt.memoizedState, a);
    },
    useTransition: function() {
      var a = zo(ta)[0], s = Dr().memoizedState;
      return [a, s];
    },
    useMutableSource: Ru,
    useSyncExternalStore: Cl,
    useId: Pf,
    unstable_isNewReconciler: !1
  }, Df = { readContext: ba, useCallback: Tl, useContext: ba, useEffect: Qc, useImperativeHandle: Rf, useInsertionEffect: Tf, useLayoutEffect: Ef, useMemo: _f, useReducer: Sa, useRef: Cf, useState: function() {
    return Sa(ta);
  }, useDebugValue: Du, useDeferredValue: function(a) {
    var s = Dr();
    return yt === null ? s.memoizedState = a : xf(s, yt.memoizedState, a);
  }, useTransition: function() {
    var a = Sa(ta)[0], s = Dr().memoizedState;
    return [a, s];
  }, useMutableSource: Ru, useSyncExternalStore: Cl, useId: Pf, unstable_isNewReconciler: !1 };
  function Ni(a, s) {
    if (a && a.defaultProps) {
      s = Ie({}, s), a = a.defaultProps;
      for (var p in a)
        s[p] === void 0 && (s[p] = a[p]);
      return s;
    }
    return s;
  }
  function El(a, s, p, v) {
    s = a.memoizedState, p = p(v, s), p = p == null ? s : Ie({}, s, p), a.memoizedState = p, a.lanes === 0 && (a.updateQueue.baseState = p);
  }
  var wl = { isMounted: function(a) {
    return (a = a._reactInternals) ? nt(a) === a : !1;
  }, enqueueSetState: function(a, s, p) {
    a = a._reactInternals;
    var v = Rr(), S = Ho(a), T = Mi(v, S);
    T.payload = s, p != null && (T.callback = p), s = Ls(a, T, S), s !== null && (Fn(s, a, S, v), df(s, a, S));
  }, enqueueReplaceState: function(a, s, p) {
    a = a._reactInternals;
    var v = Rr(), S = Ho(a), T = Mi(v, S);
    T.tag = 1, T.payload = s, p != null && (T.callback = p), s = Ls(a, T, S), s !== null && (Fn(s, a, S, v), df(s, a, S));
  }, enqueueForceUpdate: function(a, s) {
    a = a._reactInternals;
    var p = Rr(), v = Ho(a), S = Mi(p, v);
    S.tag = 2, s != null && (S.callback = s), s = Ls(a, S, v), s !== null && (Fn(s, a, v, p), df(s, a, v));
  } };
  function kg(a, s, p, v, S, T, D) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(v, T, D) : s.prototype && s.prototype.isPureReactComponent ? !Nc(p, v) || !Nc(S, T) : !0;
  }
  function Tg(a, s, p) {
    var v = !1, S = lo, T = s.contextType;
    return typeof T == "object" && T !== null ? T = ba(T) : (S = Pn(s) ? _i : gt.current, v = s.contextTypes, T = (v = v != null) ? ha(a, S) : lo), s = new s(p, T), a.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, s.updater = wl, a.stateNode = s, s._reactInternals = a, v && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = S, a.__reactInternalMemoizedMaskedChildContext = T), s;
  }
  function Eg(a, s, p, v) {
    a = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(p, v), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(p, v), s.state !== a && wl.enqueueReplaceState(s, s.state, null);
  }
  function Vh(a, s, p, v) {
    var S = a.stateNode;
    S.props = p, S.state = a.memoizedState, S.refs = {}, cf(a);
    var T = s.contextType;
    typeof T == "object" && T !== null ? S.context = ba(T) : (T = Pn(s) ? _i : gt.current, S.context = ha(a, T)), S.state = a.memoizedState, T = s.getDerivedStateFromProps, typeof T == "function" && (El(a, s, T, p), S.state = a.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (s = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), s !== S.state && wl.enqueueReplaceState(S, S.state, null), ff(a, p, S, v), S.state = a.memoizedState), typeof S.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function Is(a, s) {
    try {
      var p = "", v = s;
      do
        p += kt(v), v = v.return;
      while (v);
      var S = p;
    } catch (T) {
      S = `
Error generating stack: ` + T.message + `
` + T.stack;
    }
    return { value: a, source: s, stack: S, digest: null };
  }
  function Bh(a, s, p) {
    return { value: a, source: null, stack: p ?? null, digest: s ?? null };
  }
  function Xc(a, s) {
    try {
      console.error(s.value);
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  var wg = typeof WeakMap == "function" ? WeakMap : Map;
  function Rg(a, s, p) {
    p = Mi(-1, p), p.tag = 3, p.payload = { element: null };
    var v = s.value;
    return p.callback = function() {
      Bf || (Bf = !0, Jh = v), Xc(a, s);
    }, p;
  }
  function _g(a, s, p) {
    p = Mi(-1, p), p.tag = 3;
    var v = a.type.getDerivedStateFromError;
    if (typeof v == "function") {
      var S = s.value;
      p.payload = function() {
        return v(S);
      }, p.callback = function() {
        Xc(a, s);
      };
    }
    var T = a.stateNode;
    return T !== null && typeof T.componentDidCatch == "function" && (p.callback = function() {
      Xc(a, s), typeof v != "function" && (Ta === null ? Ta = /* @__PURE__ */ new Set([this]) : Ta.add(this));
      var D = s.stack;
      this.componentDidCatch(s.value, { componentStack: D !== null ? D : "" });
    }), p;
  }
  function Zc(a, s, p) {
    var v = a.pingCache;
    if (v === null) {
      v = a.pingCache = new wg();
      var S = /* @__PURE__ */ new Set();
      v.set(s, S);
    } else
      S = v.get(s), S === void 0 && (S = /* @__PURE__ */ new Set(), v.set(s, S));
    S.has(p) || (S.add(p), a = tS.bind(null, a, s, p), s.then(a, a));
  }
  function xg(a) {
    do {
      var s;
      if ((s = a.tag === 13) && (s = a.memoizedState, s = s !== null ? s.dehydrated !== null : !0), s)
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Hh(a, s, p, v, S) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = S, a) : (a === s ? a.flags |= 65536 : (a.flags |= 128, p.flags |= 131072, p.flags &= -52805, p.tag === 1 && (p.alternate === null ? p.tag = 17 : (s = Mi(-1, 1), s.tag = 2, Ls(p, s, 1))), p.lanes |= 1), a);
  }
  var Pg = B.ReactCurrentOwner, Li = !1;
  function Qn(a, s, p, v) {
    s.child = a === null ? vg(s, null, p, v) : Su(s, a.child, p, v);
  }
  function Mu(a, s, p, v, S) {
    p = p.render;
    var T = s.ref;
    return Cu(s, S), v = Se(a, s, p, v, T, S), p = ir(), a !== null && !Li ? (s.updateQueue = a.updateQueue, s.flags &= -2053, a.lanes &= ~S, Jn(a, s, S)) : (En && p && rf(s), s.flags |= 1, Qn(a, s, v, S), s.child);
  }
  function Us(a, s, p, v, S) {
    if (a === null) {
      var T = p.type;
      return typeof T == "function" && !nm(T) && T.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (s.tag = 15, s.type = T, Of(a, s, T, v, S)) : (a = Yf(p.type, null, v, s, s.mode, S), a.ref = s.ref, a.return = s, s.child = a);
    }
    if (T = a.child, !(a.lanes & S)) {
      var D = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : Nc, p(D, v) && a.ref === s.ref)
        return Jn(a, s, S);
    }
    return s.flags |= 1, a = zs(T, v), a.ref = s.ref, a.return = s, s.child = a;
  }
  function Of(a, s, p, v, S) {
    if (a !== null) {
      var T = a.memoizedProps;
      if (Nc(T, v) && a.ref === s.ref)
        if (Li = !1, s.pendingProps = v = T, (a.lanes & S) !== 0)
          a.flags & 131072 && (Li = !0);
        else
          return s.lanes = a.lanes, Jn(a, s, S);
    }
    return Et(a, s, p, v, S);
  }
  function Ai(a, s, p) {
    var v = s.pendingProps, S = v.children, T = a !== null ? a.memoizedState : null;
    if (v.mode === "hidden")
      if (!(s.mode & 1))
        s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ln(Bu, Ii), Ii |= p;
      else {
        if (!(p & 1073741824))
          return a = T !== null ? T.baseLanes | p : p, s.lanes = s.childLanes = 1073741824, s.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, s.updateQueue = null, ln(Bu, Ii), Ii |= a, null;
        s.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, v = T !== null ? T.baseLanes : p, ln(Bu, Ii), Ii |= v;
      }
    else
      T !== null ? (v = T.baseLanes | p, s.memoizedState = null) : v = p, ln(Bu, Ii), Ii |= v;
    return Qn(a, s, S, p), s.child;
  }
  function Rl(a, s) {
    var p = s.ref;
    (a === null && p !== null || a !== null && a.ref !== p) && (s.flags |= 512, s.flags |= 2097152);
  }
  function Et(a, s, p, v, S) {
    var T = Pn(p) ? _i : gt.current;
    return T = ha(s, T), Cu(s, S), p = Se(a, s, p, v, T, S), v = ir(), a !== null && !Li ? (s.updateQueue = a.updateQueue, s.flags &= -2053, a.lanes &= ~S, Jn(a, s, S)) : (En && v && rf(s), s.flags |= 1, Qn(a, s, p, S), s.child);
  }
  function ed(a, s, p, v, S) {
    if (Pn(p)) {
      var T = !0;
      nf(s);
    } else
      T = !1;
    if (Cu(s, S), s.stateNode === null)
      nd(a, s), Tg(s, p, v), Vh(s, p, v, S), v = !0;
    else if (a === null) {
      var D = s.stateNode, j = s.memoizedProps;
      D.props = j;
      var H = D.context, oe = p.contextType;
      typeof oe == "object" && oe !== null ? oe = ba(oe) : (oe = Pn(p) ? _i : gt.current, oe = ha(s, oe));
      var we = p.getDerivedStateFromProps, Re = typeof we == "function" || typeof D.getSnapshotBeforeUpdate == "function";
      Re || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (j !== v || H !== oe) && Eg(s, D, v, oe), Ns = !1;
      var Te = s.memoizedState;
      D.state = Te, ff(s, v, D, S), H = s.memoizedState, j !== v || Te !== H || Bn.current || Ns ? (typeof we == "function" && (El(s, p, we, v), H = s.memoizedState), (j = Ns || kg(s, p, j, v, Te, H, oe)) ? (Re || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount()), typeof D.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof D.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = v, s.memoizedState = H), D.props = v, D.state = H, D.context = oe, v = j) : (typeof D.componentDidMount == "function" && (s.flags |= 4194308), v = !1);
    } else {
      D = s.stateNode, ku(a, s), j = s.memoizedProps, oe = s.type === s.elementType ? j : Ni(s.type, j), D.props = oe, Re = s.pendingProps, Te = D.context, H = p.contextType, typeof H == "object" && H !== null ? H = ba(H) : (H = Pn(p) ? _i : gt.current, H = ha(s, H));
      var He = p.getDerivedStateFromProps;
      (we = typeof He == "function" || typeof D.getSnapshotBeforeUpdate == "function") || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (j !== Re || Te !== H) && Eg(s, D, v, H), Ns = !1, Te = s.memoizedState, D.state = Te, ff(s, v, D, S);
      var Ye = s.memoizedState;
      j !== Re || Te !== Ye || Bn.current || Ns ? (typeof He == "function" && (El(s, p, He, v), Ye = s.memoizedState), (oe = Ns || kg(s, p, oe, v, Te, Ye, H) || !1) ? (we || typeof D.UNSAFE_componentWillUpdate != "function" && typeof D.componentWillUpdate != "function" || (typeof D.componentWillUpdate == "function" && D.componentWillUpdate(v, Ye, H), typeof D.UNSAFE_componentWillUpdate == "function" && D.UNSAFE_componentWillUpdate(v, Ye, H)), typeof D.componentDidUpdate == "function" && (s.flags |= 4), typeof D.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof D.componentDidUpdate != "function" || j === a.memoizedProps && Te === a.memoizedState || (s.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || j === a.memoizedProps && Te === a.memoizedState || (s.flags |= 1024), s.memoizedProps = v, s.memoizedState = Ye), D.props = v, D.state = Ye, D.context = H, v = oe) : (typeof D.componentDidUpdate != "function" || j === a.memoizedProps && Te === a.memoizedState || (s.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || j === a.memoizedProps && Te === a.memoizedState || (s.flags |= 1024), v = !1);
    }
    return Mf(a, s, p, v, T, S);
  }
  function Mf(a, s, p, v, S, T) {
    Rl(a, s);
    var D = (s.flags & 128) !== 0;
    if (!v && !D)
      return S && dg(s, p, !1), Jn(a, s, T);
    v = s.stateNode, Pg.current = s;
    var j = D && typeof p.getDerivedStateFromError != "function" ? null : v.render();
    return s.flags |= 1, a !== null && D ? (s.child = Su(s, a.child, null, T), s.child = Su(s, null, j, T)) : Qn(a, s, j, T), s.memoizedState = v.state, S && dg(s, p, !0), s.child;
  }
  function Wb(a) {
    var s = a.stateNode;
    s.pendingContext ? Os(a, s.pendingContext, s.pendingContext !== s.context) : s.context && Os(a, s.context, !1), Ih(a, s.containerInfo);
  }
  function Dg(a, s, p, v, S) {
    return Un(), Nh(S), s.flags |= 256, Qn(a, s, p, v), s.child;
  }
  var td = { dehydrated: null, treeContext: null, retryLane: 0 };
  function _l(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function Og(a, s, p) {
    var v = s.pendingProps, S = Dn.current, T = !1, D = (s.flags & 128) !== 0, j;
    if ((j = D) || (j = a !== null && a.memoizedState === null ? !1 : (S & 2) !== 0), j ? (T = !0, s.flags &= -129) : (a === null || a.memoizedState !== null) && (S |= 1), ln(Dn, S & 1), a === null)
      return of(s), a = s.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (s.mode & 1 ? a.data === "$!" ? s.lanes = 8 : s.lanes = 1073741824 : s.lanes = 1, null) : (D = v.children, a = v.fallback, T ? (v = s.mode, T = s.child, D = { mode: "hidden", children: D }, !(v & 1) && T !== null ? (T.childLanes = 0, T.pendingProps = D) : T = Kf(D, v, 0, null), a = Nl(a, v, p, null), T.return = s, a.return = s, T.sibling = a, s.child = T, s.child.memoizedState = _l(p), s.memoizedState = td, a) : Nf(s, D));
    if (S = a.memoizedState, S !== null && (j = S.dehydrated, j !== null))
      return $h(a, s, D, v, j, S, p);
    if (T) {
      T = v.fallback, D = s.mode, S = a.child, j = S.sibling;
      var H = { mode: "hidden", children: v.children };
      return !(D & 1) && s.child !== S ? (v = s.child, v.childLanes = 0, v.pendingProps = H, s.deletions = null) : (v = zs(S, H), v.subtreeFlags = S.subtreeFlags & 14680064), j !== null ? T = zs(j, T) : (T = Nl(T, D, p, null), T.flags |= 2), T.return = s, v.return = s, v.sibling = T, s.child = v, v = T, T = s.child, D = a.child.memoizedState, D = D === null ? _l(p) : { baseLanes: D.baseLanes | p, cachePool: null, transitions: D.transitions }, T.memoizedState = D, T.childLanes = a.childLanes & ~p, s.memoizedState = td, v;
    }
    return T = a.child, a = T.sibling, v = zs(T, { mode: "visible", children: v.children }), !(s.mode & 1) && (v.lanes = p), v.return = s, v.sibling = null, a !== null && (p = s.deletions, p === null ? (s.deletions = [a], s.flags |= 16) : p.push(a)), s.child = v, s.memoizedState = null, v;
  }
  function Nf(a, s) {
    return s = Kf({ mode: "visible", children: s }, a.mode, 0, null), s.return = a, a.child = s;
  }
  function Lf(a, s, p, v) {
    return v !== null && Nh(v), Su(s, a.child, null, p), a = Nf(s, s.pendingProps.children), a.flags |= 2, s.memoizedState = null, a;
  }
  function $h(a, s, p, v, S, T, D) {
    if (p)
      return s.flags & 256 ? (s.flags &= -257, v = Bh(Error(i(422))), Lf(a, s, D, v)) : s.memoizedState !== null ? (s.child = a.child, s.flags |= 128, null) : (T = v.fallback, S = s.mode, v = Kf({ mode: "visible", children: v.children }, S, 0, null), T = Nl(T, S, D, null), T.flags |= 2, v.return = s, T.return = s, v.sibling = T, s.child = v, s.mode & 1 && Su(s, a.child, null, D), s.child.memoizedState = _l(D), s.memoizedState = td, T);
    if (!(s.mode & 1))
      return Lf(a, s, D, null);
    if (S.data === "$!") {
      if (v = S.nextSibling && S.nextSibling.dataset, v)
        var j = v.dgst;
      return v = j, T = Error(i(419)), v = Bh(T, v, void 0), Lf(a, s, D, v);
    }
    if (j = (D & a.childLanes) !== 0, Li || j) {
      if (v = $n, v !== null) {
        switch (D & -D) {
          case 4:
            S = 2;
            break;
          case 16:
            S = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            S = 32;
            break;
          case 536870912:
            S = 268435456;
            break;
          default:
            S = 0;
        }
        S = S & (v.suspendedLanes | D) ? 0 : S, S !== 0 && S !== T.retryLane && (T.retryLane = S, jo(a, S), Fn(v, a, S, -1));
      }
      return sd(), v = Bh(Error(i(421))), Lf(a, s, D, v);
    }
    return S.data === "$?" ? (s.flags |= 128, s.child = a.child, s = tm.bind(null, a), S._reactRetry = s, null) : (a = T.treeContext, Oi = Wa(S.nextSibling), Xi = s, En = !0, ga = null, a !== null && (Di[Wr++] = Pr, Di[Wr++] = Uo, Di[Wr++] = va, Pr = a.id, Uo = a.overflow, va = s), s = Nf(s, v.children), s.flags |= 4096, s);
  }
  function Mg(a, s, p) {
    a.lanes |= s;
    var v = a.alternate;
    v !== null && (v.lanes |= s), Ah(a.return, s, p);
  }
  function Af(a, s, p, v, S) {
    var T = a.memoizedState;
    T === null ? a.memoizedState = { isBackwards: s, rendering: null, renderingStartTime: 0, last: v, tail: p, tailMode: S } : (T.isBackwards = s, T.rendering = null, T.renderingStartTime = 0, T.last = v, T.tail = p, T.tailMode = S);
  }
  function qh(a, s, p) {
    var v = s.pendingProps, S = v.revealOrder, T = v.tail;
    if (Qn(a, s, v.children, p), v = Dn.current, v & 2)
      v = v & 1 | 2, s.flags |= 128;
    else {
      if (a !== null && a.flags & 128)
        e:
          for (a = s.child; a !== null; ) {
            if (a.tag === 13)
              a.memoizedState !== null && Mg(a, p, s);
            else if (a.tag === 19)
              Mg(a, p, s);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === s)
              break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === s)
                break e;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
      v &= 1;
    }
    if (ln(Dn, v), !(s.mode & 1))
      s.memoizedState = null;
    else
      switch (S) {
        case "forwards":
          for (p = s.child, S = null; p !== null; )
            a = p.alternate, a !== null && pf(a) === null && (S = p), p = p.sibling;
          p = S, p === null ? (S = s.child, s.child = null) : (S = p.sibling, p.sibling = null), Af(s, !1, S, p, T);
          break;
        case "backwards":
          for (p = null, S = s.child, s.child = null; S !== null; ) {
            if (a = S.alternate, a !== null && pf(a) === null) {
              s.child = S;
              break;
            }
            a = S.sibling, S.sibling = p, p = S, S = a;
          }
          Af(s, !0, p, null, T);
          break;
        case "together":
          Af(s, !1, null, null, void 0);
          break;
        default:
          s.memoizedState = null;
      }
    return s.child;
  }
  function nd(a, s) {
    !(s.mode & 1) && a !== null && (a.alternate = null, s.alternate = null, s.flags |= 2);
  }
  function Jn(a, s, p) {
    if (a !== null && (s.dependencies = a.dependencies), Pl |= s.lanes, !(p & s.childLanes))
      return null;
    if (a !== null && s.child !== a.child)
      throw Error(i(153));
    if (s.child !== null) {
      for (a = s.child, p = zs(a, a.pendingProps), s.child = p, p.return = s; a.sibling !== null; )
        a = a.sibling, p = p.sibling = zs(a, a.pendingProps), p.return = s;
      p.sibling = null;
    }
    return s.child;
  }
  function Vo(a, s, p) {
    switch (s.tag) {
      case 3:
        Wb(s), Un();
        break;
      case 5:
        Sg(s);
        break;
      case 1:
        Pn(s.type) && nf(s);
        break;
      case 4:
        Ih(s, s.stateNode.containerInfo);
        break;
      case 10:
        var v = s.type._context, S = s.memoizedProps.value;
        ln(Fo, v._currentValue), v._currentValue = S;
        break;
      case 13:
        if (v = s.memoizedState, v !== null)
          return v.dehydrated !== null ? (ln(Dn, Dn.current & 1), s.flags |= 128, null) : p & s.child.childLanes ? Og(a, s, p) : (ln(Dn, Dn.current & 1), a = Jn(a, s, p), a !== null ? a.sibling : null);
        ln(Dn, Dn.current & 1);
        break;
      case 19:
        if (v = (p & s.childLanes) !== 0, a.flags & 128) {
          if (v)
            return qh(a, s, p);
          s.flags |= 128;
        }
        if (S = s.memoizedState, S !== null && (S.rendering = null, S.tail = null, S.lastEffect = null), ln(Dn, Dn.current), v)
          break;
        return null;
      case 22:
      case 23:
        return s.lanes = 0, Ai(a, s, p);
    }
    return Jn(a, s, p);
  }
  var co, Nu, Lu, Ca;
  co = function(a, s) {
    for (var p = s.child; p !== null; ) {
      if (p.tag === 5 || p.tag === 6)
        a.appendChild(p.stateNode);
      else if (p.tag !== 4 && p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === s)
        break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === s)
          return;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
  }, Nu = function() {
  }, Lu = function(a, s, p, v) {
    var S = a.memoizedProps;
    if (S !== v) {
      a = s.stateNode, Sl(Ga.current);
      var T = null;
      switch (p) {
        case "input":
          S = yr(a, S), v = yr(a, v), T = [];
          break;
        case "select":
          S = Ie({}, S, { value: void 0 }), v = Ie({}, v, { value: void 0 }), T = [];
          break;
        case "textarea":
          S = Ci(a, S), v = Ci(a, v), T = [];
          break;
        default:
          typeof S.onClick != "function" && typeof v.onClick == "function" && (a.onclick = tf);
      }
      Kn(p, v);
      var D;
      p = null;
      for (oe in S)
        if (!v.hasOwnProperty(oe) && S.hasOwnProperty(oe) && S[oe] != null)
          if (oe === "style") {
            var j = S[oe];
            for (D in j)
              j.hasOwnProperty(D) && (p || (p = {}), p[D] = "");
          } else
            oe !== "dangerouslySetInnerHTML" && oe !== "children" && oe !== "suppressContentEditableWarning" && oe !== "suppressHydrationWarning" && oe !== "autoFocus" && (u.hasOwnProperty(oe) ? T || (T = []) : (T = T || []).push(oe, null));
      for (oe in v) {
        var H = v[oe];
        if (j = S != null ? S[oe] : void 0, v.hasOwnProperty(oe) && H !== j && (H != null || j != null))
          if (oe === "style")
            if (j) {
              for (D in j)
                !j.hasOwnProperty(D) || H && H.hasOwnProperty(D) || (p || (p = {}), p[D] = "");
              for (D in H)
                H.hasOwnProperty(D) && j[D] !== H[D] && (p || (p = {}), p[D] = H[D]);
            } else
              p || (T || (T = []), T.push(
                oe,
                p
              )), p = H;
          else
            oe === "dangerouslySetInnerHTML" ? (H = H ? H.__html : void 0, j = j ? j.__html : void 0, H != null && j !== H && (T = T || []).push(oe, H)) : oe === "children" ? typeof H != "string" && typeof H != "number" || (T = T || []).push(oe, "" + H) : oe !== "suppressContentEditableWarning" && oe !== "suppressHydrationWarning" && (u.hasOwnProperty(oe) ? (H != null && oe === "onScroll" && gn("scroll", a), T || j === H || (T = [])) : (T = T || []).push(oe, H));
      }
      p && (T = T || []).push("style", p);
      var oe = T;
      (s.updateQueue = oe) && (s.flags |= 4);
    }
  }, Ca = function(a, s, p, v) {
    p !== v && (s.flags |= 4);
  };
  function Hn(a, s) {
    if (!En)
      switch (a.tailMode) {
        case "hidden":
          s = a.tail;
          for (var p = null; s !== null; )
            s.alternate !== null && (p = s), s = s.sibling;
          p === null ? a.tail = null : p.sibling = null;
          break;
        case "collapsed":
          p = a.tail;
          for (var v = null; p !== null; )
            p.alternate !== null && (v = p), p = p.sibling;
          v === null ? s || a.tail === null ? a.tail = null : a.tail.sibling = null : v.sibling = null;
      }
  }
  function Kr(a) {
    var s = a.alternate !== null && a.alternate.child === a.child, p = 0, v = 0;
    if (s)
      for (var S = a.child; S !== null; )
        p |= S.lanes | S.childLanes, v |= S.subtreeFlags & 14680064, v |= S.flags & 14680064, S.return = a, S = S.sibling;
    else
      for (S = a.child; S !== null; )
        p |= S.lanes | S.childLanes, v |= S.subtreeFlags, v |= S.flags, S.return = a, S = S.sibling;
    return a.subtreeFlags |= v, a.childLanes = p, s;
  }
  function Gb(a, s, p) {
    var v = s.pendingProps;
    switch (Oh(s), s.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Kr(s), null;
      case 1:
        return Pn(s.type) && ma(), Kr(s), null;
      case 3:
        return v = s.stateNode, Eu(), tn(Bn), tn(gt), Fh(), v.pendingContext && (v.context = v.pendingContext, v.pendingContext = null), (a === null || a.child === null) && (sf(s) ? s.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(s.flags & 256) || (s.flags |= 1024, ga !== null && (Xh(ga), ga = null))), Nu(a, s), Kr(s), null;
      case 5:
        Uh(s);
        var S = Sl(Wc.current);
        if (p = s.type, a !== null && s.stateNode != null)
          Lu(a, s, p, v, S), a.ref !== s.ref && (s.flags |= 512, s.flags |= 2097152);
        else {
          if (!v) {
            if (s.stateNode === null)
              throw Error(i(166));
            return Kr(s), null;
          }
          if (a = Sl(Ga.current), sf(s)) {
            v = s.stateNode, p = s.type;
            var T = s.memoizedProps;
            switch (v[so] = s, v[vl] = T, a = (s.mode & 1) !== 0, p) {
              case "dialog":
                gn("cancel", v), gn("close", v);
                break;
              case "iframe":
              case "object":
              case "embed":
                gn("load", v);
                break;
              case "video":
              case "audio":
                for (S = 0; S < Uc.length; S++)
                  gn(Uc[S], v);
                break;
              case "source":
                gn("error", v);
                break;
              case "img":
              case "image":
              case "link":
                gn(
                  "error",
                  v
                ), gn("load", v);
                break;
              case "details":
                gn("toggle", v);
                break;
              case "input":
                ur(v, T), gn("invalid", v);
                break;
              case "select":
                v._wrapperState = { wasMultiple: !!T.multiple }, gn("invalid", v);
                break;
              case "textarea":
                Hr(v, T), gn("invalid", v);
            }
            Kn(p, T), S = null;
            for (var D in T)
              if (T.hasOwnProperty(D)) {
                var j = T[D];
                D === "children" ? typeof j == "string" ? v.textContent !== j && (T.suppressHydrationWarning !== !0 && ef(v.textContent, j, a), S = ["children", j]) : typeof j == "number" && v.textContent !== "" + j && (T.suppressHydrationWarning !== !0 && ef(
                  v.textContent,
                  j,
                  a
                ), S = ["children", "" + j]) : u.hasOwnProperty(D) && j != null && D === "onScroll" && gn("scroll", v);
              }
            switch (p) {
              case "input":
                Vr(v), bi(v, T, !0);
                break;
              case "textarea":
                Vr(v), xr(v);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof T.onClick == "function" && (v.onclick = tf);
            }
            v = S, s.updateQueue = v, v !== null && (s.flags |= 4);
          } else {
            D = S.nodeType === 9 ? S : S.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = ki(p)), a === "http://www.w3.org/1999/xhtml" ? p === "script" ? (a = D.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof v.is == "string" ? a = D.createElement(p, { is: v.is }) : (a = D.createElement(p), p === "select" && (D = a, v.multiple ? D.multiple = !0 : v.size && (D.size = v.size))) : a = D.createElementNS(a, p), a[so] = s, a[vl] = v, co(a, s, !1, !1), s.stateNode = a;
            e: {
              switch (D = An(p, v), p) {
                case "dialog":
                  gn("cancel", a), gn("close", a), S = v;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  gn("load", a), S = v;
                  break;
                case "video":
                case "audio":
                  for (S = 0; S < Uc.length; S++)
                    gn(Uc[S], a);
                  S = v;
                  break;
                case "source":
                  gn("error", a), S = v;
                  break;
                case "img":
                case "image":
                case "link":
                  gn(
                    "error",
                    a
                  ), gn("load", a), S = v;
                  break;
                case "details":
                  gn("toggle", a), S = v;
                  break;
                case "input":
                  ur(a, v), S = yr(a, v), gn("invalid", a);
                  break;
                case "option":
                  S = v;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!v.multiple }, S = Ie({}, v, { value: void 0 }), gn("invalid", a);
                  break;
                case "textarea":
                  Hr(a, v), S = Ci(a, v), gn("invalid", a);
                  break;
                default:
                  S = v;
              }
              Kn(p, S), j = S;
              for (T in j)
                if (j.hasOwnProperty(T)) {
                  var H = j[T];
                  T === "style" ? en(a, H) : T === "dangerouslySetInnerHTML" ? (H = H ? H.__html : void 0, H != null && eo(a, H)) : T === "children" ? typeof H == "string" ? (p !== "textarea" || H !== "") && Wi(a, H) : typeof H == "number" && Wi(a, "" + H) : T !== "suppressContentEditableWarning" && T !== "suppressHydrationWarning" && T !== "autoFocus" && (u.hasOwnProperty(T) ? H != null && T === "onScroll" && gn("scroll", a) : H != null && Z(a, T, H, D));
                }
              switch (p) {
                case "input":
                  Vr(a), bi(a, v, !1);
                  break;
                case "textarea":
                  Vr(a), xr(a);
                  break;
                case "option":
                  v.value != null && a.setAttribute("value", "" + Dt(v.value));
                  break;
                case "select":
                  a.multiple = !!v.multiple, T = v.value, T != null ? Br(a, !!v.multiple, T, !1) : v.defaultValue != null && Br(
                    a,
                    !!v.multiple,
                    v.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof S.onClick == "function" && (a.onclick = tf);
              }
              switch (p) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  v = !!v.autoFocus;
                  break e;
                case "img":
                  v = !0;
                  break e;
                default:
                  v = !1;
              }
            }
            v && (s.flags |= 4);
          }
          s.ref !== null && (s.flags |= 512, s.flags |= 2097152);
        }
        return Kr(s), null;
      case 6:
        if (a && s.stateNode != null)
          Ca(a, s, a.memoizedProps, v);
        else {
          if (typeof v != "string" && s.stateNode === null)
            throw Error(i(166));
          if (p = Sl(Wc.current), Sl(Ga.current), sf(s)) {
            if (v = s.stateNode, p = s.memoizedProps, v[so] = s, (T = v.nodeValue !== p) && (a = Xi, a !== null))
              switch (a.tag) {
                case 3:
                  ef(v.nodeValue, p, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 && ef(v.nodeValue, p, (a.mode & 1) !== 0);
              }
            T && (s.flags |= 4);
          } else
            v = (p.nodeType === 9 ? p : p.ownerDocument).createTextNode(v), v[so] = s, s.stateNode = v;
        }
        return Kr(s), null;
      case 13:
        if (tn(Dn), v = s.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (En && Oi !== null && s.mode & 1 && !(s.flags & 128))
            hg(), Un(), s.flags |= 98560, T = !1;
          else if (T = sf(s), v !== null && v.dehydrated !== null) {
            if (a === null) {
              if (!T)
                throw Error(i(318));
              if (T = s.memoizedState, T = T !== null ? T.dehydrated : null, !T)
                throw Error(i(317));
              T[so] = s;
            } else
              Un(), !(s.flags & 128) && (s.memoizedState = null), s.flags |= 4;
            Kr(s), T = !1;
          } else
            ga !== null && (Xh(ga), ga = null), T = !0;
          if (!T)
            return s.flags & 65536 ? s : null;
        }
        return s.flags & 128 ? (s.lanes = p, s) : (v = v !== null, v !== (a !== null && a.memoizedState !== null) && v && (s.child.flags |= 8192, s.mode & 1 && (a === null || Dn.current & 1 ? fr === 0 && (fr = 3) : sd())), s.updateQueue !== null && (s.flags |= 4), Kr(s), null);
      case 4:
        return Eu(), Nu(a, s), a === null && gu(s.stateNode.containerInfo), Kr(s), null;
      case 10:
        return Lh(s.type._context), Kr(s), null;
      case 17:
        return Pn(s.type) && ma(), Kr(s), null;
      case 19:
        if (tn(Dn), T = s.memoizedState, T === null)
          return Kr(s), null;
        if (v = (s.flags & 128) !== 0, D = T.rendering, D === null)
          if (v)
            Hn(T, !1);
          else {
            if (fr !== 0 || a !== null && a.flags & 128)
              for (a = s.child; a !== null; ) {
                if (D = pf(a), D !== null) {
                  for (s.flags |= 128, Hn(T, !1), v = D.updateQueue, v !== null && (s.updateQueue = v, s.flags |= 4), s.subtreeFlags = 0, v = p, p = s.child; p !== null; )
                    T = p, a = v, T.flags &= 14680066, D = T.alternate, D === null ? (T.childLanes = 0, T.lanes = a, T.child = null, T.subtreeFlags = 0, T.memoizedProps = null, T.memoizedState = null, T.updateQueue = null, T.dependencies = null, T.stateNode = null) : (T.childLanes = D.childLanes, T.lanes = D.lanes, T.child = D.child, T.subtreeFlags = 0, T.deletions = null, T.memoizedProps = D.memoizedProps, T.memoizedState = D.memoizedState, T.updateQueue = D.updateQueue, T.type = D.type, a = D.dependencies, T.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), p = p.sibling;
                  return ln(Dn, Dn.current & 1 | 2), s.child;
                }
                a = a.sibling;
              }
            T.tail !== null && Kt() > $u && (s.flags |= 128, v = !0, Hn(T, !1), s.lanes = 4194304);
          }
        else {
          if (!v)
            if (a = pf(D), a !== null) {
              if (s.flags |= 128, v = !0, p = a.updateQueue, p !== null && (s.updateQueue = p, s.flags |= 4), Hn(T, !0), T.tail === null && T.tailMode === "hidden" && !D.alternate && !En)
                return Kr(s), null;
            } else
              2 * Kt() - T.renderingStartTime > $u && p !== 1073741824 && (s.flags |= 128, v = !0, Hn(T, !1), s.lanes = 4194304);
          T.isBackwards ? (D.sibling = s.child, s.child = D) : (p = T.last, p !== null ? p.sibling = D : s.child = D, T.last = D);
        }
        return T.tail !== null ? (s = T.tail, T.rendering = s, T.tail = s.sibling, T.renderingStartTime = Kt(), s.sibling = null, p = Dn.current, ln(Dn, v ? p & 1 | 2 : p & 1), s) : (Kr(s), null);
      case 22:
      case 23:
        return Wf(), v = s.memoizedState !== null, a !== null && a.memoizedState !== null !== v && (s.flags |= 8192), v && s.mode & 1 ? Ii & 1073741824 && (Kr(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : Kr(s), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(i(156, s.tag));
  }
  function Yb(a, s) {
    switch (Oh(s), s.tag) {
      case 1:
        return Pn(s.type) && ma(), a = s.flags, a & 65536 ? (s.flags = a & -65537 | 128, s) : null;
      case 3:
        return Eu(), tn(Bn), tn(gt), Fh(), a = s.flags, a & 65536 && !(a & 128) ? (s.flags = a & -65537 | 128, s) : null;
      case 5:
        return Uh(s), null;
      case 13:
        if (tn(Dn), a = s.memoizedState, a !== null && a.dehydrated !== null) {
          if (s.alternate === null)
            throw Error(i(340));
          Un();
        }
        return a = s.flags, a & 65536 ? (s.flags = a & -65537 | 128, s) : null;
      case 19:
        return tn(Dn), null;
      case 4:
        return Eu(), null;
      case 10:
        return Lh(s.type._context), null;
      case 22:
      case 23:
        return Wf(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Au = !1, Or = !1, If = typeof WeakSet == "function" ? WeakSet : Set, Ge = null;
  function Iu(a, s) {
    var p = a.ref;
    if (p !== null)
      if (typeof p == "function")
        try {
          p(null);
        } catch (v) {
          qn(a, s, v);
        }
      else
        p.current = null;
  }
  function Wh(a, s, p) {
    try {
      p();
    } catch (v) {
      qn(a, s, v);
    }
  }
  var Uf = !1;
  function Kb(a, s) {
    if (Th = da, a = Kd(), No(a)) {
      if ("selectionStart" in a)
        var p = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          p = (p = a.ownerDocument) && p.defaultView || window;
          var v = p.getSelection && p.getSelection();
          if (v && v.rangeCount !== 0) {
            p = v.anchorNode;
            var S = v.anchorOffset, T = v.focusNode;
            v = v.focusOffset;
            try {
              p.nodeType, T.nodeType;
            } catch {
              p = null;
              break e;
            }
            var D = 0, j = -1, H = -1, oe = 0, we = 0, Re = a, Te = null;
            t:
              for (; ; ) {
                for (var He; Re !== p || S !== 0 && Re.nodeType !== 3 || (j = D + S), Re !== T || v !== 0 && Re.nodeType !== 3 || (H = D + v), Re.nodeType === 3 && (D += Re.nodeValue.length), (He = Re.firstChild) !== null; )
                  Te = Re, Re = He;
                for (; ; ) {
                  if (Re === a)
                    break t;
                  if (Te === p && ++oe === S && (j = D), Te === T && ++we === v && (H = D), (He = Re.nextSibling) !== null)
                    break;
                  Re = Te, Te = Re.parentNode;
                }
                Re = He;
              }
            p = j === -1 || H === -1 ? null : { start: j, end: H };
          } else
            p = null;
        }
      p = p || { start: 0, end: 0 };
    } else
      p = null;
    for (hl = { focusedElem: a, selectionRange: p }, da = !1, Ge = s; Ge !== null; )
      if (s = Ge, a = s.child, (s.subtreeFlags & 1028) !== 0 && a !== null)
        a.return = s, Ge = a;
      else
        for (; Ge !== null; ) {
          s = Ge;
          try {
            var Ye = s.alternate;
            if (s.flags & 1024)
              switch (s.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Ye !== null) {
                    var Xe = Ye.memoizedProps, Xn = Ye.memoizedState, Q = s.stateNode, q = Q.getSnapshotBeforeUpdate(s.elementType === s.type ? Xe : Ni(s.type, Xe), Xn);
                    Q.__reactInternalSnapshotBeforeUpdate = q;
                  }
                  break;
                case 3:
                  var ee = s.stateNode.containerInfo;
                  ee.nodeType === 1 ? ee.textContent = "" : ee.nodeType === 9 && ee.documentElement && ee.removeChild(ee.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(i(163));
              }
          } catch (Oe) {
            qn(s, s.return, Oe);
          }
          if (a = s.sibling, a !== null) {
            a.return = s.return, Ge = a;
            break;
          }
          Ge = s.return;
        }
    return Ye = Uf, Uf = !1, Ye;
  }
  function Uu(a, s, p) {
    var v = s.updateQueue;
    if (v = v !== null ? v.lastEffect : null, v !== null) {
      var S = v = v.next;
      do {
        if ((S.tag & a) === a) {
          var T = S.destroy;
          S.destroy = void 0, T !== void 0 && Wh(s, p, T);
        }
        S = S.next;
      } while (S !== v);
    }
  }
  function Ff(a, s) {
    if (s = s.updateQueue, s = s !== null ? s.lastEffect : null, s !== null) {
      var p = s = s.next;
      do {
        if ((p.tag & a) === a) {
          var v = p.create;
          p.destroy = v();
        }
        p = p.next;
      } while (p !== s);
    }
  }
  function jf(a) {
    var s = a.ref;
    if (s !== null) {
      var p = a.stateNode;
      switch (a.tag) {
        case 5:
          a = p;
          break;
        default:
          a = p;
      }
      typeof s == "function" ? s(a) : s.current = a;
    }
  }
  function Ng(a) {
    var s = a.alternate;
    s !== null && (a.alternate = null, Ng(s)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (s = a.stateNode, s !== null && (delete s[so], delete s[vl], delete s[Rh], delete s[Hb], delete s[_h])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function Gh(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Lg(a) {
    e:
      for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || Gh(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
          if (a.flags & 2 || a.child === null || a.tag === 4)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function rd(a, s, p) {
    var v = a.tag;
    if (v === 5 || v === 6)
      a = a.stateNode, s ? p.nodeType === 8 ? p.parentNode.insertBefore(a, s) : p.insertBefore(a, s) : (p.nodeType === 8 ? (s = p.parentNode, s.insertBefore(a, p)) : (s = p, s.appendChild(a)), p = p._reactRootContainer, p != null || s.onclick !== null || (s.onclick = tf));
    else if (v !== 4 && (a = a.child, a !== null))
      for (rd(a, s, p), a = a.sibling; a !== null; )
        rd(a, s, p), a = a.sibling;
  }
  function Fu(a, s, p) {
    var v = a.tag;
    if (v === 5 || v === 6)
      a = a.stateNode, s ? p.insertBefore(a, s) : p.appendChild(a);
    else if (v !== 4 && (a = a.child, a !== null))
      for (Fu(a, s, p), a = a.sibling; a !== null; )
        Fu(a, s, p), a = a.sibling;
  }
  var On = null, Er = !1;
  function oi(a, s, p) {
    for (p = p.child; p !== null; )
      ju(a, s, p), p = p.sibling;
  }
  function ju(a, s, p) {
    if (Ti && typeof Ti.onCommitFiberUnmount == "function")
      try {
        Ti.onCommitFiberUnmount(gs, p);
      } catch {
      }
    switch (p.tag) {
      case 5:
        Or || Iu(p, s);
      case 6:
        var v = On, S = Er;
        On = null, oi(a, s, p), On = v, Er = S, On !== null && (Er ? (a = On, p = p.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(p) : a.removeChild(p)) : On.removeChild(p.stateNode));
        break;
      case 18:
        On !== null && (Er ? (a = On, p = p.stateNode, a.nodeType === 8 ? xs(a.parentNode, p) : a.nodeType === 1 && xs(a, p), Es(a)) : xs(On, p.stateNode));
        break;
      case 4:
        v = On, S = Er, On = p.stateNode.containerInfo, Er = !0, oi(a, s, p), On = v, Er = S;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Or && (v = p.updateQueue, v !== null && (v = v.lastEffect, v !== null))) {
          S = v = v.next;
          do {
            var T = S, D = T.destroy;
            T = T.tag, D !== void 0 && (T & 2 || T & 4) && Wh(p, s, D), S = S.next;
          } while (S !== v);
        }
        oi(a, s, p);
        break;
      case 1:
        if (!Or && (Iu(p, s), v = p.stateNode, typeof v.componentWillUnmount == "function"))
          try {
            v.props = p.memoizedProps, v.state = p.memoizedState, v.componentWillUnmount();
          } catch (j) {
            qn(p, s, j);
          }
        oi(a, s, p);
        break;
      case 21:
        oi(a, s, p);
        break;
      case 22:
        p.mode & 1 ? (Or = (v = Or) || p.memoizedState !== null, oi(a, s, p), Or = v) : oi(a, s, p);
        break;
      default:
        oi(a, s, p);
    }
  }
  function zu(a) {
    var s = a.updateQueue;
    if (s !== null) {
      a.updateQueue = null;
      var p = a.stateNode;
      p === null && (p = a.stateNode = new If()), s.forEach(function(v) {
        var S = nS.bind(null, a, v);
        p.has(v) || (p.add(v), v.then(S, S));
      });
    }
  }
  function wr(a, s) {
    var p = s.deletions;
    if (p !== null)
      for (var v = 0; v < p.length; v++) {
        var S = p[v];
        try {
          var T = a, D = s, j = D;
          e:
            for (; j !== null; ) {
              switch (j.tag) {
                case 5:
                  On = j.stateNode, Er = !1;
                  break e;
                case 3:
                  On = j.stateNode.containerInfo, Er = !0;
                  break e;
                case 4:
                  On = j.stateNode.containerInfo, Er = !0;
                  break e;
              }
              j = j.return;
            }
          if (On === null)
            throw Error(i(160));
          ju(T, D, S), On = null, Er = !1;
          var H = S.alternate;
          H !== null && (H.return = null), S.return = null;
        } catch (oe) {
          qn(S, s, oe);
        }
      }
    if (s.subtreeFlags & 12854)
      for (s = s.child; s !== null; )
        Ag(s, a), s = s.sibling;
  }
  function Ag(a, s) {
    var p = a.alternate, v = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (wr(s, a), fo(a), v & 4) {
          try {
            Uu(3, a, a.return), Ff(3, a);
          } catch (Xe) {
            qn(a, a.return, Xe);
          }
          try {
            Uu(5, a, a.return);
          } catch (Xe) {
            qn(a, a.return, Xe);
          }
        }
        break;
      case 1:
        wr(s, a), fo(a), v & 512 && p !== null && Iu(p, p.return);
        break;
      case 5:
        if (wr(s, a), fo(a), v & 512 && p !== null && Iu(p, p.return), a.flags & 32) {
          var S = a.stateNode;
          try {
            Wi(S, "");
          } catch (Xe) {
            qn(a, a.return, Xe);
          }
        }
        if (v & 4 && (S = a.stateNode, S != null)) {
          var T = a.memoizedProps, D = p !== null ? p.memoizedProps : T, j = a.type, H = a.updateQueue;
          if (a.updateQueue = null, H !== null)
            try {
              j === "input" && T.type === "radio" && T.name != null && er(S, T), An(j, D);
              var oe = An(j, T);
              for (D = 0; D < H.length; D += 2) {
                var we = H[D], Re = H[D + 1];
                we === "style" ? en(S, Re) : we === "dangerouslySetInnerHTML" ? eo(S, Re) : we === "children" ? Wi(S, Re) : Z(S, we, Re, oe);
              }
              switch (j) {
                case "input":
                  Yn(S, T);
                  break;
                case "textarea":
                  qi(S, T);
                  break;
                case "select":
                  var Te = S._wrapperState.wasMultiple;
                  S._wrapperState.wasMultiple = !!T.multiple;
                  var He = T.value;
                  He != null ? Br(S, !!T.multiple, He, !1) : Te !== !!T.multiple && (T.defaultValue != null ? Br(
                    S,
                    !!T.multiple,
                    T.defaultValue,
                    !0
                  ) : Br(S, !!T.multiple, T.multiple ? [] : "", !1));
              }
              S[vl] = T;
            } catch (Xe) {
              qn(a, a.return, Xe);
            }
        }
        break;
      case 6:
        if (wr(s, a), fo(a), v & 4) {
          if (a.stateNode === null)
            throw Error(i(162));
          S = a.stateNode, T = a.memoizedProps;
          try {
            S.nodeValue = T;
          } catch (Xe) {
            qn(a, a.return, Xe);
          }
        }
        break;
      case 3:
        if (wr(s, a), fo(a), v & 4 && p !== null && p.memoizedState.isDehydrated)
          try {
            Es(s.containerInfo);
          } catch (Xe) {
            qn(a, a.return, Xe);
          }
        break;
      case 4:
        wr(s, a), fo(a);
        break;
      case 13:
        wr(s, a), fo(a), S = a.child, S.flags & 8192 && (T = S.memoizedState !== null, S.stateNode.isHidden = T, !T || S.alternate !== null && S.alternate.memoizedState !== null || (Vf = Kt())), v & 4 && zu(a);
        break;
      case 22:
        if (we = p !== null && p.memoizedState !== null, a.mode & 1 ? (Or = (oe = Or) || we, wr(s, a), Or = oe) : wr(s, a), fo(a), v & 8192) {
          if (oe = a.memoizedState !== null, (a.stateNode.isHidden = oe) && !we && a.mode & 1)
            for (Ge = a, we = a.child; we !== null; ) {
              for (Re = Ge = we; Ge !== null; ) {
                switch (Te = Ge, He = Te.child, Te.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Uu(4, Te, Te.return);
                    break;
                  case 1:
                    Iu(Te, Te.return);
                    var Ye = Te.stateNode;
                    if (typeof Ye.componentWillUnmount == "function") {
                      v = Te, p = Te.return;
                      try {
                        s = v, Ye.props = s.memoizedProps, Ye.state = s.memoizedState, Ye.componentWillUnmount();
                      } catch (Xe) {
                        qn(v, p, Xe);
                      }
                    }
                    break;
                  case 5:
                    Iu(Te, Te.return);
                    break;
                  case 22:
                    if (Te.memoizedState !== null) {
                      Ig(Re);
                      continue;
                    }
                }
                He !== null ? (He.return = Te, Ge = He) : Ig(Re);
              }
              we = we.sibling;
            }
          e:
            for (we = null, Re = a; ; ) {
              if (Re.tag === 5) {
                if (we === null) {
                  we = Re;
                  try {
                    S = Re.stateNode, oe ? (T = S.style, typeof T.setProperty == "function" ? T.setProperty("display", "none", "important") : T.display = "none") : (j = Re.stateNode, H = Re.memoizedProps.style, D = H != null && H.hasOwnProperty("display") ? H.display : null, j.style.display = _t("display", D));
                  } catch (Xe) {
                    qn(a, a.return, Xe);
                  }
                }
              } else if (Re.tag === 6) {
                if (we === null)
                  try {
                    Re.stateNode.nodeValue = oe ? "" : Re.memoizedProps;
                  } catch (Xe) {
                    qn(a, a.return, Xe);
                  }
              } else if ((Re.tag !== 22 && Re.tag !== 23 || Re.memoizedState === null || Re === a) && Re.child !== null) {
                Re.child.return = Re, Re = Re.child;
                continue;
              }
              if (Re === a)
                break e;
              for (; Re.sibling === null; ) {
                if (Re.return === null || Re.return === a)
                  break e;
                we === Re && (we = null), Re = Re.return;
              }
              we === Re && (we = null), Re.sibling.return = Re.return, Re = Re.sibling;
            }
        }
        break;
      case 19:
        wr(s, a), fo(a), v & 4 && zu(a);
        break;
      case 21:
        break;
      default:
        wr(
          s,
          a
        ), fo(a);
    }
  }
  function fo(a) {
    var s = a.flags;
    if (s & 2) {
      try {
        e: {
          for (var p = a.return; p !== null; ) {
            if (Gh(p)) {
              var v = p;
              break e;
            }
            p = p.return;
          }
          throw Error(i(160));
        }
        switch (v.tag) {
          case 5:
            var S = v.stateNode;
            v.flags & 32 && (Wi(S, ""), v.flags &= -33);
            var T = Lg(a);
            Fu(a, T, S);
            break;
          case 3:
          case 4:
            var D = v.stateNode.containerInfo, j = Lg(a);
            rd(a, j, D);
            break;
          default:
            throw Error(i(161));
        }
      } catch (H) {
        qn(a, a.return, H);
      }
      a.flags &= -3;
    }
    s & 4096 && (a.flags &= -4097);
  }
  function Qb(a, s, p) {
    Ge = a, Yh(a);
  }
  function Yh(a, s, p) {
    for (var v = (a.mode & 1) !== 0; Ge !== null; ) {
      var S = Ge, T = S.child;
      if (S.tag === 22 && v) {
        var D = S.memoizedState !== null || Au;
        if (!D) {
          var j = S.alternate, H = j !== null && j.memoizedState !== null || Or;
          j = Au;
          var oe = Or;
          if (Au = D, (Or = H) && !oe)
            for (Ge = S; Ge !== null; )
              D = Ge, H = D.child, D.tag === 22 && D.memoizedState !== null ? Kh(S) : H !== null ? (H.return = D, Ge = H) : Kh(S);
          for (; T !== null; )
            Ge = T, Yh(T), T = T.sibling;
          Ge = S, Au = j, Or = oe;
        }
        Vu(a);
      } else
        S.subtreeFlags & 8772 && T !== null ? (T.return = S, Ge = T) : Vu(a);
    }
  }
  function Vu(a) {
    for (; Ge !== null; ) {
      var s = Ge;
      if (s.flags & 8772) {
        var p = s.alternate;
        try {
          if (s.flags & 8772)
            switch (s.tag) {
              case 0:
              case 11:
              case 15:
                Or || Ff(5, s);
                break;
              case 1:
                var v = s.stateNode;
                if (s.flags & 4 && !Or)
                  if (p === null)
                    v.componentDidMount();
                  else {
                    var S = s.elementType === s.type ? p.memoizedProps : Ni(s.type, p.memoizedProps);
                    v.componentDidUpdate(S, p.memoizedState, v.__reactInternalSnapshotBeforeUpdate);
                  }
                var T = s.updateQueue;
                T !== null && bg(s, T, v);
                break;
              case 3:
                var D = s.updateQueue;
                if (D !== null) {
                  if (p = null, s.child !== null)
                    switch (s.child.tag) {
                      case 5:
                        p = s.child.stateNode;
                        break;
                      case 1:
                        p = s.child.stateNode;
                    }
                  bg(s, D, p);
                }
                break;
              case 5:
                var j = s.stateNode;
                if (p === null && s.flags & 4) {
                  p = j;
                  var H = s.memoizedProps;
                  switch (s.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      H.autoFocus && p.focus();
                      break;
                    case "img":
                      H.src && (p.src = H.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (s.memoizedState === null) {
                  var oe = s.alternate;
                  if (oe !== null) {
                    var we = oe.memoizedState;
                    if (we !== null) {
                      var Re = we.dehydrated;
                      Re !== null && Es(Re);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(i(163));
            }
          Or || s.flags & 512 && jf(s);
        } catch (Te) {
          qn(s, s.return, Te);
        }
      }
      if (s === a) {
        Ge = null;
        break;
      }
      if (p = s.sibling, p !== null) {
        p.return = s.return, Ge = p;
        break;
      }
      Ge = s.return;
    }
  }
  function Ig(a) {
    for (; Ge !== null; ) {
      var s = Ge;
      if (s === a) {
        Ge = null;
        break;
      }
      var p = s.sibling;
      if (p !== null) {
        p.return = s.return, Ge = p;
        break;
      }
      Ge = s.return;
    }
  }
  function Kh(a) {
    for (; Ge !== null; ) {
      var s = Ge;
      try {
        switch (s.tag) {
          case 0:
          case 11:
          case 15:
            var p = s.return;
            try {
              Ff(4, s);
            } catch (H) {
              qn(s, p, H);
            }
            break;
          case 1:
            var v = s.stateNode;
            if (typeof v.componentDidMount == "function") {
              var S = s.return;
              try {
                v.componentDidMount();
              } catch (H) {
                qn(s, S, H);
              }
            }
            var T = s.return;
            try {
              jf(s);
            } catch (H) {
              qn(s, T, H);
            }
            break;
          case 5:
            var D = s.return;
            try {
              jf(s);
            } catch (H) {
              qn(s, D, H);
            }
        }
      } catch (H) {
        qn(s, s.return, H);
      }
      if (s === a) {
        Ge = null;
        break;
      }
      var j = s.sibling;
      if (j !== null) {
        j.return = s.return, Ge = j;
        break;
      }
      Ge = s.return;
    }
  }
  var Jb = Math.ceil, xl = B.ReactCurrentDispatcher, zf = B.ReactCurrentOwner, ka = B.ReactCurrentBatchConfig, It = 0, $n = null, wn = null, dr = 0, Ii = 0, Bu = wt(0), fr = 0, id = null, Pl = 0, Hu = 0, Qh = 0, Fs = null, Qr = null, Vf = 0, $u = 1 / 0, Bo = null, Bf = !1, Jh = null, Ta = null, qu = !1, Ea = null, Hf = 0, ad = 0, $f = null, od = -1, Dl = 0;
  function Rr() {
    return It & 6 ? Kt() : od !== -1 ? od : od = Kt();
  }
  function Ho(a) {
    return a.mode & 1 ? It & 2 && dr !== 0 ? dr & -dr : lf.transition !== null ? (Dl === 0 && (Dl = ru()), Dl) : (a = Qt, a !== 0 || (a = window.event, a = a === void 0 ? 16 : xc(a.type)), a) : 1;
  }
  function Fn(a, s, p, v) {
    if (50 < ad)
      throw ad = 0, $f = null, Error(i(185));
    _o(a, p, v), (!(It & 2) || a !== $n) && (a === $n && (!(It & 2) && (Hu |= p), fr === 4 && po(a, dr)), pr(a, v), p === 1 && It === 0 && !(s.mode & 1) && ($u = Kt() + 500, Tr && xi()));
  }
  function pr(a, s) {
    var p = a.callbackNode;
    Ss(a, s);
    var v = ii(a, a === $n ? dr : 0);
    if (v === 0)
      p !== null && kn(p), a.callbackNode = null, a.callbackPriority = 0;
    else if (s = v & -v, a.callbackPriority !== s) {
      if (p != null && kn(p), s === 1)
        a.tag === 0 ? Ph(Wu.bind(null, a)) : xh(Wu.bind(null, a)), wh(function() {
          !(It & 6) && xi();
        }), p = null;
      else {
        switch (au(v)) {
          case 1:
            p = ni;
            break;
          case 4:
            p = Pt;
            break;
          case 16:
            p = ua;
            break;
          case 536870912:
            p = tu;
            break;
          default:
            p = ua;
        }
        p = $g(p, qf.bind(null, a));
      }
      a.callbackPriority = s, a.callbackNode = p;
    }
  }
  function qf(a, s) {
    if (od = -1, Dl = 0, It & 6)
      throw Error(i(327));
    var p = a.callbackNode;
    if (Gu() && a.callbackNode !== p)
      return null;
    var v = ii(a, a === $n ? dr : 0);
    if (v === 0)
      return null;
    if (v & 30 || v & a.expiredLanes || s)
      s = Gf(a, v);
    else {
      s = v;
      var S = It;
      It |= 2;
      var T = Fg();
      ($n !== a || dr !== s) && (Bo = null, $u = Kt() + 500, Ml(a, s));
      do
        try {
          Zb();
          break;
        } catch (j) {
          Ug(a, j);
        }
      while (1);
      Zi(), xl.current = T, It = S, wn !== null ? s = 0 : ($n = null, dr = 0, s = fr);
    }
    if (s !== 0) {
      if (s === 2 && (S = Cs(a), S !== 0 && (v = S, s = Ol(a, S))), s === 1)
        throw p = id, Ml(a, 0), po(a, v), pr(a, Kt()), p;
      if (s === 6)
        po(a, v);
      else {
        if (S = a.current.alternate, !(v & 30) && !Zh(S) && (s = Gf(a, v), s === 2 && (T = Cs(a), T !== 0 && (v = T, s = Ol(a, T))), s === 1))
          throw p = id, Ml(a, 0), po(a, v), pr(a, Kt()), p;
        switch (a.finishedWork = S, a.finishedLanes = v, s) {
          case 0:
          case 1:
            throw Error(i(345));
          case 2:
            js(a, Qr, Bo);
            break;
          case 3:
            if (po(a, v), (v & 130023424) === v && (s = Vf + 500 - Kt(), 10 < s)) {
              if (ii(a, 0) !== 0)
                break;
              if (S = a.suspendedLanes, (S & v) !== v) {
                Rr(), a.pingedLanes |= a.suspendedLanes & S;
                break;
              }
              a.timeoutHandle = ml(js.bind(null, a, Qr, Bo), s);
              break;
            }
            js(a, Qr, Bo);
            break;
          case 4:
            if (po(a, v), (v & 4194240) === v)
              break;
            for (s = a.eventTimes, S = -1; 0 < v; ) {
              var D = 31 - ri(v);
              T = 1 << D, D = s[D], D > S && (S = D), v &= ~T;
            }
            if (v = S, v = Kt() - v, v = (120 > v ? 120 : 480 > v ? 480 : 1080 > v ? 1080 : 1920 > v ? 1920 : 3e3 > v ? 3e3 : 4320 > v ? 4320 : 1960 * Jb(v / 1960)) - v, 10 < v) {
              a.timeoutHandle = ml(js.bind(null, a, Qr, Bo), v);
              break;
            }
            js(a, Qr, Bo);
            break;
          case 5:
            js(a, Qr, Bo);
            break;
          default:
            throw Error(i(329));
        }
      }
    }
    return pr(a, Kt()), a.callbackNode === p ? qf.bind(null, a) : null;
  }
  function Ol(a, s) {
    var p = Fs;
    return a.current.memoizedState.isDehydrated && (Ml(a, s).flags |= 256), a = Gf(a, s), a !== 2 && (s = Qr, Qr = p, s !== null && Xh(s)), a;
  }
  function Xh(a) {
    Qr === null ? Qr = a : Qr.push.apply(Qr, a);
  }
  function Zh(a) {
    for (var s = a; ; ) {
      if (s.flags & 16384) {
        var p = s.updateQueue;
        if (p !== null && (p = p.stores, p !== null))
          for (var v = 0; v < p.length; v++) {
            var S = p[v], T = S.getSnapshot;
            S = S.value;
            try {
              if (!fa(T(), S))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (p = s.child, s.subtreeFlags & 16384 && p !== null)
        p.return = s, s = p;
      else {
        if (s === a)
          break;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === a)
            return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
    }
    return !0;
  }
  function po(a, s) {
    for (s &= ~Qh, s &= ~Hu, a.suspendedLanes |= s, a.pingedLanes &= ~s, a = a.expirationTimes; 0 < s; ) {
      var p = 31 - ri(s), v = 1 << p;
      a[p] = -1, s &= ~v;
    }
  }
  function Wu(a) {
    if (It & 6)
      throw Error(i(327));
    Gu();
    var s = ii(a, 0);
    if (!(s & 1))
      return pr(a, Kt()), null;
    var p = Gf(a, s);
    if (a.tag !== 0 && p === 2) {
      var v = Cs(a);
      v !== 0 && (s = v, p = Ol(a, v));
    }
    if (p === 1)
      throw p = id, Ml(a, 0), po(a, s), pr(a, Kt()), p;
    if (p === 6)
      throw Error(i(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = s, js(a, Qr, Bo), pr(a, Kt()), null;
  }
  function em(a, s) {
    var p = It;
    It |= 1;
    try {
      return a(s);
    } finally {
      It = p, It === 0 && ($u = Kt() + 500, Tr && xi());
    }
  }
  function ho(a) {
    Ea !== null && Ea.tag === 0 && !(It & 6) && Gu();
    var s = It;
    It |= 1;
    var p = ka.transition, v = Qt;
    try {
      if (ka.transition = null, Qt = 1, a)
        return a();
    } finally {
      Qt = v, ka.transition = p, It = s, !(It & 6) && xi();
    }
  }
  function Wf() {
    Ii = Bu.current, tn(Bu);
  }
  function Ml(a, s) {
    a.finishedWork = null, a.finishedLanes = 0;
    var p = a.timeoutHandle;
    if (p !== -1 && (a.timeoutHandle = -1, cg(p)), wn !== null)
      for (p = wn.return; p !== null; ) {
        var v = p;
        switch (Oh(v), v.tag) {
          case 1:
            v = v.type.childContextTypes, v != null && ma();
            break;
          case 3:
            Eu(), tn(Bn), tn(gt), Fh();
            break;
          case 5:
            Uh(v);
            break;
          case 4:
            Eu();
            break;
          case 13:
            tn(Dn);
            break;
          case 19:
            tn(Dn);
            break;
          case 10:
            Lh(v.type._context);
            break;
          case 22:
          case 23:
            Wf();
        }
        p = p.return;
      }
    if ($n = a, wn = a = zs(a.current, null), dr = Ii = s, fr = 0, id = null, Qh = Hu = Pl = 0, Qr = Fs = null, bl !== null) {
      for (s = 0; s < bl.length; s++)
        if (p = bl[s], v = p.interleaved, v !== null) {
          p.interleaved = null;
          var S = v.next, T = p.pending;
          if (T !== null) {
            var D = T.next;
            T.next = S, v.next = D;
          }
          p.pending = v;
        }
      bl = null;
    }
    return a;
  }
  function Ug(a, s) {
    do {
      var p = wn;
      try {
        if (Zi(), mf.current = Yr, ea) {
          for (var v = rt.memoizedState; v !== null; ) {
            var S = v.queue;
            S !== null && (S.pending = null), v = v.next;
          }
          ea = !1;
        }
        if (et = 0, At = yt = rt = null, wu = !1, Yc = 0, zf.current = null, p === null || p.return === null) {
          fr = 1, id = s, wn = null;
          break;
        }
        e: {
          var T = a, D = p.return, j = p, H = s;
          if (s = dr, j.flags |= 32768, H !== null && typeof H == "object" && typeof H.then == "function") {
            var oe = H, we = j, Re = we.tag;
            if (!(we.mode & 1) && (Re === 0 || Re === 11 || Re === 15)) {
              var Te = we.alternate;
              Te ? (we.updateQueue = Te.updateQueue, we.memoizedState = Te.memoizedState, we.lanes = Te.lanes) : (we.updateQueue = null, we.memoizedState = null);
            }
            var He = xg(D);
            if (He !== null) {
              He.flags &= -257, Hh(He, D, j, T, s), He.mode & 1 && Zc(T, oe, s), s = He, H = oe;
              var Ye = s.updateQueue;
              if (Ye === null) {
                var Xe = /* @__PURE__ */ new Set();
                Xe.add(H), s.updateQueue = Xe;
              } else
                Ye.add(H);
              break e;
            } else {
              if (!(s & 1)) {
                Zc(T, oe, s), sd();
                break e;
              }
              H = Error(i(426));
            }
          } else if (En && j.mode & 1) {
            var Xn = xg(D);
            if (Xn !== null) {
              !(Xn.flags & 65536) && (Xn.flags |= 256), Hh(Xn, D, j, T, s), Nh(Is(H, j));
              break e;
            }
          }
          T = H = Is(H, j), fr !== 4 && (fr = 2), Fs === null ? Fs = [T] : Fs.push(T), T = D;
          do {
            switch (T.tag) {
              case 3:
                T.flags |= 65536, s &= -s, T.lanes |= s;
                var Q = Rg(T, H, s);
                yg(T, Q);
                break e;
              case 1:
                j = H;
                var q = T.type, ee = T.stateNode;
                if (!(T.flags & 128) && (typeof q.getDerivedStateFromError == "function" || ee !== null && typeof ee.componentDidCatch == "function" && (Ta === null || !Ta.has(ee)))) {
                  T.flags |= 65536, s &= -s, T.lanes |= s;
                  var Oe = _g(T, j, s);
                  yg(T, Oe);
                  break e;
                }
            }
            T = T.return;
          } while (T !== null);
        }
        zg(p);
      } catch (tt) {
        s = tt, wn === p && p !== null && (wn = p = p.return);
        continue;
      }
      break;
    } while (1);
  }
  function Fg() {
    var a = xl.current;
    return xl.current = Yr, a === null ? Yr : a;
  }
  function sd() {
    (fr === 0 || fr === 3 || fr === 2) && (fr = 4), $n === null || !(Pl & 268435455) && !(Hu & 268435455) || po($n, dr);
  }
  function Gf(a, s) {
    var p = It;
    It |= 2;
    var v = Fg();
    ($n !== a || dr !== s) && (Bo = null, Ml(a, s));
    do
      try {
        Xb();
        break;
      } catch (S) {
        Ug(a, S);
      }
    while (1);
    if (Zi(), It = p, xl.current = v, wn !== null)
      throw Error(i(261));
    return $n = null, dr = 0, fr;
  }
  function Xb() {
    for (; wn !== null; )
      jg(wn);
  }
  function Zb() {
    for (; wn !== null && !qr(); )
      jg(wn);
  }
  function jg(a) {
    var s = Hg(a.alternate, a, Ii);
    a.memoizedProps = a.pendingProps, s === null ? zg(a) : wn = s, zf.current = null;
  }
  function zg(a) {
    var s = a;
    do {
      var p = s.alternate;
      if (a = s.return, s.flags & 32768) {
        if (p = Yb(p, s), p !== null) {
          p.flags &= 32767, wn = p;
          return;
        }
        if (a !== null)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          fr = 6, wn = null;
          return;
        }
      } else if (p = Gb(p, s, Ii), p !== null) {
        wn = p;
        return;
      }
      if (s = s.sibling, s !== null) {
        wn = s;
        return;
      }
      wn = s = a;
    } while (s !== null);
    fr === 0 && (fr = 5);
  }
  function js(a, s, p) {
    var v = Qt, S = ka.transition;
    try {
      ka.transition = null, Qt = 1, eS(a, s, p, v);
    } finally {
      ka.transition = S, Qt = v;
    }
    return null;
  }
  function eS(a, s, p, v) {
    do
      Gu();
    while (Ea !== null);
    if (It & 6)
      throw Error(i(327));
    p = a.finishedWork;
    var S = a.finishedLanes;
    if (p === null)
      return null;
    if (a.finishedWork = null, a.finishedLanes = 0, p === a.current)
      throw Error(i(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var T = p.lanes | p.childLanes;
    if (ih(a, T), a === $n && (wn = $n = null, dr = 0), !(p.subtreeFlags & 2064) && !(p.flags & 2064) || qu || (qu = !0, $g(ua, function() {
      return Gu(), null;
    })), T = (p.flags & 15990) !== 0, p.subtreeFlags & 15990 || T) {
      T = ka.transition, ka.transition = null;
      var D = Qt;
      Qt = 1;
      var j = It;
      It |= 4, zf.current = null, Kb(a, p), Ag(p, a), Qd(hl), da = !!Th, hl = Th = null, a.current = p, Qb(p), io(), It = j, Qt = D, ka.transition = T;
    } else
      a.current = p;
    if (qu && (qu = !1, Ea = a, Hf = S), T = a.pendingLanes, T === 0 && (Ta = null), wc(p.stateNode), pr(a, Kt()), s !== null)
      for (v = a.onRecoverableError, p = 0; p < s.length; p++)
        S = s[p], v(S.value, { componentStack: S.stack, digest: S.digest });
    if (Bf)
      throw Bf = !1, a = Jh, Jh = null, a;
    return Hf & 1 && a.tag !== 0 && Gu(), T = a.pendingLanes, T & 1 ? a === $f ? ad++ : (ad = 0, $f = a) : ad = 0, xi(), null;
  }
  function Gu() {
    if (Ea !== null) {
      var a = au(Hf), s = ka.transition, p = Qt;
      try {
        if (ka.transition = null, Qt = 16 > a ? 16 : a, Ea === null)
          var v = !1;
        else {
          if (a = Ea, Ea = null, Hf = 0, It & 6)
            throw Error(i(331));
          var S = It;
          for (It |= 4, Ge = a.current; Ge !== null; ) {
            var T = Ge, D = T.child;
            if (Ge.flags & 16) {
              var j = T.deletions;
              if (j !== null) {
                for (var H = 0; H < j.length; H++) {
                  var oe = j[H];
                  for (Ge = oe; Ge !== null; ) {
                    var we = Ge;
                    switch (we.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Uu(8, we, T);
                    }
                    var Re = we.child;
                    if (Re !== null)
                      Re.return = we, Ge = Re;
                    else
                      for (; Ge !== null; ) {
                        we = Ge;
                        var Te = we.sibling, He = we.return;
                        if (Ng(we), we === oe) {
                          Ge = null;
                          break;
                        }
                        if (Te !== null) {
                          Te.return = He, Ge = Te;
                          break;
                        }
                        Ge = He;
                      }
                  }
                }
                var Ye = T.alternate;
                if (Ye !== null) {
                  var Xe = Ye.child;
                  if (Xe !== null) {
                    Ye.child = null;
                    do {
                      var Xn = Xe.sibling;
                      Xe.sibling = null, Xe = Xn;
                    } while (Xe !== null);
                  }
                }
                Ge = T;
              }
            }
            if (T.subtreeFlags & 2064 && D !== null)
              D.return = T, Ge = D;
            else
              e:
                for (; Ge !== null; ) {
                  if (T = Ge, T.flags & 2048)
                    switch (T.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Uu(9, T, T.return);
                    }
                  var Q = T.sibling;
                  if (Q !== null) {
                    Q.return = T.return, Ge = Q;
                    break e;
                  }
                  Ge = T.return;
                }
          }
          var q = a.current;
          for (Ge = q; Ge !== null; ) {
            D = Ge;
            var ee = D.child;
            if (D.subtreeFlags & 2064 && ee !== null)
              ee.return = D, Ge = ee;
            else
              e:
                for (D = q; Ge !== null; ) {
                  if (j = Ge, j.flags & 2048)
                    try {
                      switch (j.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Ff(9, j);
                      }
                    } catch (tt) {
                      qn(j, j.return, tt);
                    }
                  if (j === D) {
                    Ge = null;
                    break e;
                  }
                  var Oe = j.sibling;
                  if (Oe !== null) {
                    Oe.return = j.return, Ge = Oe;
                    break e;
                  }
                  Ge = j.return;
                }
          }
          if (It = S, xi(), Ti && typeof Ti.onPostCommitFiberRoot == "function")
            try {
              Ti.onPostCommitFiberRoot(gs, a);
            } catch {
            }
          v = !0;
        }
        return v;
      } finally {
        Qt = p, ka.transition = s;
      }
    }
    return !1;
  }
  function Vg(a, s, p) {
    s = Is(p, s), s = Rg(a, s, 1), a = Ls(a, s, 1), s = Rr(), a !== null && (_o(a, 1, s), pr(a, s));
  }
  function qn(a, s, p) {
    if (a.tag === 3)
      Vg(a, a, p);
    else
      for (; s !== null; ) {
        if (s.tag === 3) {
          Vg(s, a, p);
          break;
        } else if (s.tag === 1) {
          var v = s.stateNode;
          if (typeof s.type.getDerivedStateFromError == "function" || typeof v.componentDidCatch == "function" && (Ta === null || !Ta.has(v))) {
            a = Is(p, a), a = _g(s, a, 1), s = Ls(s, a, 1), a = Rr(), s !== null && (_o(s, 1, a), pr(s, a));
            break;
          }
        }
        s = s.return;
      }
  }
  function tS(a, s, p) {
    var v = a.pingCache;
    v !== null && v.delete(s), s = Rr(), a.pingedLanes |= a.suspendedLanes & p, $n === a && (dr & p) === p && (fr === 4 || fr === 3 && (dr & 130023424) === dr && 500 > Kt() - Vf ? Ml(a, 0) : Qh |= p), pr(a, s);
  }
  function Bg(a, s) {
    s === 0 && (a.mode & 1 ? (s = ys, ys <<= 1, !(ys & 130023424) && (ys = 4194304)) : s = 1);
    var p = Rr();
    a = jo(a, s), a !== null && (_o(a, s, p), pr(a, p));
  }
  function tm(a) {
    var s = a.memoizedState, p = 0;
    s !== null && (p = s.retryLane), Bg(a, p);
  }
  function nS(a, s) {
    var p = 0;
    switch (a.tag) {
      case 13:
        var v = a.stateNode, S = a.memoizedState;
        S !== null && (p = S.retryLane);
        break;
      case 19:
        v = a.stateNode;
        break;
      default:
        throw Error(i(314));
    }
    v !== null && v.delete(s), Bg(a, p);
  }
  var Hg;
  Hg = function(a, s, p) {
    if (a !== null)
      if (a.memoizedProps !== s.pendingProps || Bn.current)
        Li = !0;
      else {
        if (!(a.lanes & p) && !(s.flags & 128))
          return Li = !1, Vo(a, s, p);
        Li = !!(a.flags & 131072);
      }
    else
      Li = !1, En && s.flags & 1048576 && Dh(s, bu, s.index);
    switch (s.lanes = 0, s.tag) {
      case 2:
        var v = s.type;
        nd(a, s), a = s.pendingProps;
        var S = ha(s, gt.current);
        Cu(s, p), S = Se(null, s, v, a, S, p);
        var T = ir();
        return s.flags |= 1, typeof S == "object" && S !== null && typeof S.render == "function" && S.$$typeof === void 0 ? (s.tag = 1, s.memoizedState = null, s.updateQueue = null, Pn(v) ? (T = !0, nf(s)) : T = !1, s.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, cf(s), S.updater = wl, s.stateNode = S, S._reactInternals = s, Vh(s, v, a, p), s = Mf(null, s, v, !0, T, p)) : (s.tag = 0, En && T && rf(s), Qn(null, s, S, p), s = s.child), s;
      case 16:
        v = s.elementType;
        e: {
          switch (nd(a, s), a = s.pendingProps, S = v._init, v = S(v._payload), s.type = v, S = s.tag = rS(v), a = Ni(v, a), S) {
            case 0:
              s = Et(null, s, v, a, p);
              break e;
            case 1:
              s = ed(null, s, v, a, p);
              break e;
            case 11:
              s = Mu(null, s, v, a, p);
              break e;
            case 14:
              s = Us(null, s, v, Ni(v.type, a), p);
              break e;
          }
          throw Error(i(
            306,
            v,
            ""
          ));
        }
        return s;
      case 0:
        return v = s.type, S = s.pendingProps, S = s.elementType === v ? S : Ni(v, S), Et(a, s, v, S, p);
      case 1:
        return v = s.type, S = s.pendingProps, S = s.elementType === v ? S : Ni(v, S), ed(a, s, v, S, p);
      case 3:
        e: {
          if (Wb(s), a === null)
            throw Error(i(387));
          v = s.pendingProps, T = s.memoizedState, S = T.element, ku(a, s), ff(s, v, null, p);
          var D = s.memoizedState;
          if (v = D.element, T.isDehydrated)
            if (T = { element: v, isDehydrated: !1, cache: D.cache, pendingSuspenseBoundaries: D.pendingSuspenseBoundaries, transitions: D.transitions }, s.updateQueue.baseState = T, s.memoizedState = T, s.flags & 256) {
              S = Is(Error(i(423)), s), s = Dg(a, s, v, p, S);
              break e;
            } else if (v !== S) {
              S = Is(Error(i(424)), s), s = Dg(a, s, v, p, S);
              break e;
            } else
              for (Oi = Wa(s.stateNode.containerInfo.firstChild), Xi = s, En = !0, ga = null, p = vg(s, null, v, p), s.child = p; p; )
                p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (Un(), v === S) {
              s = Jn(a, s, p);
              break e;
            }
            Qn(a, s, v, p);
          }
          s = s.child;
        }
        return s;
      case 5:
        return Sg(s), a === null && of(s), v = s.type, S = s.pendingProps, T = a !== null ? a.memoizedProps : null, D = S.children, zc(v, S) ? D = null : T !== null && zc(v, T) && (s.flags |= 32), Rl(a, s), Qn(a, s, D, p), s.child;
      case 6:
        return a === null && of(s), null;
      case 13:
        return Og(a, s, p);
      case 4:
        return Ih(s, s.stateNode.containerInfo), v = s.pendingProps, a === null ? s.child = Su(s, null, v, p) : Qn(a, s, v, p), s.child;
      case 11:
        return v = s.type, S = s.pendingProps, S = s.elementType === v ? S : Ni(v, S), Mu(a, s, v, S, p);
      case 7:
        return Qn(a, s, s.pendingProps, p), s.child;
      case 8:
        return Qn(a, s, s.pendingProps.children, p), s.child;
      case 12:
        return Qn(a, s, s.pendingProps.children, p), s.child;
      case 10:
        e: {
          if (v = s.type._context, S = s.pendingProps, T = s.memoizedProps, D = S.value, ln(Fo, v._currentValue), v._currentValue = D, T !== null)
            if (fa(T.value, D)) {
              if (T.children === S.children && !Bn.current) {
                s = Jn(a, s, p);
                break e;
              }
            } else
              for (T = s.child, T !== null && (T.return = s); T !== null; ) {
                var j = T.dependencies;
                if (j !== null) {
                  D = T.child;
                  for (var H = j.firstContext; H !== null; ) {
                    if (H.context === v) {
                      if (T.tag === 1) {
                        H = Mi(-1, p & -p), H.tag = 2;
                        var oe = T.updateQueue;
                        if (oe !== null) {
                          oe = oe.shared;
                          var we = oe.pending;
                          we === null ? H.next = H : (H.next = we.next, we.next = H), oe.pending = H;
                        }
                      }
                      T.lanes |= p, H = T.alternate, H !== null && (H.lanes |= p), Ah(
                        T.return,
                        p,
                        s
                      ), j.lanes |= p;
                      break;
                    }
                    H = H.next;
                  }
                } else if (T.tag === 10)
                  D = T.type === s.type ? null : T.child;
                else if (T.tag === 18) {
                  if (D = T.return, D === null)
                    throw Error(i(341));
                  D.lanes |= p, j = D.alternate, j !== null && (j.lanes |= p), Ah(D, p, s), D = T.sibling;
                } else
                  D = T.child;
                if (D !== null)
                  D.return = T;
                else
                  for (D = T; D !== null; ) {
                    if (D === s) {
                      D = null;
                      break;
                    }
                    if (T = D.sibling, T !== null) {
                      T.return = D.return, D = T;
                      break;
                    }
                    D = D.return;
                  }
                T = D;
              }
          Qn(a, s, S.children, p), s = s.child;
        }
        return s;
      case 9:
        return S = s.type, v = s.pendingProps.children, Cu(s, p), S = ba(S), v = v(S), s.flags |= 1, Qn(a, s, v, p), s.child;
      case 14:
        return v = s.type, S = Ni(v, s.pendingProps), S = Ni(v.type, S), Us(a, s, v, S, p);
      case 15:
        return Of(a, s, s.type, s.pendingProps, p);
      case 17:
        return v = s.type, S = s.pendingProps, S = s.elementType === v ? S : Ni(v, S), nd(a, s), s.tag = 1, Pn(v) ? (a = !0, nf(s)) : a = !1, Cu(s, p), Tg(s, v, S), Vh(s, v, S, p), Mf(null, s, v, !0, a, p);
      case 19:
        return qh(a, s, p);
      case 22:
        return Ai(a, s, p);
    }
    throw Error(i(156, s.tag));
  };
  function $g(a, s) {
    return hn(a, s);
  }
  function qg(a, s, p, v) {
    this.tag = a, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = v, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function wa(a, s, p, v) {
    return new qg(a, s, p, v);
  }
  function nm(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function rS(a) {
    if (typeof a == "function")
      return nm(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === Ee)
        return 11;
      if (a === vt)
        return 14;
    }
    return 2;
  }
  function zs(a, s) {
    var p = a.alternate;
    return p === null ? (p = wa(a.tag, s, a.key, a.mode), p.elementType = a.elementType, p.type = a.type, p.stateNode = a.stateNode, p.alternate = a, a.alternate = p) : (p.pendingProps = s, p.type = a.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = a.flags & 14680064, p.childLanes = a.childLanes, p.lanes = a.lanes, p.child = a.child, p.memoizedProps = a.memoizedProps, p.memoizedState = a.memoizedState, p.updateQueue = a.updateQueue, s = a.dependencies, p.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, p.sibling = a.sibling, p.index = a.index, p.ref = a.ref, p;
  }
  function Yf(a, s, p, v, S, T) {
    var D = 2;
    if (v = a, typeof a == "function")
      nm(a) && (D = 1);
    else if (typeof a == "string")
      D = 5;
    else
      e:
        switch (a) {
          case te:
            return Nl(p.children, S, T, s);
          case he:
            D = 8, S |= 8;
            break;
          case pe:
            return a = wa(12, p, s, S | 2), a.elementType = pe, a.lanes = T, a;
          case Ne:
            return a = wa(13, p, s, S), a.elementType = Ne, a.lanes = T, a;
          case Je:
            return a = wa(19, p, s, S), a.elementType = Je, a.lanes = T, a;
          case Me:
            return Kf(p, S, T, s);
          default:
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case ye:
                  D = 10;
                  break e;
                case se:
                  D = 9;
                  break e;
                case Ee:
                  D = 11;
                  break e;
                case vt:
                  D = 14;
                  break e;
                case Ct:
                  D = 16, v = null;
                  break e;
              }
            throw Error(i(130, a == null ? a : typeof a, ""));
        }
    return s = wa(D, p, s, S), s.elementType = a, s.type = v, s.lanes = T, s;
  }
  function Nl(a, s, p, v) {
    return a = wa(7, a, v, s), a.lanes = p, a;
  }
  function Kf(a, s, p, v) {
    return a = wa(22, a, v, s), a.elementType = Me, a.lanes = p, a.stateNode = { isHidden: !1 }, a;
  }
  function Qf(a, s, p) {
    return a = wa(6, a, null, s), a.lanes = p, a;
  }
  function ld(a, s, p) {
    return s = wa(4, a.children !== null ? a.children : [], a.key, s), s.lanes = p, s.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, s;
  }
  function ud(a, s, p, v, S) {
    this.tag = s, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = iu(0), this.expirationTimes = iu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = iu(0), this.identifierPrefix = v, this.onRecoverableError = S, this.mutableSourceEagerHydrationData = null;
  }
  function rm(a, s, p, v, S, T, D, j, H) {
    return a = new ud(a, s, p, j, H), s === 1 ? (s = 1, T === !0 && (s |= 8)) : s = 0, T = wa(3, null, null, s), a.current = T, T.stateNode = a, T.memoizedState = { element: v, isDehydrated: p, cache: null, transitions: null, pendingSuspenseBoundaries: null }, cf(T), a;
  }
  function Wg(a, s, p) {
    var v = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: K, key: v == null ? null : "" + v, children: a, containerInfo: s, implementation: p };
  }
  function im(a) {
    if (!a)
      return lo;
    a = a._reactInternals;
    e: {
      if (nt(a) !== a || a.tag !== 1)
        throw Error(i(170));
      var s = a;
      do {
        switch (s.tag) {
          case 3:
            s = s.stateNode.context;
            break e;
          case 1:
            if (Pn(s.type)) {
              s = s.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        s = s.return;
      } while (s !== null);
      throw Error(i(171));
    }
    if (a.tag === 1) {
      var p = a.type;
      if (Pn(p))
        return Hc(a, p, s);
    }
    return s;
  }
  function am(a, s, p, v, S, T, D, j, H) {
    return a = rm(p, v, !0, a, S, T, D, j, H), a.context = im(null), p = a.current, v = Rr(), S = Ho(p), T = Mi(v, S), T.callback = s ?? null, Ls(p, T, S), a.current.lanes = S, _o(a, S, v), pr(a, v), a;
  }
  function Jf(a, s, p, v) {
    var S = s.current, T = Rr(), D = Ho(S);
    return p = im(p), s.context === null ? s.context = p : s.pendingContext = p, s = Mi(T, D), s.payload = { element: a }, v = v === void 0 ? null : v, v !== null && (s.callback = v), a = Ls(S, s, D), a !== null && (Fn(a, S, D, T), df(a, S, D)), D;
  }
  function cd(a) {
    if (a = a.current, !a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function Gg(a, s) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var p = a.retryLane;
      a.retryLane = p !== 0 && p < s ? p : s;
    }
  }
  function om(a, s) {
    Gg(a, s), (a = a.alternate) && Gg(a, s);
  }
  function iS() {
    return null;
  }
  var sm = typeof reportError == "function" ? reportError : function(a) {
    console.error(a);
  };
  function Xf(a) {
    this._internalRoot = a;
  }
  dd.prototype.render = Xf.prototype.render = function(a) {
    var s = this._internalRoot;
    if (s === null)
      throw Error(i(409));
    Jf(a, s, null, null);
  }, dd.prototype.unmount = Xf.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var s = a.containerInfo;
      ho(function() {
        Jf(null, a, null, null);
      }), s[Io] = null;
    }
  };
  function dd(a) {
    this._internalRoot = a;
  }
  dd.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var s = su();
      a = { blockedOn: null, target: a, priority: s };
      for (var p = 0; p < sn.length && s !== 0 && s < sn[p].priority; p++)
        ;
      sn.splice(p, 0, a), p === 0 && Hd(a);
    }
  };
  function Vs(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function Zf(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
  }
  function Yg() {
  }
  function aS(a, s, p, v, S) {
    if (S) {
      if (typeof v == "function") {
        var T = v;
        v = function() {
          var oe = cd(D);
          T.call(oe);
        };
      }
      var D = am(s, v, a, 0, null, !1, !1, "", Yg);
      return a._reactRootContainer = D, a[Io] = D.current, gu(a.nodeType === 8 ? a.parentNode : a), ho(), D;
    }
    for (; S = a.lastChild; )
      a.removeChild(S);
    if (typeof v == "function") {
      var j = v;
      v = function() {
        var oe = cd(H);
        j.call(oe);
      };
    }
    var H = rm(a, 0, !1, null, null, !1, !1, "", Yg);
    return a._reactRootContainer = H, a[Io] = H.current, gu(a.nodeType === 8 ? a.parentNode : a), ho(function() {
      Jf(s, H, p, v);
    }), H;
  }
  function ep(a, s, p, v, S) {
    var T = p._reactRootContainer;
    if (T) {
      var D = T;
      if (typeof S == "function") {
        var j = S;
        S = function() {
          var H = cd(D);
          j.call(H);
        };
      }
      Jf(s, D, a, S);
    } else
      D = aS(p, s, a, S, v);
    return cd(D);
  }
  sl = function(a) {
    switch (a.tag) {
      case 3:
        var s = a.stateNode;
        if (s.current.memoizedState.isDehydrated) {
          var p = Va(s.pendingLanes);
          p !== 0 && (ao(s, p | 1), pr(s, Kt()), !(It & 6) && ($u = Kt() + 500, xi()));
        }
        break;
      case 13:
        ho(function() {
          var v = jo(a, 1);
          if (v !== null) {
            var S = Rr();
            Fn(v, a, 1, S);
          }
        }), om(a, 1);
    }
  }, ou = function(a) {
    if (a.tag === 13) {
      var s = jo(a, 134217728);
      if (s !== null) {
        var p = Rr();
        Fn(s, a, 134217728, p);
      }
      om(a, 134217728);
    }
  }, zt = function(a) {
    if (a.tag === 13) {
      var s = Ho(a), p = jo(a, s);
      if (p !== null) {
        var v = Rr();
        Fn(p, a, s, v);
      }
      om(a, s);
    }
  }, su = function() {
    return Qt;
  }, lu = function(a, s) {
    var p = Qt;
    try {
      return Qt = a, s();
    } finally {
      Qt = p;
    }
  }, ei = function(a, s, p) {
    switch (s) {
      case "input":
        if (Yn(a, p), s = p.name, p.type === "radio" && s != null) {
          for (p = a; p.parentNode; )
            p = p.parentNode;
          for (p = p.querySelectorAll("input[name=" + JSON.stringify("" + s) + '][type="radio"]'), s = 0; s < p.length; s++) {
            var v = p[s];
            if (v !== a && v.form === a.form) {
              var S = st(v);
              if (!S)
                throw Error(i(90));
              yi(v), Yn(v, S);
            }
          }
        }
        break;
      case "textarea":
        qi(a, p);
        break;
      case "select":
        s = p.value, s != null && Br(a, !!p.multiple, s, !1);
    }
  }, ol = em, eu = ho;
  var oS = { usingClientEntryPoint: !1, Events: [Bc, yu, st, la, hs, em] }, fd = { findFiberByHostInstance: pa, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Kg = { bundleType: fd.bundleType, version: fd.version, rendererPackageName: fd.rendererPackageName, rendererConfig: fd.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: B.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    return a = xt(a), a === null ? null : a.stateNode;
  }, findFiberByHostInstance: fd.findFiberByHostInstance || iS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var tp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!tp.isDisabled && tp.supportsFiber)
      try {
        gs = tp.inject(Kg), Ti = tp;
      } catch {
      }
  }
  return Oa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oS, Oa.createPortal = function(a, s) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Vs(s))
      throw Error(i(200));
    return Wg(a, s, null, p);
  }, Oa.createRoot = function(a, s) {
    if (!Vs(a))
      throw Error(i(299));
    var p = !1, v = "", S = sm;
    return s != null && (s.unstable_strictMode === !0 && (p = !0), s.identifierPrefix !== void 0 && (v = s.identifierPrefix), s.onRecoverableError !== void 0 && (S = s.onRecoverableError)), s = rm(a, 1, !1, null, null, p, !1, v, S), a[Io] = s.current, gu(a.nodeType === 8 ? a.parentNode : a), new Xf(s);
  }, Oa.findDOMNode = function(a) {
    if (a == null)
      return null;
    if (a.nodeType === 1)
      return a;
    var s = a._reactInternals;
    if (s === void 0)
      throw typeof a.render == "function" ? Error(i(188)) : (a = Object.keys(a).join(","), Error(i(268, a)));
    return a = xt(s), a = a === null ? null : a.stateNode, a;
  }, Oa.flushSync = function(a) {
    return ho(a);
  }, Oa.hydrate = function(a, s, p) {
    if (!Zf(s))
      throw Error(i(200));
    return ep(null, a, s, !0, p);
  }, Oa.hydrateRoot = function(a, s, p) {
    if (!Vs(a))
      throw Error(i(405));
    var v = p != null && p.hydratedSources || null, S = !1, T = "", D = sm;
    if (p != null && (p.unstable_strictMode === !0 && (S = !0), p.identifierPrefix !== void 0 && (T = p.identifierPrefix), p.onRecoverableError !== void 0 && (D = p.onRecoverableError)), s = am(s, null, a, 1, p ?? null, S, !1, T, D), a[Io] = s.current, gu(a), v)
      for (a = 0; a < v.length; a++)
        p = v[a], S = p._getVersion, S = S(p._source), s.mutableSourceEagerHydrationData == null ? s.mutableSourceEagerHydrationData = [p, S] : s.mutableSourceEagerHydrationData.push(
          p,
          S
        );
    return new dd(s);
  }, Oa.render = function(a, s, p) {
    if (!Zf(s))
      throw Error(i(200));
    return ep(null, a, s, !1, p);
  }, Oa.unmountComponentAtNode = function(a) {
    if (!Zf(a))
      throw Error(i(40));
    return a._reactRootContainer ? (ho(function() {
      ep(null, null, a, !1, function() {
        a._reactRootContainer = null, a[Io] = null;
      });
    }), !0) : !1;
  }, Oa.unstable_batchedUpdates = em, Oa.unstable_renderSubtreeIntoContainer = function(a, s, p, v) {
    if (!Zf(p))
      throw Error(i(200));
    if (a == null || a._reactInternals === void 0)
      throw Error(i(38));
    return ep(a, s, p, !1, v);
  }, Oa.version = "18.3.1-next-f1338f8080-20240426", Oa;
}
var Ma = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var A_;
function u5() {
  return A_ || (A_ = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var r = R, t = vP(), i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function u(e) {
      o = e;
    }
    function d(e) {
      if (!o) {
        for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), f = 1; f < n; f++)
          l[f - 1] = arguments[f];
        m("warn", e, l);
      }
    }
    function c(e) {
      if (!o) {
        for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), f = 1; f < n; f++)
          l[f - 1] = arguments[f];
        m("error", e, l);
      }
    }
    function m(e, n, l) {
      {
        var f = i.ReactDebugCurrentFrame, h = f.getStackAddendum();
        h !== "" && (n += "%s", l = l.concat([h]));
        var y = l.map(function(k) {
          return String(k);
        });
        y.unshift("Warning: " + n), Function.prototype.apply.call(console[e], console, y);
      }
    }
    var g = 0, b = 1, C = 2, E = 3, x = 4, O = 5, N = 6, M = 7, I = 8, U = 9, ae = 10, Z = 11, B = 12, F = 13, K = 14, te = 15, he = 16, pe = 17, ye = 18, se = 19, Ee = 21, Ne = 22, Je = 23, vt = 24, Ct = 25, Me = !0, Pe = !1, Ze = !1, Ie = !1, Y = !1, ge = !0, lt = !1, Be = !0, kt = !0, Rt = !0, Ft = !0, Dt = /* @__PURE__ */ new Set(), Ot = {}, yn = {};
    function Vr(e, n) {
      yi(e, n), yi(e + "Capture", n);
    }
    function yi(e, n) {
      Ot[e] && c("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), Ot[e] = n;
      {
        var l = e.toLowerCase();
        yn[l] = e, e === "onDoubleClick" && (yn.ondblclick = e);
      }
      for (var f = 0; f < n.length; f++)
        Dt.add(n[f]);
    }
    var Nn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", yr = Object.prototype.hasOwnProperty;
    function ur(e) {
      {
        var n = typeof Symbol == "function" && Symbol.toStringTag, l = n && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return l;
      }
    }
    function er(e) {
      try {
        return Yn(e), !1;
      } catch {
        return !0;
      }
    }
    function Yn(e) {
      return "" + e;
    }
    function bi(e, n) {
      if (er(e))
        return c("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", n, ur(e)), Yn(e);
    }
    function Si(e) {
      if (er(e))
        return c("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ur(e)), Yn(e);
    }
    function br(e, n) {
      if (er(e))
        return c("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", n, ur(e)), Yn(e);
    }
    function Br(e, n) {
      if (er(e))
        return c("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", n, ur(e)), Yn(e);
    }
    function Ci(e) {
      if (er(e))
        return c("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ur(e)), Yn(e);
    }
    function Hr(e) {
      if (er(e))
        return c("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ur(e)), Yn(e);
    }
    var qi = 0, xr = 1, ki = 2, Ln = 3, Zr = 4, eo = 5, Wi = 6, Ae = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", at = Ae + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", _t = new RegExp("^[" + Ae + "][" + at + "]*$"), en = {}, rn = {};
    function Kn(e) {
      return yr.call(rn, e) ? !0 : yr.call(en, e) ? !1 : _t.test(e) ? (rn[e] = !0, !0) : (en[e] = !0, c("Invalid attribute name: `%s`", e), !1);
    }
    function An(e, n, l) {
      return n !== null ? n.type === qi : l ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function $r(e, n, l, f) {
      if (l !== null && l.type === qi)
        return !1;
      switch (typeof n) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (f)
            return !1;
          if (l !== null)
            return !l.acceptsBooleans;
          var h = e.toLowerCase().slice(0, 5);
          return h !== "data-" && h !== "aria-";
        }
        default:
          return !1;
      }
    }
    function cn(e, n, l, f) {
      if (n === null || typeof n > "u" || $r(e, n, l, f))
        return !0;
      if (f)
        return !1;
      if (l !== null)
        switch (l.type) {
          case Ln:
            return !n;
          case Zr:
            return n === !1;
          case eo:
            return isNaN(n);
          case Wi:
            return isNaN(n) || n < 1;
        }
      return !1;
    }
    function ei(e) {
      return on.hasOwnProperty(e) ? on[e] : null;
    }
    function an(e, n, l, f, h, y, k) {
      this.acceptsBooleans = n === ki || n === Ln || n === Zr, this.attributeName = f, this.attributeNamespace = h, this.mustUseProperty = l, this.propertyName = e, this.type = n, this.sanitizeURL = y, this.removeEmptyString = k;
    }
    var on = {}, ja = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ja.forEach(function(e) {
      on[e] = new an(
        e,
        qi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var n = e[0], l = e[1];
      on[n] = new an(
        n,
        xr,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      on[e] = new an(
        e,
        ki,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      on[e] = new an(
        e,
        ki,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      on[e] = new an(
        e,
        Ln,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      on[e] = new an(
        e,
        Ln,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      on[e] = new an(
        e,
        Zr,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      on[e] = new an(
        e,
        Wi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      on[e] = new an(
        e,
        eo,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var la = /[\-\:]([a-z])/g, hs = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var n = e.replace(la, hs);
      on[n] = new an(
        n,
        xr,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var n = e.replace(la, hs);
      on[n] = new an(
        n,
        xr,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var n = e.replace(la, hs);
      on[n] = new an(
        n,
        xr,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      on[e] = new an(
        e,
        xr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ol = "xlinkHref";
    on[ol] = new an(
      "xlinkHref",
      xr,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      on[e] = new an(
        e,
        xr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var eu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ro = !1;
    function ms(e) {
      !Ro && eu.test(e) && (Ro = !0, c("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function Gi(e, n, l, f) {
      if (f.mustUseProperty) {
        var h = f.propertyName;
        return e[h];
      } else {
        bi(l, n), f.sanitizeURL && ms("" + l);
        var y = f.attributeName, k = null;
        if (f.type === Zr) {
          if (e.hasAttribute(y)) {
            var w = e.getAttribute(y);
            return w === "" ? !0 : cn(n, l, f, !1) ? w : w === "" + l ? l : w;
          }
        } else if (e.hasAttribute(y)) {
          if (cn(n, l, f, !1))
            return e.getAttribute(y);
          if (f.type === Ln)
            return l;
          k = e.getAttribute(y);
        }
        return cn(n, l, f, !1) ? k === null ? l : k : k === "" + l ? l : k;
      }
    }
    function to(e, n, l, f) {
      {
        if (!Kn(n))
          return;
        if (!e.hasAttribute(n))
          return l === void 0 ? void 0 : null;
        var h = e.getAttribute(n);
        return bi(l, n), h === "" + l ? l : h;
      }
    }
    function Yi(e, n, l, f) {
      var h = ei(n);
      if (!An(n, h, f)) {
        if (cn(n, l, h, f) && (l = null), f || h === null) {
          if (Kn(n)) {
            var y = n;
            l === null ? e.removeAttribute(y) : (bi(l, n), e.setAttribute(y, "" + l));
          }
          return;
        }
        var k = h.mustUseProperty;
        if (k) {
          var w = h.propertyName;
          if (l === null) {
            var _ = h.type;
            e[w] = _ === Ln ? !1 : "";
          } else
            e[w] = l;
          return;
        }
        var L = h.attributeName, A = h.attributeNamespace;
        if (l === null)
          e.removeAttribute(L);
        else {
          var W = h.type, $;
          W === Ln || W === Zr && l === !0 ? $ = "" : (bi(l, L), $ = "" + l, h.sanitizeURL && ms($.toString())), A ? e.setAttributeNS(A, L, $) : e.setAttribute(L, $);
        }
      }
    }
    var za = Symbol.for("react.element"), ti = Symbol.for("react.portal"), Ki = Symbol.for("react.fragment"), no = Symbol.for("react.strict_mode"), ro = Symbol.for("react.profiler"), V = Symbol.for("react.provider"), ke = Symbol.for("react.context"), _e = Symbol.for("react.forward_ref"), nt = Symbol.for("react.suspense"), Nt = Symbol.for("react.suspense_list"), jt = Symbol.for("react.memo"), dt = Symbol.for("react.lazy"), xt = Symbol.for("react.scope"), tr = Symbol.for("react.debug_trace_mode"), hn = Symbol.for("react.offscreen"), kn = Symbol.for("react.legacy_hidden"), qr = Symbol.for("react.cache"), io = Symbol.for("react.tracing_marker"), Kt = Symbol.iterator, Sr = "@@iterator";
    function ni(e) {
      if (e === null || typeof e != "object")
        return null;
      var n = Kt && e[Kt] || e[Sr];
      return typeof n == "function" ? n : null;
    }
    var Pt = Object.assign, ua = 0, vs, tu, gs, Ti, wc, ri, Rc;
    function _c() {
    }
    _c.__reactDisabledLog = !0;
    function Vd() {
      {
        if (ua === 0) {
          vs = console.log, tu = console.info, gs = console.warn, Ti = console.error, wc = console.group, ri = console.groupCollapsed, Rc = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: _c,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        ua++;
      }
    }
    function nu() {
      {
        if (ua--, ua === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Pt({}, e, {
              value: vs
            }),
            info: Pt({}, e, {
              value: tu
            }),
            warn: Pt({}, e, {
              value: gs
            }),
            error: Pt({}, e, {
              value: Ti
            }),
            group: Pt({}, e, {
              value: wc
            }),
            groupCollapsed: Pt({}, e, {
              value: ri
            }),
            groupEnd: Pt({}, e, {
              value: Rc
            })
          });
        }
        ua < 0 && c("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ys = i.ReactCurrentDispatcher, Va;
    function ii(e, n, l) {
      {
        if (Va === void 0)
          try {
            throw Error();
          } catch (h) {
            var f = h.stack.trim().match(/\n( *(at )?)/);
            Va = f && f[1] || "";
          }
        return `
` + Va + e;
      }
    }
    var bs = !1, Ss;
    {
      var Cs = typeof WeakMap == "function" ? WeakMap : Map;
      Ss = new Cs();
    }
    function ru(e, n) {
      if (!e || bs)
        return "";
      {
        var l = Ss.get(e);
        if (l !== void 0)
          return l;
      }
      var f;
      bs = !0;
      var h = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var y;
      y = ys.current, ys.current = null, Vd();
      try {
        if (n) {
          var k = function() {
            throw Error();
          };
          if (Object.defineProperty(k.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(k, []);
            } catch (le) {
              f = le;
            }
            Reflect.construct(e, [], k);
          } else {
            try {
              k.call();
            } catch (le) {
              f = le;
            }
            e.call(k.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (le) {
            f = le;
          }
          e();
        }
      } catch (le) {
        if (le && f && typeof le.stack == "string") {
          for (var w = le.stack.split(`
`), _ = f.stack.split(`
`), L = w.length - 1, A = _.length - 1; L >= 1 && A >= 0 && w[L] !== _[A]; )
            A--;
          for (; L >= 1 && A >= 0; L--, A--)
            if (w[L] !== _[A]) {
              if (L !== 1 || A !== 1)
                do
                  if (L--, A--, A < 0 || w[L] !== _[A]) {
                    var W = `
` + w[L].replace(" at new ", " at ");
                    return e.displayName && W.includes("<anonymous>") && (W = W.replace("<anonymous>", e.displayName)), typeof e == "function" && Ss.set(e, W), W;
                  }
                while (L >= 1 && A >= 0);
              break;
            }
        }
      } finally {
        bs = !1, ys.current = y, nu(), Error.prepareStackTrace = h;
      }
      var $ = e ? e.displayName || e.name : "", re = $ ? ii($) : "";
      return typeof e == "function" && Ss.set(e, re), re;
    }
    function iu(e, n, l) {
      return ru(e, !0);
    }
    function _o(e, n, l) {
      return ru(e, !1);
    }
    function ih(e) {
      var n = e.prototype;
      return !!(n && n.isReactComponent);
    }
    function ao(e, n, l) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return ru(e, ih(e));
      if (typeof e == "string")
        return ii(e);
      switch (e) {
        case nt:
          return ii("Suspense");
        case Nt:
          return ii("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case _e:
            return _o(e.render);
          case jt:
            return ao(e.type, n, l);
          case dt: {
            var f = e, h = f._payload, y = f._init;
            try {
              return ao(y(h), n, l);
            } catch {
            }
          }
        }
      return "";
    }
    function Qt(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case O:
          return ii(e.type);
        case he:
          return ii("Lazy");
        case F:
          return ii("Suspense");
        case se:
          return ii("SuspenseList");
        case g:
        case C:
        case te:
          return _o(e.type);
        case Z:
          return _o(e.type.render);
        case b:
          return iu(e.type);
        default:
          return "";
      }
    }
    function au(e) {
      try {
        var n = "", l = e;
        do
          n += Qt(l), l = l.return;
        while (l);
        return n;
      } catch (f) {
        return `
Error generating stack: ` + f.message + `
` + f.stack;
      }
    }
    function sl(e, n, l) {
      var f = e.displayName;
      if (f)
        return f;
      var h = n.displayName || n.name || "";
      return h !== "" ? l + "(" + h + ")" : l;
    }
    function ou(e) {
      return e.displayName || "Context";
    }
    function zt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && c("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case Ki:
          return "Fragment";
        case ti:
          return "Portal";
        case ro:
          return "Profiler";
        case no:
          return "StrictMode";
        case nt:
          return "Suspense";
        case Nt:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case ke:
            var n = e;
            return ou(n) + ".Consumer";
          case V:
            var l = e;
            return ou(l._context) + ".Provider";
          case _e:
            return sl(e, e.render, "ForwardRef");
          case jt:
            var f = e.displayName || null;
            return f !== null ? f : zt(e.type) || "Memo";
          case dt: {
            var h = e, y = h._payload, k = h._init;
            try {
              return zt(k(y));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function su(e, n, l) {
      var f = n.displayName || n.name || "";
      return e.displayName || (f !== "" ? l + "(" + f + ")" : l);
    }
    function lu(e) {
      return e.displayName || "Context";
    }
    function bt(e) {
      var n = e.tag, l = e.type;
      switch (n) {
        case vt:
          return "Cache";
        case U:
          var f = l;
          return lu(f) + ".Consumer";
        case ae:
          var h = l;
          return lu(h._context) + ".Provider";
        case ye:
          return "DehydratedFragment";
        case Z:
          return su(l, l.render, "ForwardRef");
        case M:
          return "Fragment";
        case O:
          return l;
        case x:
          return "Portal";
        case E:
          return "Root";
        case N:
          return "Text";
        case he:
          return zt(l);
        case I:
          return l === no ? "StrictMode" : "Mode";
        case Ne:
          return "Offscreen";
        case B:
          return "Profiler";
        case Ee:
          return "Scope";
        case F:
          return "Suspense";
        case se:
          return "SuspenseList";
        case Ct:
          return "TracingMarker";
        case b:
        case g:
        case pe:
        case C:
        case K:
        case te:
          if (typeof l == "function")
            return l.displayName || l.name || null;
          if (typeof l == "string")
            return l;
          break;
      }
      return null;
    }
    var ll = i.ReactDebugCurrentFrame, In = null, Ei = !1;
    function ai() {
      {
        if (In === null)
          return null;
        var e = In._debugOwner;
        if (e !== null && typeof e < "u")
          return bt(e);
      }
      return null;
    }
    function ks() {
      return In === null ? "" : au(In);
    }
    function Vn() {
      ll.getCurrentStack = null, In = null, Ei = !1;
    }
    function sn(e) {
      ll.getCurrentStack = e === null ? null : ks, In = e, Ei = !1;
    }
    function Bd() {
      return In;
    }
    function wi(e) {
      Ei = e;
    }
    function Cr(e) {
      return "" + e;
    }
    function oo(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return Hr(e), e;
        default:
          return "";
      }
    }
    var Hd = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function xo(e, n) {
      Hd[n.type] || n.onChange || n.onInput || n.readOnly || n.disabled || n.value == null || c("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), n.onChange || n.readOnly || n.disabled || n.checked == null || c("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ts(e) {
      var n = e.type, l = e.nodeName;
      return l && l.toLowerCase() === "input" && (n === "checkbox" || n === "radio");
    }
    function $d(e) {
      return e._valueTracker;
    }
    function ca(e) {
      e._valueTracker = null;
    }
    function Es(e) {
      var n = "";
      return e && (Ts(e) ? n = e.checked ? "true" : "false" : n = e.value), n;
    }
    function Po(e) {
      var n = Ts(e) ? "checked" : "value", l = Object.getOwnPropertyDescriptor(e.constructor.prototype, n);
      Hr(e[n]);
      var f = "" + e[n];
      if (!(e.hasOwnProperty(n) || typeof l > "u" || typeof l.get != "function" || typeof l.set != "function")) {
        var h = l.get, y = l.set;
        Object.defineProperty(e, n, {
          configurable: !0,
          get: function() {
            return h.call(this);
          },
          set: function(w) {
            Hr(w), f = "" + w, y.call(this, w);
          }
        }), Object.defineProperty(e, n, {
          enumerable: l.enumerable
        });
        var k = {
          getValue: function() {
            return f;
          },
          setValue: function(w) {
            Hr(w), f = "" + w;
          },
          stopTracking: function() {
            ca(e), delete e[n];
          }
        };
        return k;
      }
    }
    function da(e) {
      $d(e) || (e._valueTracker = Po(e));
    }
    function uu(e) {
      if (!e)
        return !1;
      var n = $d(e);
      if (!n)
        return !0;
      var l = n.getValue(), f = Es(e);
      return f !== l ? (n.setValue(f), !0) : !1;
    }
    function ws(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Rs = !1, ul = !1, cu = !1, xc = !1;
    function Ba(e) {
      var n = e.type === "checkbox" || e.type === "radio";
      return n ? e.checked != null : e.value != null;
    }
    function P(e, n) {
      var l = e, f = n.checked, h = Pt({}, n, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: f ?? l._wrapperState.initialChecked
      });
      return h;
    }
    function z(e, n) {
      xo("input", n), n.checked !== void 0 && n.defaultChecked !== void 0 && !ul && (c("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ai() || "A component", n.type), ul = !0), n.value !== void 0 && n.defaultValue !== void 0 && !Rs && (c("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ai() || "A component", n.type), Rs = !0);
      var l = e, f = n.defaultValue == null ? "" : n.defaultValue;
      l._wrapperState = {
        initialChecked: n.checked != null ? n.checked : n.defaultChecked,
        initialValue: oo(n.value != null ? n.value : f),
        controlled: Ba(n)
      };
    }
    function ie(e, n) {
      var l = e, f = n.checked;
      f != null && Yi(l, "checked", f, !1);
    }
    function de(e, n) {
      var l = e;
      {
        var f = Ba(n);
        !l._wrapperState.controlled && f && !xc && (c("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), xc = !0), l._wrapperState.controlled && !f && !cu && (c("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), cu = !0);
      }
      ie(e, n);
      var h = oo(n.value), y = n.type;
      if (h != null)
        y === "number" ? (h === 0 && l.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        l.value != h) && (l.value = Cr(h)) : l.value !== Cr(h) && (l.value = Cr(h));
      else if (y === "submit" || y === "reset") {
        l.removeAttribute("value");
        return;
      }
      n.hasOwnProperty("value") ? ct(l, n.type, h) : n.hasOwnProperty("defaultValue") && ct(l, n.type, oo(n.defaultValue)), n.checked == null && n.defaultChecked != null && (l.defaultChecked = !!n.defaultChecked);
    }
    function De(e, n, l) {
      var f = e;
      if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) {
        var h = n.type, y = h === "submit" || h === "reset";
        if (y && (n.value === void 0 || n.value === null))
          return;
        var k = Cr(f._wrapperState.initialValue);
        l || k !== f.value && (f.value = k), f.defaultValue = k;
      }
      var w = f.name;
      w !== "" && (f.name = ""), f.defaultChecked = !f.defaultChecked, f.defaultChecked = !!f._wrapperState.initialChecked, w !== "" && (f.name = w);
    }
    function ft(e, n) {
      var l = e;
      de(l, n), je(l, n);
    }
    function je(e, n) {
      var l = n.name;
      if (n.type === "radio" && l != null) {
        for (var f = e; f.parentNode; )
          f = f.parentNode;
        bi(l, "name");
        for (var h = f.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), y = 0; y < h.length; y++) {
          var k = h[y];
          if (!(k === e || k.form !== e.form)) {
            var w = fy(k);
            if (!w)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            uu(k), de(k, w);
          }
        }
      }
    }
    function ct(e, n, l) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (n !== "number" || ws(e.ownerDocument) !== e) && (l == null ? e.defaultValue = Cr(e._wrapperState.initialValue) : e.defaultValue !== Cr(l) && (e.defaultValue = Cr(l)));
    }
    var Lt = !1, Gt = !1, mn = !1;
    function dn(e, n) {
      n.value == null && (typeof n.children == "object" && n.children !== null ? r.Children.forEach(n.children, function(l) {
        l != null && (typeof l == "string" || typeof l == "number" || Gt || (Gt = !0, c("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : n.dangerouslySetInnerHTML != null && (mn || (mn = !0, c("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), n.selected != null && !Lt && (c("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Lt = !0);
    }
    function vn(e, n) {
      n.value != null && e.setAttribute("value", Cr(oo(n.value)));
    }
    var bn = Array.isArray;
    function Vt(e) {
      return bn(e);
    }
    var Do;
    Do = !1;
    function du() {
      var e = ai();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Pc = ["value", "defaultValue"];
    function ah(e) {
      {
        xo("select", e);
        for (var n = 0; n < Pc.length; n++) {
          var l = Pc[n];
          if (e[l] != null) {
            var f = Vt(e[l]);
            e.multiple && !f ? c("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", l, du()) : !e.multiple && f && c("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", l, du());
          }
        }
      }
    }
    function Ha(e, n, l, f) {
      var h = e.options;
      if (n) {
        for (var y = l, k = {}, w = 0; w < y.length; w++)
          k["$" + y[w]] = !0;
        for (var _ = 0; _ < h.length; _++) {
          var L = k.hasOwnProperty("$" + h[_].value);
          h[_].selected !== L && (h[_].selected = L), L && f && (h[_].defaultSelected = !0);
        }
      } else {
        for (var A = Cr(oo(l)), W = null, $ = 0; $ < h.length; $++) {
          if (h[$].value === A) {
            h[$].selected = !0, f && (h[$].defaultSelected = !0);
            return;
          }
          W === null && !h[$].disabled && (W = h[$]);
        }
        W !== null && (W.selected = !0);
      }
    }
    function Dc(e, n) {
      return Pt({}, n, {
        value: void 0
      });
    }
    function Oc(e, n) {
      var l = e;
      ah(n), l._wrapperState = {
        wasMultiple: !!n.multiple
      }, n.value !== void 0 && n.defaultValue !== void 0 && !Do && (c("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Do = !0);
    }
    function oh(e, n) {
      var l = e;
      l.multiple = !!n.multiple;
      var f = n.value;
      f != null ? Ha(l, !!n.multiple, f, !1) : n.defaultValue != null && Ha(l, !!n.multiple, n.defaultValue, !0);
    }
    function Pb(e, n) {
      var l = e, f = l._wrapperState.wasMultiple;
      l._wrapperState.wasMultiple = !!n.multiple;
      var h = n.value;
      h != null ? Ha(l, !!n.multiple, h, !1) : f !== !!n.multiple && (n.defaultValue != null ? Ha(l, !!n.multiple, n.defaultValue, !0) : Ha(l, !!n.multiple, n.multiple ? [] : "", !1));
    }
    function Db(e, n) {
      var l = e, f = n.value;
      f != null && Ha(l, !!n.multiple, f, !1);
    }
    var sh = !1;
    function lh(e, n) {
      var l = e;
      if (n.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var f = Pt({}, n, {
        value: void 0,
        defaultValue: void 0,
        children: Cr(l._wrapperState.initialValue)
      });
      return f;
    }
    function Uv(e, n) {
      var l = e;
      xo("textarea", n), n.value !== void 0 && n.defaultValue !== void 0 && !sh && (c("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", ai() || "A component"), sh = !0);
      var f = n.value;
      if (f == null) {
        var h = n.children, y = n.defaultValue;
        if (h != null) {
          c("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (y != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Vt(h)) {
              if (h.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              h = h[0];
            }
            y = h;
          }
        }
        y == null && (y = ""), f = y;
      }
      l._wrapperState = {
        initialValue: oo(f)
      };
    }
    function Fv(e, n) {
      var l = e, f = oo(n.value), h = oo(n.defaultValue);
      if (f != null) {
        var y = Cr(f);
        y !== l.value && (l.value = y), n.defaultValue == null && l.defaultValue !== y && (l.defaultValue = y);
      }
      h != null && (l.defaultValue = Cr(h));
    }
    function jv(e, n) {
      var l = e, f = l.textContent;
      f === l._wrapperState.initialValue && f !== "" && f !== null && (l.value = f);
    }
    function uh(e, n) {
      Fv(e, n);
    }
    var Oo = "http://www.w3.org/1999/xhtml", Ob = "http://www.w3.org/1998/Math/MathML", ch = "http://www.w3.org/2000/svg";
    function qd(e) {
      switch (e) {
        case "svg":
          return ch;
        case "math":
          return Ob;
        default:
          return Oo;
      }
    }
    function dh(e, n) {
      return e == null || e === Oo ? qd(n) : e === ch && n === "foreignObject" ? Oo : e;
    }
    var Mb = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(n, l, f, h) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(n, l, f, h);
        });
      } : e;
    }, Wd, zv = Mb(function(e, n) {
      if (e.namespaceURI === ch && !("innerHTML" in e)) {
        Wd = Wd || document.createElement("div"), Wd.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>";
        for (var l = Wd.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; l.firstChild; )
          e.appendChild(l.firstChild);
        return;
      }
      e.innerHTML = n;
    }), Ri = 1, Mo = 3, nr = 8, $a = 9, cl = 11, Gd = function(e, n) {
      if (n) {
        var l = e.firstChild;
        if (l && l === e.lastChild && l.nodeType === Mo) {
          l.nodeValue = n;
          return;
        }
      }
      e.textContent = n;
    }, Vv = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, fu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Bv(e, n) {
      return e + n.charAt(0).toUpperCase() + n.substring(1);
    }
    var Hv = ["Webkit", "ms", "Moz", "O"];
    Object.keys(fu).forEach(function(e) {
      Hv.forEach(function(n) {
        fu[Bv(n, e)] = fu[e];
      });
    });
    function Yd(e, n, l) {
      var f = n == null || typeof n == "boolean" || n === "";
      return f ? "" : !l && typeof n == "number" && n !== 0 && !(fu.hasOwnProperty(e) && fu[e]) ? n + "px" : (Br(n, e), ("" + n).trim());
    }
    var pu = /([A-Z])/g, Nb = /^ms-/;
    function Lb(e) {
      return e.replace(pu, "-$1").toLowerCase().replace(Nb, "-ms-");
    }
    var $v = function() {
    };
    {
      var qv = /^(?:webkit|moz|o)[A-Z]/, Wv = /^-ms-/, Mc = /-(.)/g, hu = /;\s*$/, mu = {}, vu = {}, Gv = !1, fh = !1, ph = function(e) {
        return e.replace(Mc, function(n, l) {
          return l.toUpperCase();
        });
      }, hh = function(e) {
        mu.hasOwnProperty(e) && mu[e] || (mu[e] = !0, c(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          ph(e.replace(Wv, "ms-"))
        ));
      }, Yv = function(e) {
        mu.hasOwnProperty(e) && mu[e] || (mu[e] = !0, c("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, Kv = function(e, n) {
        vu.hasOwnProperty(n) && vu[n] || (vu[n] = !0, c(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, n.replace(hu, "")));
      }, Qv = function(e, n) {
        Gv || (Gv = !0, c("`NaN` is an invalid value for the `%s` css style property.", e));
      }, Ab = function(e, n) {
        fh || (fh = !0, c("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      $v = function(e, n) {
        e.indexOf("-") > -1 ? hh(e) : qv.test(e) ? Yv(e) : hu.test(n) && Kv(e, n), typeof n == "number" && (isNaN(n) ? Qv(e, n) : isFinite(n) || Ab(e, n));
      };
    }
    var Ib = $v;
    function Ub(e) {
      {
        var n = "", l = "";
        for (var f in e)
          if (e.hasOwnProperty(f)) {
            var h = e[f];
            if (h != null) {
              var y = f.indexOf("--") === 0;
              n += l + (y ? f : Lb(f)) + ":", n += Yd(f, h, y), l = ";";
            }
          }
        return n || null;
      }
    }
    function Jv(e, n) {
      var l = e.style;
      for (var f in n)
        if (n.hasOwnProperty(f)) {
          var h = f.indexOf("--") === 0;
          h || Ib(f, n[f]);
          var y = Yd(f, n[f], h);
          f === "float" && (f = "cssFloat"), h ? l.setProperty(f, y) : l[f] = y;
        }
    }
    function Fb(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function fa(e) {
      var n = {};
      for (var l in e)
        for (var f = Vv[l] || [l], h = 0; h < f.length; h++)
          n[f[h]] = l;
      return n;
    }
    function Nc(e, n) {
      {
        if (!n)
          return;
        var l = fa(e), f = fa(n), h = {};
        for (var y in l) {
          var k = l[y], w = f[y];
          if (w && k !== w) {
            var _ = k + "," + w;
            if (h[_])
              continue;
            h[_] = !0, c("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Fb(e[k]) ? "Removing" : "Updating", k, w);
          }
        }
      }
    }
    var Xv = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Zv = Pt({
      menuitem: !0
    }, Xv), eg = "__html";
    function Kd(e, n) {
      if (n) {
        if (Zv[e] && (n.children != null || n.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (n.dangerouslySetInnerHTML != null) {
          if (n.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof n.dangerouslySetInnerHTML != "object" || !(eg in n.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!n.suppressContentEditableWarning && n.contentEditable && n.children != null && c("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), n.style != null && typeof n.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function No(e, n) {
      if (e.indexOf("-") === -1)
        return typeof n.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Qd = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, tg = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, qa = {}, mh = new RegExp("^(aria)-[" + at + "]*$"), Lc = new RegExp("^(aria)[A-Z][" + at + "]*$");
    function vh(e, n) {
      {
        if (yr.call(qa, n) && qa[n])
          return !0;
        if (Lc.test(n)) {
          var l = "aria-" + n.slice(4).toLowerCase(), f = tg.hasOwnProperty(l) ? l : null;
          if (f == null)
            return c("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", n), qa[n] = !0, !0;
          if (n !== f)
            return c("Invalid ARIA attribute `%s`. Did you mean `%s`?", n, f), qa[n] = !0, !0;
        }
        if (mh.test(n)) {
          var h = n.toLowerCase(), y = tg.hasOwnProperty(h) ? h : null;
          if (y == null)
            return qa[n] = !0, !1;
          if (n !== y)
            return c("Unknown ARIA attribute `%s`. Did you mean `%s`?", n, y), qa[n] = !0, !0;
        }
      }
      return !0;
    }
    function ng(e, n) {
      {
        var l = [];
        for (var f in n) {
          var h = vh(e, f);
          h || l.push(f);
        }
        var y = l.map(function(k) {
          return "`" + k + "`";
        }).join(", ");
        l.length === 1 ? c("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", y, e) : l.length > 1 && c("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", y, e);
      }
    }
    function Jd(e, n) {
      No(e, n) || ng(e, n);
    }
    var dl = !1;
    function gh(e, n) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        n != null && n.value === null && !dl && (dl = !0, e === "select" && n.multiple ? c("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : c("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var yh = function() {
    };
    {
      var kr = {}, bh = /^on./, rg = /^on[^A-Z]/, ig = new RegExp("^(aria)-[" + at + "]*$"), ag = new RegExp("^(aria)[A-Z][" + at + "]*$");
      yh = function(e, n, l, f) {
        if (yr.call(kr, n) && kr[n])
          return !0;
        var h = n.toLowerCase();
        if (h === "onfocusin" || h === "onfocusout")
          return c("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), kr[n] = !0, !0;
        if (f != null) {
          var y = f.registrationNameDependencies, k = f.possibleRegistrationNames;
          if (y.hasOwnProperty(n))
            return !0;
          var w = k.hasOwnProperty(h) ? k[h] : null;
          if (w != null)
            return c("Invalid event handler property `%s`. Did you mean `%s`?", n, w), kr[n] = !0, !0;
          if (bh.test(n))
            return c("Unknown event handler property `%s`. It will be ignored.", n), kr[n] = !0, !0;
        } else if (bh.test(n))
          return rg.test(n) && c("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", n), kr[n] = !0, !0;
        if (ig.test(n) || ag.test(n))
          return !0;
        if (h === "innerhtml")
          return c("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), kr[n] = !0, !0;
        if (h === "aria")
          return c("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), kr[n] = !0, !0;
        if (h === "is" && l !== null && l !== void 0 && typeof l != "string")
          return c("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof l), kr[n] = !0, !0;
        if (typeof l == "number" && isNaN(l))
          return c("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", n), kr[n] = !0, !0;
        var _ = ei(n), L = _ !== null && _.type === qi;
        if (Qd.hasOwnProperty(h)) {
          var A = Qd[h];
          if (A !== n)
            return c("Invalid DOM property `%s`. Did you mean `%s`?", n, A), kr[n] = !0, !0;
        } else if (!L && n !== h)
          return c("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", n, h), kr[n] = !0, !0;
        return typeof l == "boolean" && $r(n, l, _, !1) ? (l ? c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', l, n, n, l, n) : c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', l, n, n, l, n, n, n), kr[n] = !0, !0) : L ? !0 : $r(n, l, _, !1) ? (kr[n] = !0, !1) : ((l === "false" || l === "true") && _ !== null && _.type === Ln && (c("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", l, n, l === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', n, l), kr[n] = !0), !0);
      };
    }
    var og = function(e, n, l) {
      {
        var f = [];
        for (var h in n) {
          var y = yh(e, h, n[h], l);
          y || f.push(h);
        }
        var k = f.map(function(w) {
          return "`" + w + "`";
        }).join(", ");
        f.length === 1 ? c("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", k, e) : f.length > 1 && c("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", k, e);
      }
    };
    function sg(e, n, l) {
      No(e, n) || og(e, n, l);
    }
    var Lo = 1, Ac = 2, fl = 4, jb = Lo | Ac | fl, Ic = null;
    function Uc(e) {
      Ic !== null && c("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Ic = e;
    }
    function zb() {
      Ic === null && c("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Ic = null;
    }
    function lg(e) {
      return e === Ic;
    }
    function Xd(e) {
      var n = e.target || e.srcElement || window;
      return n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === Mo ? n.parentNode : n;
    }
    var gn = null, _s = null, Ao = null;
    function gu(e) {
      var n = Qu(e);
      if (n) {
        if (typeof gn != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var l = n.stateNode;
        if (l) {
          var f = fy(l);
          gn(n.stateNode, n.type, f);
        }
      }
    }
    function ug(e) {
      gn = e;
    }
    function Zd(e) {
      _s ? Ao ? Ao.push(e) : Ao = [e] : _s = e;
    }
    function Fc() {
      return _s !== null || Ao !== null;
    }
    function jc() {
      if (_s) {
        var e = _s, n = Ao;
        if (_s = null, Ao = null, gu(e), n)
          for (var l = 0; l < n.length; l++)
            gu(n[l]);
      }
    }
    var pl = function(e, n) {
      return e(n);
    }, Sh = function() {
    }, Ch = !1;
    function Vb() {
      var e = Fc();
      e && (Sh(), jc());
    }
    function kh(e, n, l) {
      if (Ch)
        return e(n, l);
      Ch = !0;
      try {
        return pl(e, n, l);
      } finally {
        Ch = !1, Vb();
      }
    }
    function ef(e, n, l) {
      pl = e, Sh = l;
    }
    function tf(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function Th(e, n, l) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(l.disabled && tf(n));
        default:
          return !1;
      }
    }
    function hl(e, n) {
      var l = e.stateNode;
      if (l === null)
        return null;
      var f = fy(l);
      if (f === null)
        return null;
      var h = f[n];
      if (Th(n, e.type, f))
        return null;
      if (h && typeof h != "function")
        throw new Error("Expected `" + n + "` listener to be a function, instead got a value of `" + typeof h + "` type.");
      return h;
    }
    var zc = !1;
    if (Nn)
      try {
        var ml = {};
        Object.defineProperty(ml, "passive", {
          get: function() {
            zc = !0;
          }
        }), window.addEventListener("test", ml, ml), window.removeEventListener("test", ml, ml);
      } catch {
        zc = !1;
      }
    function cg(e, n, l, f, h, y, k, w, _) {
      var L = Array.prototype.slice.call(arguments, 3);
      try {
        n.apply(l, L);
      } catch (A) {
        this.onError(A);
      }
    }
    var Eh = cg;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var wh = document.createElement("react");
      Eh = function(n, l, f, h, y, k, w, _, L) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var A = document.createEvent("Event"), W = !1, $ = !0, re = window.event, le = Object.getOwnPropertyDescriptor(window, "event");
        function me() {
          wh.removeEventListener(ve, ut, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = re);
        }
        var ze = Array.prototype.slice.call(arguments, 3);
        function ut() {
          W = !0, me(), l.apply(f, ze), $ = !1;
        }
        var it, qt = !1, Ut = !1;
        function J(X) {
          if (it = X.error, qt = !0, it === null && X.colno === 0 && X.lineno === 0 && (Ut = !0), X.defaultPrevented && it != null && typeof it == "object")
            try {
              it._suppressLogging = !0;
            } catch {
            }
        }
        var ve = "react-" + (n || "invokeguardedcallback");
        if (window.addEventListener("error", J), wh.addEventListener(ve, ut, !1), A.initEvent(ve, !1, !1), wh.dispatchEvent(A), le && Object.defineProperty(window, "event", le), W && $ && (qt ? Ut && (it = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : it = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(it)), window.removeEventListener("error", J), !W)
          return me(), cg.apply(this, arguments);
      };
    }
    var Bb = Eh, xs = !1, Wa = null, Vc = !1, Ps = null, so = {
      onError: function(e) {
        xs = !0, Wa = e;
      }
    };
    function vl(e, n, l, f, h, y, k, w, _) {
      xs = !1, Wa = null, Bb.apply(so, arguments);
    }
    function Io(e, n, l, f, h, y, k, w, _) {
      if (vl.apply(this, arguments), xs) {
        var L = _h();
        Vc || (Vc = !0, Ps = L);
      }
    }
    function Rh() {
      if (Vc) {
        var e = Ps;
        throw Vc = !1, Ps = null, e;
      }
    }
    function Hb() {
      return xs;
    }
    function _h() {
      if (xs) {
        var e = Wa;
        return xs = !1, Wa = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pa(e) {
      return e._reactInternals;
    }
    function Bc(e) {
      return e._reactInternals !== void 0;
    }
    function yu(e, n) {
      e._reactInternals = n;
    }
    var st = (
      /*                      */
      0
    ), Ds = (
      /*                */
      1
    ), Tn = (
      /*                    */
      2
    ), wt = (
      /*                       */
      4
    ), tn = (
      /*                */
      16
    ), ln = (
      /*                 */
      32
    ), lo = (
      /*                     */
      64
    ), gt = (
      /*                   */
      128
    ), Bn = (
      /*            */
      256
    ), _i = (
      /*                          */
      512
    ), ha = (
      /*                     */
      1024
    ), Pn = (
      /*                      */
      2048
    ), ma = (
      /*                    */
      4096
    ), Os = (
      /*                   */
      8192
    ), Hc = (
      /*             */
      16384
    ), nf = Pn | wt | lo | _i | ha | Hc, dg = (
      /*               */
      32767
    ), Qi = (
      /*                   */
      32768
    ), Tr = (
      /*                */
      65536
    ), $c = (
      /* */
      131072
    ), xh = (
      /*                       */
      1048576
    ), Ph = (
      /*                    */
      2097152
    ), xi = (
      /*                 */
      4194304
    ), Ms = (
      /*                */
      8388608
    ), Pi = (
      /*               */
      16777216
    ), gl = (
      /*              */
      33554432
    ), bu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      wt | ha | 0
    ), Di = Tn | wt | tn | ln | _i | ma | Os, Wr = wt | lo | _i | Os, va = Pn | tn, Pr = xi | Ms | Ph, Uo = i.ReactCurrentOwner;
    function Ji(e) {
      var n = e, l = e;
      if (e.alternate)
        for (; n.return; )
          n = n.return;
      else {
        var f = n;
        do
          n = f, (n.flags & (Tn | ma)) !== st && (l = n.return), f = n.return;
        while (f);
      }
      return n.tag === E ? l : null;
    }
    function Dh(e) {
      if (e.tag === F) {
        var n = e.memoizedState;
        if (n === null) {
          var l = e.alternate;
          l !== null && (n = l.memoizedState);
        }
        if (n !== null)
          return n.dehydrated;
      }
      return null;
    }
    function rf(e) {
      return e.tag === E ? e.stateNode.containerInfo : null;
    }
    function Oh(e) {
      return Ji(e) === e;
    }
    function Xi(e) {
      {
        var n = Uo.current;
        if (n !== null && n.tag === b) {
          var l = n, f = l.stateNode;
          f._warnedAboutRefsInRender || c("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", bt(l) || "A component"), f._warnedAboutRefsInRender = !0;
        }
      }
      var h = pa(e);
      return h ? Ji(h) === h : !1;
    }
    function Oi(e) {
      if (Ji(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function En(e) {
      var n = e.alternate;
      if (!n) {
        var l = Ji(e);
        if (l === null)
          throw new Error("Unable to find node on an unmounted component.");
        return l !== e ? null : e;
      }
      for (var f = e, h = n; ; ) {
        var y = f.return;
        if (y === null)
          break;
        var k = y.alternate;
        if (k === null) {
          var w = y.return;
          if (w !== null) {
            f = h = w;
            continue;
          }
          break;
        }
        if (y.child === k.child) {
          for (var _ = y.child; _; ) {
            if (_ === f)
              return Oi(y), e;
            if (_ === h)
              return Oi(y), n;
            _ = _.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (f.return !== h.return)
          f = y, h = k;
        else {
          for (var L = !1, A = y.child; A; ) {
            if (A === f) {
              L = !0, f = y, h = k;
              break;
            }
            if (A === h) {
              L = !0, h = y, f = k;
              break;
            }
            A = A.sibling;
          }
          if (!L) {
            for (A = k.child; A; ) {
              if (A === f) {
                L = !0, f = k, h = y;
                break;
              }
              if (A === h) {
                L = !0, h = k, f = y;
                break;
              }
              A = A.sibling;
            }
            if (!L)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (f.alternate !== h)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (f.tag !== E)
        throw new Error("Unable to find node on an unmounted component.");
      return f.stateNode.current === f ? e : n;
    }
    function ga(e) {
      var n = En(e);
      return n !== null ? Mh(n) : null;
    }
    function Mh(e) {
      if (e.tag === O || e.tag === N)
        return e;
      for (var n = e.child; n !== null; ) {
        var l = Mh(n);
        if (l !== null)
          return l;
        n = n.sibling;
      }
      return null;
    }
    function fg(e) {
      var n = En(e);
      return n !== null ? af(n) : null;
    }
    function af(e) {
      if (e.tag === O || e.tag === N)
        return e;
      for (var n = e.child; n !== null; ) {
        if (n.tag !== x) {
          var l = af(n);
          if (l !== null)
            return l;
        }
        n = n.sibling;
      }
      return null;
    }
    var of = t.unstable_scheduleCallback, pg = t.unstable_cancelCallback, sf = t.unstable_shouldYield, hg = t.unstable_requestPaint, Un = t.unstable_now, Nh = t.unstable_getCurrentPriorityLevel, lf = t.unstable_ImmediatePriority, yl = t.unstable_UserBlockingPriority, uo = t.unstable_NormalPriority, mg = t.unstable_LowPriority, uf = t.unstable_IdlePriority, Su = t.unstable_yieldValue, vg = t.unstable_setDisableYieldValue, Fo = null, cr = null, Ue = null, ya = !1, Zi = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Lh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var n = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (n.isDisabled)
        return !0;
      if (!n.supportsFiber)
        return c("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        kt && (e = Pt({}, e, {
          getLaneLabelMap: jo,
          injectProfilingHooks: gg
        })), Fo = n.inject(e), cr = n;
      } catch (l) {
        c("React instrumentation encountered an error: %s.", l);
      }
      return !!n.checkDCE;
    }
    function Ah(e, n) {
      if (cr && typeof cr.onScheduleFiberRoot == "function")
        try {
          cr.onScheduleFiberRoot(Fo, e, n);
        } catch (l) {
          ya || (ya = !0, c("React instrumentation encountered an error: %s", l));
        }
    }
    function Cu(e, n) {
      if (cr && typeof cr.onCommitFiberRoot == "function")
        try {
          var l = (e.current.flags & gt) === gt;
          if (Rt) {
            var f;
            switch (n) {
              case Jn:
                f = lf;
                break;
              case Vo:
                f = yl;
                break;
              case co:
                f = uo;
                break;
              case Nu:
                f = uf;
                break;
              default:
                f = uo;
                break;
            }
            cr.onCommitFiberRoot(Fo, e, f, l);
          }
        } catch (h) {
          ya || (ya = !0, c("React instrumentation encountered an error: %s", h));
        }
    }
    function ba(e) {
      if (cr && typeof cr.onPostCommitFiberRoot == "function")
        try {
          cr.onPostCommitFiberRoot(Fo, e);
        } catch (n) {
          ya || (ya = !0, c("React instrumentation encountered an error: %s", n));
        }
    }
    function bl(e) {
      if (cr && typeof cr.onCommitFiberUnmount == "function")
        try {
          cr.onCommitFiberUnmount(Fo, e);
        } catch (n) {
          ya || (ya = !0, c("React instrumentation encountered an error: %s", n));
        }
    }
    function rr(e) {
      if (typeof Su == "function" && (vg(e), u(e)), cr && typeof cr.setStrictMode == "function")
        try {
          cr.setStrictMode(Fo, e);
        } catch (n) {
          ya || (ya = !0, c("React instrumentation encountered an error: %s", n));
        }
    }
    function gg(e) {
      Ue = e;
    }
    function jo() {
      {
        for (var e = /* @__PURE__ */ new Map(), n = 1, l = 0; l < Kc; l++) {
          var f = qb(n);
          e.set(n, f), n *= 2;
        }
        return e;
      }
    }
    function Ns(e) {
      Ue !== null && typeof Ue.markCommitStarted == "function" && Ue.markCommitStarted(e);
    }
    function cf() {
      Ue !== null && typeof Ue.markCommitStopped == "function" && Ue.markCommitStopped();
    }
    function ku(e) {
      Ue !== null && typeof Ue.markComponentRenderStarted == "function" && Ue.markComponentRenderStarted(e);
    }
    function Mi() {
      Ue !== null && typeof Ue.markComponentRenderStopped == "function" && Ue.markComponentRenderStopped();
    }
    function Ls(e) {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStarted == "function" && Ue.markComponentPassiveEffectMountStarted(e);
    }
    function df() {
      Ue !== null && typeof Ue.markComponentPassiveEffectMountStopped == "function" && Ue.markComponentPassiveEffectMountStopped();
    }
    function yg(e) {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStarted == "function" && Ue.markComponentPassiveEffectUnmountStarted(e);
    }
    function ff() {
      Ue !== null && typeof Ue.markComponentPassiveEffectUnmountStopped == "function" && Ue.markComponentPassiveEffectUnmountStopped();
    }
    function bg(e) {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStarted == "function" && Ue.markComponentLayoutEffectMountStarted(e);
    }
    function qc() {
      Ue !== null && typeof Ue.markComponentLayoutEffectMountStopped == "function" && Ue.markComponentLayoutEffectMountStopped();
    }
    function Ga(e) {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStarted == "function" && Ue.markComponentLayoutEffectUnmountStarted(e);
    }
    function Tu() {
      Ue !== null && typeof Ue.markComponentLayoutEffectUnmountStopped == "function" && Ue.markComponentLayoutEffectUnmountStopped();
    }
    function Wc(e, n, l) {
      Ue !== null && typeof Ue.markComponentErrored == "function" && Ue.markComponentErrored(e, n, l);
    }
    function Sl(e, n, l) {
      Ue !== null && typeof Ue.markComponentSuspended == "function" && Ue.markComponentSuspended(e, n, l);
    }
    function Ih(e) {
      Ue !== null && typeof Ue.markLayoutEffectsStarted == "function" && Ue.markLayoutEffectsStarted(e);
    }
    function Eu() {
      Ue !== null && typeof Ue.markLayoutEffectsStopped == "function" && Ue.markLayoutEffectsStopped();
    }
    function Sg(e) {
      Ue !== null && typeof Ue.markPassiveEffectsStarted == "function" && Ue.markPassiveEffectsStarted(e);
    }
    function Uh() {
      Ue !== null && typeof Ue.markPassiveEffectsStopped == "function" && Ue.markPassiveEffectsStopped();
    }
    function Dn(e) {
      Ue !== null && typeof Ue.markRenderStarted == "function" && Ue.markRenderStarted(e);
    }
    function pf() {
      Ue !== null && typeof Ue.markRenderYielded == "function" && Ue.markRenderYielded();
    }
    function hf() {
      Ue !== null && typeof Ue.markRenderStopped == "function" && Ue.markRenderStopped();
    }
    function Fh(e) {
      Ue !== null && typeof Ue.markRenderScheduled == "function" && Ue.markRenderScheduled(e);
    }
    function mf(e, n) {
      Ue !== null && typeof Ue.markForceUpdateScheduled == "function" && Ue.markForceUpdateScheduled(e, n);
    }
    function Gc(e, n) {
      Ue !== null && typeof Ue.markStateUpdateScheduled == "function" && Ue.markStateUpdateScheduled(e, n);
    }
    var et = (
      /*                         */
      0
    ), rt = (
      /*                 */
      1
    ), yt = (
      /*                    */
      2
    ), At = (
      /*               */
      8
    ), ea = (
      /*              */
      16
    ), wu = Math.clz32 ? Math.clz32 : Gr, Yc = Math.log, $b = Math.LN2;
    function Gr(e) {
      var n = e >>> 0;
      return n === 0 ? 32 : 31 - (Yc(n) / $b | 0) | 0;
    }
    var Kc = 31, Se = (
      /*                        */
      0
    ), ir = (
      /*                          */
      0
    ), ot = (
      /*                        */
      1
    ), Dr = (
      /*    */
      2
    ), ta = (
      /*             */
      4
    ), zo = (
      /*            */
      8
    ), Sa = (
      /*                     */
      16
    ), Ru = (
      /*                */
      32
    ), Cl = (
      /*                       */
      4194240
    ), _u = (
      /*                        */
      64
    ), vf = (
      /*                        */
      128
    ), gf = (
      /*                        */
      256
    ), yf = (
      /*                        */
      512
    ), bf = (
      /*                        */
      1024
    ), Sf = (
      /*                        */
      2048
    ), kl = (
      /*                        */
      4096
    ), Cf = (
      /*                        */
      8192
    ), xu = (
      /*                        */
      16384
    ), Pu = (
      /*                       */
      32768
    ), kf = (
      /*                       */
      65536
    ), Qc = (
      /*                       */
      131072
    ), Tf = (
      /*                       */
      262144
    ), Ef = (
      /*                       */
      524288
    ), wf = (
      /*                       */
      1048576
    ), Rf = (
      /*                       */
      2097152
    ), Du = (
      /*                            */
      130023424
    ), Tl = (
      /*                             */
      4194304
    ), _f = (
      /*                             */
      8388608
    ), xf = (
      /*                             */
      16777216
    ), jh = (
      /*                             */
      33554432
    ), Pf = (
      /*                             */
      67108864
    ), Cg = Tl, Jc = (
      /*          */
      134217728
    ), zh = (
      /*                          */
      268435455
    ), Ou = (
      /*               */
      268435456
    ), As = (
      /*                        */
      536870912
    ), Yr = (
      /*                   */
      1073741824
    );
    function qb(e) {
      {
        if (e & ot)
          return "Sync";
        if (e & Dr)
          return "InputContinuousHydration";
        if (e & ta)
          return "InputContinuous";
        if (e & zo)
          return "DefaultHydration";
        if (e & Sa)
          return "Default";
        if (e & Ru)
          return "TransitionHydration";
        if (e & Cl)
          return "Transition";
        if (e & Du)
          return "Retry";
        if (e & Jc)
          return "SelectiveHydration";
        if (e & Ou)
          return "IdleHydration";
        if (e & As)
          return "Idle";
        if (e & Yr)
          return "Offscreen";
      }
    }
    var Sn = -1, Df = _u, Ni = Tl;
    function El(e) {
      switch (Qn(e)) {
        case ot:
          return ot;
        case Dr:
          return Dr;
        case ta:
          return ta;
        case zo:
          return zo;
        case Sa:
          return Sa;
        case Ru:
          return Ru;
        case _u:
        case vf:
        case gf:
        case yf:
        case bf:
        case Sf:
        case kl:
        case Cf:
        case xu:
        case Pu:
        case kf:
        case Qc:
        case Tf:
        case Ef:
        case wf:
        case Rf:
          return e & Cl;
        case Tl:
        case _f:
        case xf:
        case jh:
        case Pf:
          return e & Du;
        case Jc:
          return Jc;
        case Ou:
          return Ou;
        case As:
          return As;
        case Yr:
          return Yr;
        default:
          return c("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function wl(e, n) {
      var l = e.pendingLanes;
      if (l === Se)
        return Se;
      var f = Se, h = e.suspendedLanes, y = e.pingedLanes, k = l & zh;
      if (k !== Se) {
        var w = k & ~h;
        if (w !== Se)
          f = El(w);
        else {
          var _ = k & y;
          _ !== Se && (f = El(_));
        }
      } else {
        var L = l & ~h;
        L !== Se ? f = El(L) : y !== Se && (f = El(y));
      }
      if (f === Se)
        return Se;
      if (n !== Se && n !== f && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (n & h) === Se) {
        var A = Qn(f), W = Qn(n);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          A >= W || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          A === Sa && (W & Cl) !== Se
        )
          return n;
      }
      (f & ta) !== Se && (f |= l & Sa);
      var $ = e.entangledLanes;
      if ($ !== Se)
        for (var re = e.entanglements, le = f & $; le > 0; ) {
          var me = Us(le), ze = 1 << me;
          f |= re[me], le &= ~ze;
        }
      return f;
    }
    function kg(e, n) {
      for (var l = e.eventTimes, f = Sn; n > 0; ) {
        var h = Us(n), y = 1 << h, k = l[h];
        k > f && (f = k), n &= ~y;
      }
      return f;
    }
    function Tg(e, n) {
      switch (e) {
        case ot:
        case Dr:
        case ta:
          return n + 250;
        case zo:
        case Sa:
        case Ru:
        case _u:
        case vf:
        case gf:
        case yf:
        case bf:
        case Sf:
        case kl:
        case Cf:
        case xu:
        case Pu:
        case kf:
        case Qc:
        case Tf:
        case Ef:
        case wf:
        case Rf:
          return n + 5e3;
        case Tl:
        case _f:
        case xf:
        case jh:
        case Pf:
          return Sn;
        case Jc:
        case Ou:
        case As:
        case Yr:
          return Sn;
        default:
          return c("Should have found matching lanes. This is a bug in React."), Sn;
      }
    }
    function Eg(e, n) {
      for (var l = e.pendingLanes, f = e.suspendedLanes, h = e.pingedLanes, y = e.expirationTimes, k = l; k > 0; ) {
        var w = Us(k), _ = 1 << w, L = y[w];
        L === Sn ? ((_ & f) === Se || (_ & h) !== Se) && (y[w] = Tg(_, n)) : L <= n && (e.expiredLanes |= _), k &= ~_;
      }
    }
    function Vh(e) {
      return El(e.pendingLanes);
    }
    function Is(e) {
      var n = e.pendingLanes & ~Yr;
      return n !== Se ? n : n & Yr ? Yr : Se;
    }
    function Bh(e) {
      return (e & ot) !== Se;
    }
    function Xc(e) {
      return (e & zh) !== Se;
    }
    function wg(e) {
      return (e & Du) === e;
    }
    function Rg(e) {
      var n = ot | ta | Sa;
      return (e & n) === Se;
    }
    function _g(e) {
      return (e & Cl) === e;
    }
    function Zc(e, n) {
      var l = Dr | ta | zo | Sa;
      return (n & l) !== Se;
    }
    function xg(e, n) {
      return (n & e.expiredLanes) !== Se;
    }
    function Hh(e) {
      return (e & Cl) !== Se;
    }
    function Pg() {
      var e = Df;
      return Df <<= 1, (Df & Cl) === Se && (Df = _u), e;
    }
    function Li() {
      var e = Ni;
      return Ni <<= 1, (Ni & Du) === Se && (Ni = Tl), e;
    }
    function Qn(e) {
      return e & -e;
    }
    function Mu(e) {
      return Qn(e);
    }
    function Us(e) {
      return 31 - wu(e);
    }
    function Of(e) {
      return Us(e);
    }
    function Ai(e, n) {
      return (e & n) !== Se;
    }
    function Rl(e, n) {
      return (e & n) === n;
    }
    function Et(e, n) {
      return e | n;
    }
    function ed(e, n) {
      return e & ~n;
    }
    function Mf(e, n) {
      return e & n;
    }
    function Wb(e) {
      return e;
    }
    function Dg(e, n) {
      return e !== ir && e < n ? e : n;
    }
    function td(e) {
      for (var n = [], l = 0; l < Kc; l++)
        n.push(e);
      return n;
    }
    function _l(e, n, l) {
      e.pendingLanes |= n, n !== As && (e.suspendedLanes = Se, e.pingedLanes = Se);
      var f = e.eventTimes, h = Of(n);
      f[h] = l;
    }
    function Og(e, n) {
      e.suspendedLanes |= n, e.pingedLanes &= ~n;
      for (var l = e.expirationTimes, f = n; f > 0; ) {
        var h = Us(f), y = 1 << h;
        l[h] = Sn, f &= ~y;
      }
    }
    function Nf(e, n, l) {
      e.pingedLanes |= e.suspendedLanes & n;
    }
    function Lf(e, n) {
      var l = e.pendingLanes & ~n;
      e.pendingLanes = n, e.suspendedLanes = Se, e.pingedLanes = Se, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n;
      for (var f = e.entanglements, h = e.eventTimes, y = e.expirationTimes, k = l; k > 0; ) {
        var w = Us(k), _ = 1 << w;
        f[w] = Se, h[w] = Sn, y[w] = Sn, k &= ~_;
      }
    }
    function $h(e, n) {
      for (var l = e.entangledLanes |= n, f = e.entanglements, h = l; h; ) {
        var y = Us(h), k = 1 << y;
        // Is this one of the newly entangled lanes?
        k & n | // Is this lane transitively entangled with the newly entangled lanes?
        f[y] & n && (f[y] |= n), h &= ~k;
      }
    }
    function Mg(e, n) {
      var l = Qn(n), f;
      switch (l) {
        case ta:
          f = Dr;
          break;
        case Sa:
          f = zo;
          break;
        case _u:
        case vf:
        case gf:
        case yf:
        case bf:
        case Sf:
        case kl:
        case Cf:
        case xu:
        case Pu:
        case kf:
        case Qc:
        case Tf:
        case Ef:
        case wf:
        case Rf:
        case Tl:
        case _f:
        case xf:
        case jh:
        case Pf:
          f = Ru;
          break;
        case As:
          f = Ou;
          break;
        default:
          f = ir;
          break;
      }
      return (f & (e.suspendedLanes | n)) !== ir ? ir : f;
    }
    function Af(e, n, l) {
      if (Zi)
        for (var f = e.pendingUpdatersLaneMap; l > 0; ) {
          var h = Of(l), y = 1 << h, k = f[h];
          k.add(n), l &= ~y;
        }
    }
    function qh(e, n) {
      if (Zi)
        for (var l = e.pendingUpdatersLaneMap, f = e.memoizedUpdaters; n > 0; ) {
          var h = Of(n), y = 1 << h, k = l[h];
          k.size > 0 && (k.forEach(function(w) {
            var _ = w.alternate;
            (_ === null || !f.has(_)) && f.add(w);
          }), k.clear()), n &= ~y;
        }
    }
    function nd(e, n) {
      return null;
    }
    var Jn = ot, Vo = ta, co = Sa, Nu = As, Lu = ir;
    function Ca() {
      return Lu;
    }
    function Hn(e) {
      Lu = e;
    }
    function Kr(e, n) {
      var l = Lu;
      try {
        return Lu = e, n();
      } finally {
        Lu = l;
      }
    }
    function Gb(e, n) {
      return e !== 0 && e < n ? e : n;
    }
    function Yb(e, n) {
      return e === 0 || e > n ? e : n;
    }
    function Au(e, n) {
      return e !== 0 && e < n;
    }
    function Or(e) {
      var n = Qn(e);
      return Au(Jn, n) ? Au(Vo, n) ? Xc(n) ? co : Nu : Vo : Jn;
    }
    function If(e) {
      var n = e.current.memoizedState;
      return n.isDehydrated;
    }
    var Ge;
    function Iu(e) {
      Ge = e;
    }
    function Wh(e) {
      Ge(e);
    }
    var Uf;
    function Kb(e) {
      Uf = e;
    }
    var Uu;
    function Ff(e) {
      Uu = e;
    }
    var jf;
    function Ng(e) {
      jf = e;
    }
    var Gh;
    function Lg(e) {
      Gh = e;
    }
    var rd = !1, Fu = [], On = null, Er = null, oi = null, ju = /* @__PURE__ */ new Map(), zu = /* @__PURE__ */ new Map(), wr = [], Ag = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function fo(e) {
      return Ag.indexOf(e) > -1;
    }
    function Qb(e, n, l, f, h) {
      return {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: l,
        nativeEvent: h,
        targetContainers: [f]
      };
    }
    function Yh(e, n) {
      switch (e) {
        case "focusin":
        case "focusout":
          On = null;
          break;
        case "dragenter":
        case "dragleave":
          Er = null;
          break;
        case "mouseover":
        case "mouseout":
          oi = null;
          break;
        case "pointerover":
        case "pointerout": {
          var l = n.pointerId;
          ju.delete(l);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var f = n.pointerId;
          zu.delete(f);
          break;
        }
      }
    }
    function Vu(e, n, l, f, h, y) {
      if (e === null || e.nativeEvent !== y) {
        var k = Qb(n, l, f, h, y);
        if (n !== null) {
          var w = Qu(n);
          w !== null && Uf(w);
        }
        return k;
      }
      e.eventSystemFlags |= f;
      var _ = e.targetContainers;
      return h !== null && _.indexOf(h) === -1 && _.push(h), e;
    }
    function Ig(e, n, l, f, h) {
      switch (n) {
        case "focusin": {
          var y = h;
          return On = Vu(On, e, n, l, f, y), !0;
        }
        case "dragenter": {
          var k = h;
          return Er = Vu(Er, e, n, l, f, k), !0;
        }
        case "mouseover": {
          var w = h;
          return oi = Vu(oi, e, n, l, f, w), !0;
        }
        case "pointerover": {
          var _ = h, L = _.pointerId;
          return ju.set(L, Vu(ju.get(L) || null, e, n, l, f, _)), !0;
        }
        case "gotpointercapture": {
          var A = h, W = A.pointerId;
          return zu.set(W, Vu(zu.get(W) || null, e, n, l, f, A)), !0;
        }
      }
      return !1;
    }
    function Kh(e) {
      var n = md(e.target);
      if (n !== null) {
        var l = Ji(n);
        if (l !== null) {
          var f = l.tag;
          if (f === F) {
            var h = Dh(l);
            if (h !== null) {
              e.blockedOn = h, Gh(e.priority, function() {
                Uu(l);
              });
              return;
            }
          } else if (f === E) {
            var y = l.stateNode;
            if (If(y)) {
              e.blockedOn = rf(l);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Jb(e) {
      for (var n = jf(), l = {
        blockedOn: null,
        target: e,
        priority: n
      }, f = 0; f < wr.length && Au(n, wr[f].priority); f++)
        ;
      wr.splice(f, 0, l), f === 0 && Kh(l);
    }
    function xl(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var n = e.targetContainers; n.length > 0; ) {
        var l = n[0], f = Qr(e.domEventName, e.eventSystemFlags, l, e.nativeEvent);
        if (f === null) {
          var h = e.nativeEvent, y = new h.constructor(h.type, h);
          Uc(y), h.target.dispatchEvent(y), zb();
        } else {
          var k = Qu(f);
          return k !== null && Uf(k), e.blockedOn = f, !1;
        }
        n.shift();
      }
      return !0;
    }
    function zf(e, n, l) {
      xl(e) && l.delete(n);
    }
    function ka() {
      rd = !1, On !== null && xl(On) && (On = null), Er !== null && xl(Er) && (Er = null), oi !== null && xl(oi) && (oi = null), ju.forEach(zf), zu.forEach(zf);
    }
    function It(e, n) {
      e.blockedOn === n && (e.blockedOn = null, rd || (rd = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, ka)));
    }
    function $n(e) {
      if (Fu.length > 0) {
        It(Fu[0], e);
        for (var n = 1; n < Fu.length; n++) {
          var l = Fu[n];
          l.blockedOn === e && (l.blockedOn = null);
        }
      }
      On !== null && It(On, e), Er !== null && It(Er, e), oi !== null && It(oi, e);
      var f = function(w) {
        return It(w, e);
      };
      ju.forEach(f), zu.forEach(f);
      for (var h = 0; h < wr.length; h++) {
        var y = wr[h];
        y.blockedOn === e && (y.blockedOn = null);
      }
      for (; wr.length > 0; ) {
        var k = wr[0];
        if (k.blockedOn !== null)
          break;
        Kh(k), k.blockedOn === null && wr.shift();
      }
    }
    var wn = i.ReactCurrentBatchConfig, dr = !0;
    function Ii(e) {
      dr = !!e;
    }
    function Bu() {
      return dr;
    }
    function fr(e, n, l) {
      var f = Vf(n), h;
      switch (f) {
        case Jn:
          h = id;
          break;
        case Vo:
          h = Pl;
          break;
        case co:
        default:
          h = Hu;
          break;
      }
      return h.bind(null, n, l, e);
    }
    function id(e, n, l, f) {
      var h = Ca(), y = wn.transition;
      wn.transition = null;
      try {
        Hn(Jn), Hu(e, n, l, f);
      } finally {
        Hn(h), wn.transition = y;
      }
    }
    function Pl(e, n, l, f) {
      var h = Ca(), y = wn.transition;
      wn.transition = null;
      try {
        Hn(Vo), Hu(e, n, l, f);
      } finally {
        Hn(h), wn.transition = y;
      }
    }
    function Hu(e, n, l, f) {
      dr && Qh(e, n, l, f);
    }
    function Qh(e, n, l, f) {
      var h = Qr(e, n, l, f);
      if (h === null) {
        hS(e, n, f, Fs, l), Yh(e, f);
        return;
      }
      if (Ig(h, e, n, l, f)) {
        f.stopPropagation();
        return;
      }
      if (Yh(e, f), n & fl && fo(e)) {
        for (; h !== null; ) {
          var y = Qu(h);
          y !== null && Wh(y);
          var k = Qr(e, n, l, f);
          if (k === null && hS(e, n, f, Fs, l), k === h)
            break;
          h = k;
        }
        h !== null && f.stopPropagation();
        return;
      }
      hS(e, n, f, null, l);
    }
    var Fs = null;
    function Qr(e, n, l, f) {
      Fs = null;
      var h = Xd(f), y = md(h);
      if (y !== null) {
        var k = Ji(y);
        if (k === null)
          y = null;
        else {
          var w = k.tag;
          if (w === F) {
            var _ = Dh(k);
            if (_ !== null)
              return _;
            y = null;
          } else if (w === E) {
            var L = k.stateNode;
            if (If(L))
              return rf(k);
            y = null;
          } else
            k !== y && (y = null);
        }
      }
      return Fs = y, null;
    }
    function Vf(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Jn;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Vo;
        case "message": {
          var n = Nh();
          switch (n) {
            case lf:
              return Jn;
            case yl:
              return Vo;
            case uo:
            case mg:
              return co;
            case uf:
              return Nu;
            default:
              return co;
          }
        }
        default:
          return co;
      }
    }
    function $u(e, n, l) {
      return e.addEventListener(n, l, !1), l;
    }
    function Bo(e, n, l) {
      return e.addEventListener(n, l, !0), l;
    }
    function Bf(e, n, l, f) {
      return e.addEventListener(n, l, {
        capture: !0,
        passive: f
      }), l;
    }
    function Jh(e, n, l, f) {
      return e.addEventListener(n, l, {
        passive: f
      }), l;
    }
    var Ta = null, qu = null, Ea = null;
    function Hf(e) {
      return Ta = e, qu = od(), !0;
    }
    function ad() {
      Ta = null, qu = null, Ea = null;
    }
    function $f() {
      if (Ea)
        return Ea;
      var e, n = qu, l = n.length, f, h = od(), y = h.length;
      for (e = 0; e < l && n[e] === h[e]; e++)
        ;
      var k = l - e;
      for (f = 1; f <= k && n[l - f] === h[y - f]; f++)
        ;
      var w = f > 1 ? 1 - f : void 0;
      return Ea = h.slice(e, w), Ea;
    }
    function od() {
      return "value" in Ta ? Ta.value : Ta.textContent;
    }
    function Dl(e) {
      var n, l = e.keyCode;
      return "charCode" in e ? (n = e.charCode, n === 0 && l === 13 && (n = 13)) : n = l, n === 10 && (n = 13), n >= 32 || n === 13 ? n : 0;
    }
    function Rr() {
      return !0;
    }
    function Ho() {
      return !1;
    }
    function Fn(e) {
      function n(l, f, h, y, k) {
        this._reactName = l, this._targetInst = h, this.type = f, this.nativeEvent = y, this.target = k, this.currentTarget = null;
        for (var w in e)
          if (e.hasOwnProperty(w)) {
            var _ = e[w];
            _ ? this[w] = _(y) : this[w] = y[w];
          }
        var L = y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1;
        return L ? this.isDefaultPrevented = Rr : this.isDefaultPrevented = Ho, this.isPropagationStopped = Ho, this;
      }
      return Pt(n.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var l = this.nativeEvent;
          l && (l.preventDefault ? l.preventDefault() : typeof l.returnValue != "unknown" && (l.returnValue = !1), this.isDefaultPrevented = Rr);
        },
        stopPropagation: function() {
          var l = this.nativeEvent;
          l && (l.stopPropagation ? l.stopPropagation() : typeof l.cancelBubble != "unknown" && (l.cancelBubble = !0), this.isPropagationStopped = Rr);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Rr
      }), n;
    }
    var pr = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, qf = Fn(pr), Ol = Pt({}, pr, {
      view: 0,
      detail: 0
    }), Xh = Fn(Ol), Zh, po, Wu;
    function em(e) {
      e !== Wu && (Wu && e.type === "mousemove" ? (Zh = e.screenX - Wu.screenX, po = e.screenY - Wu.screenY) : (Zh = 0, po = 0), Wu = e);
    }
    var ho = Pt({}, Ol, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: tm,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (em(e), Zh);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : po;
      }
    }), Wf = Fn(ho), Ml = Pt({}, ho, {
      dataTransfer: 0
    }), Ug = Fn(Ml), Fg = Pt({}, Ol, {
      relatedTarget: 0
    }), sd = Fn(Fg), Gf = Pt({}, pr, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Xb = Fn(Gf), Zb = Pt({}, pr, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), jg = Fn(Zb), zg = Pt({}, pr, {
      data: 0
    }), js = Fn(zg), eS = js, Gu = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Vg = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function qn(e) {
      if (e.key) {
        var n = Gu[e.key] || e.key;
        if (n !== "Unidentified")
          return n;
      }
      if (e.type === "keypress") {
        var l = Dl(e);
        return l === 13 ? "Enter" : String.fromCharCode(l);
      }
      return e.type === "keydown" || e.type === "keyup" ? Vg[e.keyCode] || "Unidentified" : "";
    }
    var tS = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Bg(e) {
      var n = this, l = n.nativeEvent;
      if (l.getModifierState)
        return l.getModifierState(e);
      var f = tS[e];
      return f ? !!l[f] : !1;
    }
    function tm(e) {
      return Bg;
    }
    var nS = Pt({}, Ol, {
      key: qn,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: tm,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? Dl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? Dl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), Hg = Fn(nS), $g = Pt({}, ho, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), qg = Fn($g), wa = Pt({}, Ol, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: tm
    }), nm = Fn(wa), rS = Pt({}, pr, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), zs = Fn(rS), Yf = Pt({}, ho, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Nl = Fn(Yf), Kf = [9, 13, 27, 32], Qf = 229, ld = Nn && "CompositionEvent" in window, ud = null;
    Nn && "documentMode" in document && (ud = document.documentMode);
    var rm = Nn && "TextEvent" in window && !ud, Wg = Nn && (!ld || ud && ud > 8 && ud <= 11), im = 32, am = String.fromCharCode(im);
    function Jf() {
      Vr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Vr("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Vr("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Vr("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var cd = !1;
    function Gg(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function om(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function iS(e, n) {
      return e === "keydown" && n.keyCode === Qf;
    }
    function sm(e, n) {
      switch (e) {
        case "keyup":
          return Kf.indexOf(n.keyCode) !== -1;
        case "keydown":
          return n.keyCode !== Qf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Xf(e) {
      var n = e.detail;
      return typeof n == "object" && "data" in n ? n.data : null;
    }
    function dd(e) {
      return e.locale === "ko";
    }
    var Vs = !1;
    function Zf(e, n, l, f, h) {
      var y, k;
      if (ld ? y = om(n) : Vs ? sm(n, f) && (y = "onCompositionEnd") : iS(n, f) && (y = "onCompositionStart"), !y)
        return null;
      Wg && !dd(f) && (!Vs && y === "onCompositionStart" ? Vs = Hf(h) : y === "onCompositionEnd" && Vs && (k = $f()));
      var w = Zg(l, y);
      if (w.length > 0) {
        var _ = new js(y, n, null, f, h);
        if (e.push({
          event: _,
          listeners: w
        }), k)
          _.data = k;
        else {
          var L = Xf(f);
          L !== null && (_.data = L);
        }
      }
    }
    function Yg(e, n) {
      switch (e) {
        case "compositionend":
          return Xf(n);
        case "keypress":
          var l = n.which;
          return l !== im ? null : (cd = !0, am);
        case "textInput":
          var f = n.data;
          return f === am && cd ? null : f;
        default:
          return null;
      }
    }
    function aS(e, n) {
      if (Vs) {
        if (e === "compositionend" || !ld && sm(e, n)) {
          var l = $f();
          return ad(), Vs = !1, l;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!Gg(n)) {
            if (n.char && n.char.length > 1)
              return n.char;
            if (n.which)
              return String.fromCharCode(n.which);
          }
          return null;
        case "compositionend":
          return Wg && !dd(n) ? null : n.data;
        default:
          return null;
      }
    }
    function ep(e, n, l, f, h) {
      var y;
      if (rm ? y = Yg(n, f) : y = aS(n, f), !y)
        return null;
      var k = Zg(l, "onBeforeInput");
      if (k.length > 0) {
        var w = new eS("onBeforeInput", "beforeinput", null, f, h);
        e.push({
          event: w,
          listeners: k
        }), w.data = y;
      }
    }
    function oS(e, n, l, f, h, y, k) {
      Zf(e, n, l, f, h), ep(e, n, l, f, h);
    }
    var fd = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Kg(e) {
      var n = e && e.nodeName && e.nodeName.toLowerCase();
      return n === "input" ? !!fd[e.type] : n === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function tp(e) {
      if (!Nn)
        return !1;
      var n = "on" + e, l = n in document;
      if (!l) {
        var f = document.createElement("div");
        f.setAttribute(n, "return;"), l = typeof f[n] == "function";
      }
      return l;
    }
    function a() {
      Vr("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function s(e, n, l, f) {
      Zd(f);
      var h = Zg(n, "onChange");
      if (h.length > 0) {
        var y = new qf("onChange", "change", null, l, f);
        e.push({
          event: y,
          listeners: h
        });
      }
    }
    var p = null, v = null;
    function S(e) {
      var n = e.nodeName && e.nodeName.toLowerCase();
      return n === "select" || n === "input" && e.type === "file";
    }
    function T(e) {
      var n = [];
      s(n, v, e, Xd(e)), kh(D, n);
    }
    function D(e) {
      i1(e, 0);
    }
    function j(e) {
      var n = sp(e);
      if (uu(n))
        return e;
    }
    function H(e, n) {
      if (e === "change")
        return n;
    }
    var oe = !1;
    Nn && (oe = tp("input") && (!document.documentMode || document.documentMode > 9));
    function we(e, n) {
      p = e, v = n, p.attachEvent("onpropertychange", Te);
    }
    function Re() {
      p && (p.detachEvent("onpropertychange", Te), p = null, v = null);
    }
    function Te(e) {
      e.propertyName === "value" && j(v) && T(e);
    }
    function He(e, n, l) {
      e === "focusin" ? (Re(), we(n, l)) : e === "focusout" && Re();
    }
    function Ye(e, n) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return j(v);
    }
    function Xe(e) {
      var n = e.nodeName;
      return n && n.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function Xn(e, n) {
      if (e === "click")
        return j(n);
    }
    function Q(e, n) {
      if (e === "input" || e === "change")
        return j(n);
    }
    function q(e) {
      var n = e._wrapperState;
      !n || !n.controlled || e.type !== "number" || ct(e, "number", e.value);
    }
    function ee(e, n, l, f, h, y, k) {
      var w = l ? sp(l) : window, _, L;
      if (S(w) ? _ = H : Kg(w) ? oe ? _ = Q : (_ = Ye, L = He) : Xe(w) && (_ = Xn), _) {
        var A = _(n, l);
        if (A) {
          s(e, A, f, h);
          return;
        }
      }
      L && L(n, w, l), n === "focusout" && q(w);
    }
    function Oe() {
      yi("onMouseEnter", ["mouseout", "mouseover"]), yi("onMouseLeave", ["mouseout", "mouseover"]), yi("onPointerEnter", ["pointerout", "pointerover"]), yi("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function tt(e, n, l, f, h, y, k) {
      var w = n === "mouseover" || n === "pointerover", _ = n === "mouseout" || n === "pointerout";
      if (w && !lg(f)) {
        var L = f.relatedTarget || f.fromElement;
        if (L && (md(L) || Cm(L)))
          return;
      }
      if (!(!_ && !w)) {
        var A;
        if (h.window === h)
          A = h;
        else {
          var W = h.ownerDocument;
          W ? A = W.defaultView || W.parentWindow : A = window;
        }
        var $, re;
        if (_) {
          var le = f.relatedTarget || f.toElement;
          if ($ = l, re = le ? md(le) : null, re !== null) {
            var me = Ji(re);
            (re !== me || re.tag !== O && re.tag !== N) && (re = null);
          }
        } else
          $ = null, re = l;
        if ($ !== re) {
          var ze = Wf, ut = "onMouseLeave", it = "onMouseEnter", qt = "mouse";
          (n === "pointerout" || n === "pointerover") && (ze = qg, ut = "onPointerLeave", it = "onPointerEnter", qt = "pointer");
          var Ut = $ == null ? A : sp($), J = re == null ? A : sp(re), ve = new ze(ut, qt + "leave", $, f, h);
          ve.target = Ut, ve.relatedTarget = J;
          var X = null, xe = md(h);
          if (xe === l) {
            var We = new ze(it, qt + "enter", re, f, h);
            We.target = J, We.relatedTarget = Ut, X = We;
          }
          NM(e, ve, X, $, re);
        }
      }
    }
    function pt(e, n) {
      return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n;
    }
    var Ke = typeof Object.is == "function" ? Object.is : pt;
    function ht(e, n) {
      if (Ke(e, n))
        return !0;
      if (typeof e != "object" || e === null || typeof n != "object" || n === null)
        return !1;
      var l = Object.keys(e), f = Object.keys(n);
      if (l.length !== f.length)
        return !1;
      for (var h = 0; h < l.length; h++) {
        var y = l[h];
        if (!yr.call(n, y) || !Ke(e[y], n[y]))
          return !1;
      }
      return !0;
    }
    function hr(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Jt(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function $o(e, n) {
      for (var l = hr(e), f = 0, h = 0; l; ) {
        if (l.nodeType === Mo) {
          if (h = f + l.textContent.length, f <= n && h >= n)
            return {
              node: l,
              offset: n - f
            };
          f = h;
        }
        l = hr(Jt(l));
      }
    }
    function sS(e) {
      var n = e.ownerDocument, l = n && n.defaultView || window, f = l.getSelection && l.getSelection();
      if (!f || f.rangeCount === 0)
        return null;
      var h = f.anchorNode, y = f.anchorOffset, k = f.focusNode, w = f.focusOffset;
      try {
        h.nodeType, k.nodeType;
      } catch {
        return null;
      }
      return pM(e, h, y, k, w);
    }
    function pM(e, n, l, f, h) {
      var y = 0, k = -1, w = -1, _ = 0, L = 0, A = e, W = null;
      e:
        for (; ; ) {
          for (var $ = null; A === n && (l === 0 || A.nodeType === Mo) && (k = y + l), A === f && (h === 0 || A.nodeType === Mo) && (w = y + h), A.nodeType === Mo && (y += A.nodeValue.length), ($ = A.firstChild) !== null; )
            W = A, A = $;
          for (; ; ) {
            if (A === e)
              break e;
            if (W === n && ++_ === l && (k = y), W === f && ++L === h && (w = y), ($ = A.nextSibling) !== null)
              break;
            A = W, W = A.parentNode;
          }
          A = $;
        }
      return k === -1 || w === -1 ? null : {
        start: k,
        end: w
      };
    }
    function hM(e, n) {
      var l = e.ownerDocument || document, f = l && l.defaultView || window;
      if (f.getSelection) {
        var h = f.getSelection(), y = e.textContent.length, k = Math.min(n.start, y), w = n.end === void 0 ? k : Math.min(n.end, y);
        if (!h.extend && k > w) {
          var _ = w;
          w = k, k = _;
        }
        var L = $o(e, k), A = $o(e, w);
        if (L && A) {
          if (h.rangeCount === 1 && h.anchorNode === L.node && h.anchorOffset === L.offset && h.focusNode === A.node && h.focusOffset === A.offset)
            return;
          var W = l.createRange();
          W.setStart(L.node, L.offset), h.removeAllRanges(), k > w ? (h.addRange(W), h.extend(A.node, A.offset)) : (W.setEnd(A.node, A.offset), h.addRange(W));
        }
      }
    }
    function WE(e) {
      return e && e.nodeType === Mo;
    }
    function GE(e, n) {
      return !e || !n ? !1 : e === n ? !0 : WE(e) ? !1 : WE(n) ? GE(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1;
    }
    function mM(e) {
      return e && e.ownerDocument && GE(e.ownerDocument.documentElement, e);
    }
    function vM(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function YE() {
      for (var e = window, n = ws(); n instanceof e.HTMLIFrameElement; ) {
        if (vM(n))
          e = n.contentWindow;
        else
          return n;
        n = ws(e.document);
      }
      return n;
    }
    function lS(e) {
      var n = e && e.nodeName && e.nodeName.toLowerCase();
      return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true");
    }
    function gM() {
      var e = YE();
      return {
        focusedElem: e,
        selectionRange: lS(e) ? bM(e) : null
      };
    }
    function yM(e) {
      var n = YE(), l = e.focusedElem, f = e.selectionRange;
      if (n !== l && mM(l)) {
        f !== null && lS(l) && SM(l, f);
        for (var h = [], y = l; y = y.parentNode; )
          y.nodeType === Ri && h.push({
            element: y,
            left: y.scrollLeft,
            top: y.scrollTop
          });
        typeof l.focus == "function" && l.focus();
        for (var k = 0; k < h.length; k++) {
          var w = h[k];
          w.element.scrollLeft = w.left, w.element.scrollTop = w.top;
        }
      }
    }
    function bM(e) {
      var n;
      return "selectionStart" in e ? n = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : n = sS(e), n || {
        start: 0,
        end: 0
      };
    }
    function SM(e, n) {
      var l = n.start, f = n.end;
      f === void 0 && (f = l), "selectionStart" in e ? (e.selectionStart = l, e.selectionEnd = Math.min(f, e.value.length)) : hM(e, n);
    }
    var CM = Nn && "documentMode" in document && document.documentMode <= 11;
    function kM() {
      Vr("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var np = null, uS = null, lm = null, cS = !1;
    function TM(e) {
      if ("selectionStart" in e && lS(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var n = e.ownerDocument && e.ownerDocument.defaultView || window, l = n.getSelection();
      return {
        anchorNode: l.anchorNode,
        anchorOffset: l.anchorOffset,
        focusNode: l.focusNode,
        focusOffset: l.focusOffset
      };
    }
    function EM(e) {
      return e.window === e ? e.document : e.nodeType === $a ? e : e.ownerDocument;
    }
    function KE(e, n, l) {
      var f = EM(l);
      if (!(cS || np == null || np !== ws(f))) {
        var h = TM(np);
        if (!lm || !ht(lm, h)) {
          lm = h;
          var y = Zg(uS, "onSelect");
          if (y.length > 0) {
            var k = new qf("onSelect", "select", null, n, l);
            e.push({
              event: k,
              listeners: y
            }), k.target = np;
          }
        }
      }
    }
    function wM(e, n, l, f, h, y, k) {
      var w = l ? sp(l) : window;
      switch (n) {
        case "focusin":
          (Kg(w) || w.contentEditable === "true") && (np = w, uS = l, lm = null);
          break;
        case "focusout":
          np = null, uS = null, lm = null;
          break;
        case "mousedown":
          cS = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          cS = !1, KE(e, f, h);
          break;
        case "selectionchange":
          if (CM)
            break;
        case "keydown":
        case "keyup":
          KE(e, f, h);
      }
    }
    function Qg(e, n) {
      var l = {};
      return l[e.toLowerCase()] = n.toLowerCase(), l["Webkit" + e] = "webkit" + n, l["Moz" + e] = "moz" + n, l;
    }
    var rp = {
      animationend: Qg("Animation", "AnimationEnd"),
      animationiteration: Qg("Animation", "AnimationIteration"),
      animationstart: Qg("Animation", "AnimationStart"),
      transitionend: Qg("Transition", "TransitionEnd")
    }, dS = {}, QE = {};
    Nn && (QE = document.createElement("div").style, "AnimationEvent" in window || (delete rp.animationend.animation, delete rp.animationiteration.animation, delete rp.animationstart.animation), "TransitionEvent" in window || delete rp.transitionend.transition);
    function Jg(e) {
      if (dS[e])
        return dS[e];
      if (!rp[e])
        return e;
      var n = rp[e];
      for (var l in n)
        if (n.hasOwnProperty(l) && l in QE)
          return dS[e] = n[l];
      return e;
    }
    var JE = Jg("animationend"), XE = Jg("animationiteration"), ZE = Jg("animationstart"), e1 = Jg("transitionend"), t1 = /* @__PURE__ */ new Map(), n1 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Yu(e, n) {
      t1.set(e, n), Vr(n, [e]);
    }
    function RM() {
      for (var e = 0; e < n1.length; e++) {
        var n = n1[e], l = n.toLowerCase(), f = n[0].toUpperCase() + n.slice(1);
        Yu(l, "on" + f);
      }
      Yu(JE, "onAnimationEnd"), Yu(XE, "onAnimationIteration"), Yu(ZE, "onAnimationStart"), Yu("dblclick", "onDoubleClick"), Yu("focusin", "onFocus"), Yu("focusout", "onBlur"), Yu(e1, "onTransitionEnd");
    }
    function _M(e, n, l, f, h, y, k) {
      var w = t1.get(n);
      if (w !== void 0) {
        var _ = qf, L = n;
        switch (n) {
          case "keypress":
            if (Dl(f) === 0)
              return;
          case "keydown":
          case "keyup":
            _ = Hg;
            break;
          case "focusin":
            L = "focus", _ = sd;
            break;
          case "focusout":
            L = "blur", _ = sd;
            break;
          case "beforeblur":
          case "afterblur":
            _ = sd;
            break;
          case "click":
            if (f.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            _ = Wf;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            _ = Ug;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            _ = nm;
            break;
          case JE:
          case XE:
          case ZE:
            _ = Xb;
            break;
          case e1:
            _ = zs;
            break;
          case "scroll":
            _ = Xh;
            break;
          case "wheel":
            _ = Nl;
            break;
          case "copy":
          case "cut":
          case "paste":
            _ = jg;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            _ = qg;
            break;
        }
        var A = (y & fl) !== 0;
        {
          var W = !A && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          n === "scroll", $ = OM(l, w, f.type, A, W);
          if ($.length > 0) {
            var re = new _(w, L, null, f, h);
            e.push({
              event: re,
              listeners: $
            });
          }
        }
      }
    }
    RM(), Oe(), a(), kM(), Jf();
    function xM(e, n, l, f, h, y, k) {
      _M(e, n, l, f, h, y);
      var w = (y & jb) === 0;
      w && (tt(e, n, l, f, h), ee(e, n, l, f, h), wM(e, n, l, f, h), oS(e, n, l, f, h));
    }
    var um = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], fS = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(um));
    function r1(e, n, l) {
      var f = e.type || "unknown-event";
      e.currentTarget = l, Io(f, n, void 0, e), e.currentTarget = null;
    }
    function PM(e, n, l) {
      var f;
      if (l)
        for (var h = n.length - 1; h >= 0; h--) {
          var y = n[h], k = y.instance, w = y.currentTarget, _ = y.listener;
          if (k !== f && e.isPropagationStopped())
            return;
          r1(e, _, w), f = k;
        }
      else
        for (var L = 0; L < n.length; L++) {
          var A = n[L], W = A.instance, $ = A.currentTarget, re = A.listener;
          if (W !== f && e.isPropagationStopped())
            return;
          r1(e, re, $), f = W;
        }
    }
    function i1(e, n) {
      for (var l = (n & fl) !== 0, f = 0; f < e.length; f++) {
        var h = e[f], y = h.event, k = h.listeners;
        PM(y, k, l);
      }
      Rh();
    }
    function DM(e, n, l, f, h) {
      var y = Xd(l), k = [];
      xM(k, e, f, l, y, n), i1(k, n);
    }
    function jn(e, n) {
      fS.has(e) || c('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var l = !1, f = oL(n), h = LM(e, l);
      f.has(h) || (a1(n, e, Ac, l), f.add(h));
    }
    function pS(e, n, l) {
      fS.has(e) && !n && c('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var f = 0;
      n && (f |= fl), a1(l, e, f, n);
    }
    var Xg = "_reactListening" + Math.random().toString(36).slice(2);
    function cm(e) {
      if (!e[Xg]) {
        e[Xg] = !0, Dt.forEach(function(l) {
          l !== "selectionchange" && (fS.has(l) || pS(l, !1, e), pS(l, !0, e));
        });
        var n = e.nodeType === $a ? e : e.ownerDocument;
        n !== null && (n[Xg] || (n[Xg] = !0, pS("selectionchange", !1, n)));
      }
    }
    function a1(e, n, l, f, h) {
      var y = fr(e, n, l), k = void 0;
      zc && (n === "touchstart" || n === "touchmove" || n === "wheel") && (k = !0), e = e, f ? k !== void 0 ? Bf(e, n, y, k) : Bo(e, n, y) : k !== void 0 ? Jh(e, n, y, k) : $u(e, n, y);
    }
    function o1(e, n) {
      return e === n || e.nodeType === nr && e.parentNode === n;
    }
    function hS(e, n, l, f, h) {
      var y = f;
      if (!(n & Lo) && !(n & Ac)) {
        var k = h;
        if (f !== null) {
          var w = f;
          e:
            for (; ; ) {
              if (w === null)
                return;
              var _ = w.tag;
              if (_ === E || _ === x) {
                var L = w.stateNode.containerInfo;
                if (o1(L, k))
                  break;
                if (_ === x)
                  for (var A = w.return; A !== null; ) {
                    var W = A.tag;
                    if (W === E || W === x) {
                      var $ = A.stateNode.containerInfo;
                      if (o1($, k))
                        return;
                    }
                    A = A.return;
                  }
                for (; L !== null; ) {
                  var re = md(L);
                  if (re === null)
                    return;
                  var le = re.tag;
                  if (le === O || le === N) {
                    w = y = re;
                    continue e;
                  }
                  L = L.parentNode;
                }
              }
              w = w.return;
            }
        }
      }
      kh(function() {
        return DM(e, n, l, y);
      });
    }
    function dm(e, n, l) {
      return {
        instance: e,
        listener: n,
        currentTarget: l
      };
    }
    function OM(e, n, l, f, h, y) {
      for (var k = n !== null ? n + "Capture" : null, w = f ? k : n, _ = [], L = e, A = null; L !== null; ) {
        var W = L, $ = W.stateNode, re = W.tag;
        if (re === O && $ !== null && (A = $, w !== null)) {
          var le = hl(L, w);
          le != null && _.push(dm(L, le, A));
        }
        if (h)
          break;
        L = L.return;
      }
      return _;
    }
    function Zg(e, n) {
      for (var l = n + "Capture", f = [], h = e; h !== null; ) {
        var y = h, k = y.stateNode, w = y.tag;
        if (w === O && k !== null) {
          var _ = k, L = hl(h, l);
          L != null && f.unshift(dm(h, L, _));
          var A = hl(h, n);
          A != null && f.push(dm(h, A, _));
        }
        h = h.return;
      }
      return f;
    }
    function ip(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== O);
      return e || null;
    }
    function MM(e, n) {
      for (var l = e, f = n, h = 0, y = l; y; y = ip(y))
        h++;
      for (var k = 0, w = f; w; w = ip(w))
        k++;
      for (; h - k > 0; )
        l = ip(l), h--;
      for (; k - h > 0; )
        f = ip(f), k--;
      for (var _ = h; _--; ) {
        if (l === f || f !== null && l === f.alternate)
          return l;
        l = ip(l), f = ip(f);
      }
      return null;
    }
    function s1(e, n, l, f, h) {
      for (var y = n._reactName, k = [], w = l; w !== null && w !== f; ) {
        var _ = w, L = _.alternate, A = _.stateNode, W = _.tag;
        if (L !== null && L === f)
          break;
        if (W === O && A !== null) {
          var $ = A;
          if (h) {
            var re = hl(w, y);
            re != null && k.unshift(dm(w, re, $));
          } else if (!h) {
            var le = hl(w, y);
            le != null && k.push(dm(w, le, $));
          }
        }
        w = w.return;
      }
      k.length !== 0 && e.push({
        event: n,
        listeners: k
      });
    }
    function NM(e, n, l, f, h) {
      var y = f && h ? MM(f, h) : null;
      f !== null && s1(e, n, f, y, !1), h !== null && l !== null && s1(e, l, h, y, !0);
    }
    function LM(e, n) {
      return e + "__" + (n ? "capture" : "bubble");
    }
    var Ra = !1, fm = "dangerouslySetInnerHTML", ey = "suppressContentEditableWarning", Ku = "suppressHydrationWarning", l1 = "autoFocus", pd = "children", hd = "style", ty = "__html", mS, ny, pm, u1, ry, c1, d1;
    mS = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, ny = function(e, n) {
      Jd(e, n), gh(e, n), sg(e, n, {
        registrationNameDependencies: Ot,
        possibleRegistrationNames: yn
      });
    }, c1 = Nn && !document.documentMode, pm = function(e, n, l) {
      if (!Ra) {
        var f = iy(l), h = iy(n);
        h !== f && (Ra = !0, c("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(h), JSON.stringify(f)));
      }
    }, u1 = function(e) {
      if (!Ra) {
        Ra = !0;
        var n = [];
        e.forEach(function(l) {
          n.push(l);
        }), c("Extra attributes from the server: %s", n);
      }
    }, ry = function(e, n) {
      n === !1 ? c("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : c("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof n);
    }, d1 = function(e, n) {
      var l = e.namespaceURI === Oo ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return l.innerHTML = n, l.innerHTML;
    };
    var AM = /\r\n?/g, IM = /\u0000|\uFFFD/g;
    function iy(e) {
      Ci(e);
      var n = typeof e == "string" ? e : "" + e;
      return n.replace(AM, `
`).replace(IM, "");
    }
    function ay(e, n, l, f) {
      var h = iy(n), y = iy(e);
      if (y !== h && (f && (Ra || (Ra = !0, c('Text content did not match. Server: "%s" Client: "%s"', y, h))), l && Me))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function f1(e) {
      return e.nodeType === $a ? e : e.ownerDocument;
    }
    function UM() {
    }
    function oy(e) {
      e.onclick = UM;
    }
    function FM(e, n, l, f, h) {
      for (var y in f)
        if (f.hasOwnProperty(y)) {
          var k = f[y];
          if (y === hd)
            k && Object.freeze(k), Jv(n, k);
          else if (y === fm) {
            var w = k ? k[ty] : void 0;
            w != null && zv(n, w);
          } else if (y === pd)
            if (typeof k == "string") {
              var _ = e !== "textarea" || k !== "";
              _ && Gd(n, k);
            } else
              typeof k == "number" && Gd(n, "" + k);
          else
            y === ey || y === Ku || y === l1 || (Ot.hasOwnProperty(y) ? k != null && (typeof k != "function" && ry(y, k), y === "onScroll" && jn("scroll", n)) : k != null && Yi(n, y, k, h));
        }
    }
    function jM(e, n, l, f) {
      for (var h = 0; h < n.length; h += 2) {
        var y = n[h], k = n[h + 1];
        y === hd ? Jv(e, k) : y === fm ? zv(e, k) : y === pd ? Gd(e, k) : Yi(e, y, k, f);
      }
    }
    function zM(e, n, l, f) {
      var h, y = f1(l), k, w = f;
      if (w === Oo && (w = qd(e)), w === Oo) {
        if (h = No(e, n), !h && e !== e.toLowerCase() && c("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var _ = y.createElement("div");
          _.innerHTML = "<script><\/script>";
          var L = _.firstChild;
          k = _.removeChild(L);
        } else if (typeof n.is == "string")
          k = y.createElement(e, {
            is: n.is
          });
        else if (k = y.createElement(e), e === "select") {
          var A = k;
          n.multiple ? A.multiple = !0 : n.size && (A.size = n.size);
        }
      } else
        k = y.createElementNS(w, e);
      return w === Oo && !h && Object.prototype.toString.call(k) === "[object HTMLUnknownElement]" && !yr.call(mS, e) && (mS[e] = !0, c("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), k;
    }
    function VM(e, n) {
      return f1(n).createTextNode(e);
    }
    function BM(e, n, l, f) {
      var h = No(n, l);
      ny(n, l);
      var y;
      switch (n) {
        case "dialog":
          jn("cancel", e), jn("close", e), y = l;
          break;
        case "iframe":
        case "object":
        case "embed":
          jn("load", e), y = l;
          break;
        case "video":
        case "audio":
          for (var k = 0; k < um.length; k++)
            jn(um[k], e);
          y = l;
          break;
        case "source":
          jn("error", e), y = l;
          break;
        case "img":
        case "image":
        case "link":
          jn("error", e), jn("load", e), y = l;
          break;
        case "details":
          jn("toggle", e), y = l;
          break;
        case "input":
          z(e, l), y = P(e, l), jn("invalid", e);
          break;
        case "option":
          dn(e, l), y = l;
          break;
        case "select":
          Oc(e, l), y = Dc(e, l), jn("invalid", e);
          break;
        case "textarea":
          Uv(e, l), y = lh(e, l), jn("invalid", e);
          break;
        default:
          y = l;
      }
      switch (Kd(n, y), FM(n, e, f, y, h), n) {
        case "input":
          da(e), De(e, l, !1);
          break;
        case "textarea":
          da(e), jv(e);
          break;
        case "option":
          vn(e, l);
          break;
        case "select":
          oh(e, l);
          break;
        default:
          typeof y.onClick == "function" && oy(e);
          break;
      }
    }
    function HM(e, n, l, f, h) {
      ny(n, f);
      var y = null, k, w;
      switch (n) {
        case "input":
          k = P(e, l), w = P(e, f), y = [];
          break;
        case "select":
          k = Dc(e, l), w = Dc(e, f), y = [];
          break;
        case "textarea":
          k = lh(e, l), w = lh(e, f), y = [];
          break;
        default:
          k = l, w = f, typeof k.onClick != "function" && typeof w.onClick == "function" && oy(e);
          break;
      }
      Kd(n, w);
      var _, L, A = null;
      for (_ in k)
        if (!(w.hasOwnProperty(_) || !k.hasOwnProperty(_) || k[_] == null))
          if (_ === hd) {
            var W = k[_];
            for (L in W)
              W.hasOwnProperty(L) && (A || (A = {}), A[L] = "");
          } else
            _ === fm || _ === pd || _ === ey || _ === Ku || _ === l1 || (Ot.hasOwnProperty(_) ? y || (y = []) : (y = y || []).push(_, null));
      for (_ in w) {
        var $ = w[_], re = k != null ? k[_] : void 0;
        if (!(!w.hasOwnProperty(_) || $ === re || $ == null && re == null))
          if (_ === hd)
            if ($ && Object.freeze($), re) {
              for (L in re)
                re.hasOwnProperty(L) && (!$ || !$.hasOwnProperty(L)) && (A || (A = {}), A[L] = "");
              for (L in $)
                $.hasOwnProperty(L) && re[L] !== $[L] && (A || (A = {}), A[L] = $[L]);
            } else
              A || (y || (y = []), y.push(_, A)), A = $;
          else if (_ === fm) {
            var le = $ ? $[ty] : void 0, me = re ? re[ty] : void 0;
            le != null && me !== le && (y = y || []).push(_, le);
          } else
            _ === pd ? (typeof $ == "string" || typeof $ == "number") && (y = y || []).push(_, "" + $) : _ === ey || _ === Ku || (Ot.hasOwnProperty(_) ? ($ != null && (typeof $ != "function" && ry(_, $), _ === "onScroll" && jn("scroll", e)), !y && re !== $ && (y = [])) : (y = y || []).push(_, $));
      }
      return A && (Nc(A, w[hd]), (y = y || []).push(hd, A)), y;
    }
    function $M(e, n, l, f, h) {
      l === "input" && h.type === "radio" && h.name != null && ie(e, h);
      var y = No(l, f), k = No(l, h);
      switch (jM(e, n, y, k), l) {
        case "input":
          de(e, h);
          break;
        case "textarea":
          Fv(e, h);
          break;
        case "select":
          Pb(e, h);
          break;
      }
    }
    function qM(e) {
      {
        var n = e.toLowerCase();
        return Qd.hasOwnProperty(n) && Qd[n] || null;
      }
    }
    function WM(e, n, l, f, h, y, k) {
      var w, _;
      switch (w = No(n, l), ny(n, l), n) {
        case "dialog":
          jn("cancel", e), jn("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          jn("load", e);
          break;
        case "video":
        case "audio":
          for (var L = 0; L < um.length; L++)
            jn(um[L], e);
          break;
        case "source":
          jn("error", e);
          break;
        case "img":
        case "image":
        case "link":
          jn("error", e), jn("load", e);
          break;
        case "details":
          jn("toggle", e);
          break;
        case "input":
          z(e, l), jn("invalid", e);
          break;
        case "option":
          dn(e, l);
          break;
        case "select":
          Oc(e, l), jn("invalid", e);
          break;
        case "textarea":
          Uv(e, l), jn("invalid", e);
          break;
      }
      Kd(n, l);
      {
        _ = /* @__PURE__ */ new Set();
        for (var A = e.attributes, W = 0; W < A.length; W++) {
          var $ = A[W].name.toLowerCase();
          switch ($) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              _.add(A[W].name);
          }
        }
      }
      var re = null;
      for (var le in l)
        if (l.hasOwnProperty(le)) {
          var me = l[le];
          if (le === pd)
            typeof me == "string" ? e.textContent !== me && (l[Ku] !== !0 && ay(e.textContent, me, y, k), re = [pd, me]) : typeof me == "number" && e.textContent !== "" + me && (l[Ku] !== !0 && ay(e.textContent, me, y, k), re = [pd, "" + me]);
          else if (Ot.hasOwnProperty(le))
            me != null && (typeof me != "function" && ry(le, me), le === "onScroll" && jn("scroll", e));
          else if (k && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof w == "boolean") {
            var ze = void 0, ut = w && lt ? null : ei(le);
            if (l[Ku] !== !0) {
              if (!(le === ey || le === Ku || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              le === "value" || le === "checked" || le === "selected")) {
                if (le === fm) {
                  var it = e.innerHTML, qt = me ? me[ty] : void 0;
                  if (qt != null) {
                    var Ut = d1(e, qt);
                    Ut !== it && pm(le, it, Ut);
                  }
                } else if (le === hd) {
                  if (_.delete(le), c1) {
                    var J = Ub(me);
                    ze = e.getAttribute("style"), J !== ze && pm(le, ze, J);
                  }
                } else if (w && !lt)
                  _.delete(le.toLowerCase()), ze = to(e, le, me), me !== ze && pm(le, ze, me);
                else if (!An(le, ut, w) && !cn(le, me, ut, w)) {
                  var ve = !1;
                  if (ut !== null)
                    _.delete(ut.attributeName), ze = Gi(e, le, me, ut);
                  else {
                    var X = f;
                    if (X === Oo && (X = qd(n)), X === Oo)
                      _.delete(le.toLowerCase());
                    else {
                      var xe = qM(le);
                      xe !== null && xe !== le && (ve = !0, _.delete(xe)), _.delete(le);
                    }
                    ze = to(e, le, me);
                  }
                  var We = lt;
                  !We && me !== ze && !ve && pm(le, ze, me);
                }
              }
            }
          }
        }
      switch (k && // $FlowFixMe - Should be inferred as not undefined.
      _.size > 0 && l[Ku] !== !0 && u1(_), n) {
        case "input":
          da(e), De(e, l, !0);
          break;
        case "textarea":
          da(e), jv(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof l.onClick == "function" && oy(e);
          break;
      }
      return re;
    }
    function GM(e, n, l) {
      var f = e.nodeValue !== n;
      return f;
    }
    function vS(e, n) {
      {
        if (Ra)
          return;
        Ra = !0, c("Did not expect server HTML to contain a <%s> in <%s>.", n.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function gS(e, n) {
      {
        if (Ra)
          return;
        Ra = !0, c('Did not expect server HTML to contain the text node "%s" in <%s>.', n.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function yS(e, n, l) {
      {
        if (Ra)
          return;
        Ra = !0, c("Expected server HTML to contain a matching <%s> in <%s>.", n, e.nodeName.toLowerCase());
      }
    }
    function bS(e, n) {
      {
        if (n === "" || Ra)
          return;
        Ra = !0, c('Expected server HTML to contain a matching text node for "%s" in <%s>.', n, e.nodeName.toLowerCase());
      }
    }
    function YM(e, n, l) {
      switch (n) {
        case "input":
          ft(e, l);
          return;
        case "textarea":
          uh(e, l);
          return;
        case "select":
          Db(e, l);
          return;
      }
    }
    var hm = function() {
    }, mm = function() {
    };
    {
      var KM = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], p1 = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], QM = p1.concat(["button"]), JM = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], h1 = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      mm = function(e, n) {
        var l = Pt({}, e || h1), f = {
          tag: n
        };
        return p1.indexOf(n) !== -1 && (l.aTagInScope = null, l.buttonTagInScope = null, l.nobrTagInScope = null), QM.indexOf(n) !== -1 && (l.pTagInButtonScope = null), KM.indexOf(n) !== -1 && n !== "address" && n !== "div" && n !== "p" && (l.listItemTagAutoclosing = null, l.dlItemTagAutoclosing = null), l.current = f, n === "form" && (l.formTag = f), n === "a" && (l.aTagInScope = f), n === "button" && (l.buttonTagInScope = f), n === "nobr" && (l.nobrTagInScope = f), n === "p" && (l.pTagInButtonScope = f), n === "li" && (l.listItemTagAutoclosing = f), (n === "dd" || n === "dt") && (l.dlItemTagAutoclosing = f), l;
      };
      var XM = function(e, n) {
        switch (n) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return n !== "h1" && n !== "h2" && n !== "h3" && n !== "h4" && n !== "h5" && n !== "h6";
          case "rp":
          case "rt":
            return JM.indexOf(n) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return n == null;
        }
        return !0;
      }, ZM = function(e, n) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return n.pTagInButtonScope;
          case "form":
            return n.formTag || n.pTagInButtonScope;
          case "li":
            return n.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return n.dlItemTagAutoclosing;
          case "button":
            return n.buttonTagInScope;
          case "a":
            return n.aTagInScope;
          case "nobr":
            return n.nobrTagInScope;
        }
        return null;
      }, m1 = {};
      hm = function(e, n, l) {
        l = l || h1;
        var f = l.current, h = f && f.tag;
        n != null && (e != null && c("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var y = XM(e, h) ? null : f, k = y ? null : ZM(e, l), w = y || k;
        if (w) {
          var _ = w.tag, L = !!y + "|" + e + "|" + _;
          if (!m1[L]) {
            m1[L] = !0;
            var A = e, W = "";
            if (e === "#text" ? /\S/.test(n) ? A = "Text nodes" : (A = "Whitespace text nodes", W = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : A = "<" + e + ">", y) {
              var $ = "";
              _ === "table" && e === "tr" && ($ += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), c("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", A, _, W, $);
            } else
              c("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", A, _);
          }
        }
      };
    }
    var sy = "suppressHydrationWarning", ly = "$", uy = "/$", vm = "$?", gm = "$!", eN = "style", SS = null, CS = null;
    function tN(e) {
      var n, l, f = e.nodeType;
      switch (f) {
        case $a:
        case cl: {
          n = f === $a ? "#document" : "#fragment";
          var h = e.documentElement;
          l = h ? h.namespaceURI : dh(null, "");
          break;
        }
        default: {
          var y = f === nr ? e.parentNode : e, k = y.namespaceURI || null;
          n = y.tagName, l = dh(k, n);
          break;
        }
      }
      {
        var w = n.toLowerCase(), _ = mm(null, w);
        return {
          namespace: l,
          ancestorInfo: _
        };
      }
    }
    function nN(e, n, l) {
      {
        var f = e, h = dh(f.namespace, n), y = mm(f.ancestorInfo, n);
        return {
          namespace: h,
          ancestorInfo: y
        };
      }
    }
    function s9(e) {
      return e;
    }
    function rN(e) {
      SS = Bu(), CS = gM();
      var n = null;
      return Ii(!1), n;
    }
    function iN(e) {
      yM(CS), Ii(SS), SS = null, CS = null;
    }
    function aN(e, n, l, f, h) {
      var y;
      {
        var k = f;
        if (hm(e, null, k.ancestorInfo), typeof n.children == "string" || typeof n.children == "number") {
          var w = "" + n.children, _ = mm(k.ancestorInfo, e);
          hm(null, w, _);
        }
        y = k.namespace;
      }
      var L = zM(e, n, l, y);
      return Sm(h, L), PS(L, n), L;
    }
    function oN(e, n) {
      e.appendChild(n);
    }
    function sN(e, n, l, f, h) {
      switch (BM(e, n, l, f), n) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!l.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function lN(e, n, l, f, h, y) {
      {
        var k = y;
        if (typeof f.children != typeof l.children && (typeof f.children == "string" || typeof f.children == "number")) {
          var w = "" + f.children, _ = mm(k.ancestorInfo, n);
          hm(null, w, _);
        }
      }
      return HM(e, n, l, f);
    }
    function kS(e, n) {
      return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null;
    }
    function uN(e, n, l, f) {
      {
        var h = l;
        hm(null, e, h.ancestorInfo);
      }
      var y = VM(e, n);
      return Sm(f, y), y;
    }
    function cN() {
      var e = window.event;
      return e === void 0 ? co : Vf(e.type);
    }
    var TS = typeof setTimeout == "function" ? setTimeout : void 0, dN = typeof clearTimeout == "function" ? clearTimeout : void 0, ES = -1, v1 = typeof Promise == "function" ? Promise : void 0, fN = typeof queueMicrotask == "function" ? queueMicrotask : typeof v1 < "u" ? function(e) {
      return v1.resolve(null).then(e).catch(pN);
    } : TS;
    function pN(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function hN(e, n, l, f) {
      switch (n) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          l.autoFocus && e.focus();
          return;
        case "img": {
          l.src && (e.src = l.src);
          return;
        }
      }
    }
    function mN(e, n, l, f, h, y) {
      $M(e, n, l, f, h), PS(e, h);
    }
    function g1(e) {
      Gd(e, "");
    }
    function vN(e, n, l) {
      e.nodeValue = l;
    }
    function gN(e, n) {
      e.appendChild(n);
    }
    function yN(e, n) {
      var l;
      e.nodeType === nr ? (l = e.parentNode, l.insertBefore(n, e)) : (l = e, l.appendChild(n));
      var f = e._reactRootContainer;
      f == null && l.onclick === null && oy(l);
    }
    function bN(e, n, l) {
      e.insertBefore(n, l);
    }
    function SN(e, n, l) {
      e.nodeType === nr ? e.parentNode.insertBefore(n, l) : e.insertBefore(n, l);
    }
    function CN(e, n) {
      e.removeChild(n);
    }
    function kN(e, n) {
      e.nodeType === nr ? e.parentNode.removeChild(n) : e.removeChild(n);
    }
    function wS(e, n) {
      var l = n, f = 0;
      do {
        var h = l.nextSibling;
        if (e.removeChild(l), h && h.nodeType === nr) {
          var y = h.data;
          if (y === uy)
            if (f === 0) {
              e.removeChild(h), $n(n);
              return;
            } else
              f--;
          else
            (y === ly || y === vm || y === gm) && f++;
        }
        l = h;
      } while (l);
      $n(n);
    }
    function TN(e, n) {
      e.nodeType === nr ? wS(e.parentNode, n) : e.nodeType === Ri && wS(e, n), $n(e);
    }
    function EN(e) {
      e = e;
      var n = e.style;
      typeof n.setProperty == "function" ? n.setProperty("display", "none", "important") : n.display = "none";
    }
    function wN(e) {
      e.nodeValue = "";
    }
    function RN(e, n) {
      e = e;
      var l = n[eN], f = l != null && l.hasOwnProperty("display") ? l.display : null;
      e.style.display = Yd("display", f);
    }
    function _N(e, n) {
      e.nodeValue = n;
    }
    function xN(e) {
      e.nodeType === Ri ? e.textContent = "" : e.nodeType === $a && e.documentElement && e.removeChild(e.documentElement);
    }
    function PN(e, n, l) {
      return e.nodeType !== Ri || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function DN(e, n) {
      return n === "" || e.nodeType !== Mo ? null : e;
    }
    function ON(e) {
      return e.nodeType !== nr ? null : e;
    }
    function y1(e) {
      return e.data === vm;
    }
    function RS(e) {
      return e.data === gm;
    }
    function MN(e) {
      var n = e.nextSibling && e.nextSibling.dataset, l, f, h;
      return n && (l = n.dgst, f = n.msg, h = n.stck), {
        message: f,
        digest: l,
        stack: h
      };
    }
    function NN(e, n) {
      e._reactRetry = n;
    }
    function cy(e) {
      for (; e != null; e = e.nextSibling) {
        var n = e.nodeType;
        if (n === Ri || n === Mo)
          break;
        if (n === nr) {
          var l = e.data;
          if (l === ly || l === gm || l === vm)
            break;
          if (l === uy)
            return null;
        }
      }
      return e;
    }
    function ym(e) {
      return cy(e.nextSibling);
    }
    function LN(e) {
      return cy(e.firstChild);
    }
    function AN(e) {
      return cy(e.firstChild);
    }
    function IN(e) {
      return cy(e.nextSibling);
    }
    function UN(e, n, l, f, h, y, k) {
      Sm(y, e), PS(e, l);
      var w;
      {
        var _ = h;
        w = _.namespace;
      }
      var L = (y.mode & rt) !== et;
      return WM(e, n, l, w, f, L, k);
    }
    function FN(e, n, l, f) {
      return Sm(l, e), l.mode & rt, GM(e, n);
    }
    function jN(e, n) {
      Sm(n, e);
    }
    function zN(e) {
      for (var n = e.nextSibling, l = 0; n; ) {
        if (n.nodeType === nr) {
          var f = n.data;
          if (f === uy) {
            if (l === 0)
              return ym(n);
            l--;
          } else
            (f === ly || f === gm || f === vm) && l++;
        }
        n = n.nextSibling;
      }
      return null;
    }
    function b1(e) {
      for (var n = e.previousSibling, l = 0; n; ) {
        if (n.nodeType === nr) {
          var f = n.data;
          if (f === ly || f === gm || f === vm) {
            if (l === 0)
              return n;
            l--;
          } else
            f === uy && l++;
        }
        n = n.previousSibling;
      }
      return null;
    }
    function VN(e) {
      $n(e);
    }
    function BN(e) {
      $n(e);
    }
    function HN(e) {
      return e !== "head" && e !== "body";
    }
    function $N(e, n, l, f) {
      var h = !0;
      ay(n.nodeValue, l, f, h);
    }
    function qN(e, n, l, f, h, y) {
      if (n[sy] !== !0) {
        var k = !0;
        ay(f.nodeValue, h, y, k);
      }
    }
    function WN(e, n) {
      n.nodeType === Ri ? vS(e, n) : n.nodeType === nr || gS(e, n);
    }
    function GN(e, n) {
      {
        var l = e.parentNode;
        l !== null && (n.nodeType === Ri ? vS(l, n) : n.nodeType === nr || gS(l, n));
      }
    }
    function YN(e, n, l, f, h) {
      (h || n[sy] !== !0) && (f.nodeType === Ri ? vS(l, f) : f.nodeType === nr || gS(l, f));
    }
    function KN(e, n, l) {
      yS(e, n);
    }
    function QN(e, n) {
      bS(e, n);
    }
    function JN(e, n, l) {
      {
        var f = e.parentNode;
        f !== null && yS(f, n);
      }
    }
    function XN(e, n) {
      {
        var l = e.parentNode;
        l !== null && bS(l, n);
      }
    }
    function ZN(e, n, l, f, h, y) {
      (y || n[sy] !== !0) && yS(l, f);
    }
    function eL(e, n, l, f, h) {
      (h || n[sy] !== !0) && bS(l, f);
    }
    function tL(e) {
      c("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function nL(e) {
      cm(e);
    }
    var ap = Math.random().toString(36).slice(2), op = "__reactFiber$" + ap, _S = "__reactProps$" + ap, bm = "__reactContainer$" + ap, xS = "__reactEvents$" + ap, rL = "__reactListeners$" + ap, iL = "__reactHandles$" + ap;
    function aL(e) {
      delete e[op], delete e[_S], delete e[xS], delete e[rL], delete e[iL];
    }
    function Sm(e, n) {
      n[op] = e;
    }
    function dy(e, n) {
      n[bm] = e;
    }
    function S1(e) {
      e[bm] = null;
    }
    function Cm(e) {
      return !!e[bm];
    }
    function md(e) {
      var n = e[op];
      if (n)
        return n;
      for (var l = e.parentNode; l; ) {
        if (n = l[bm] || l[op], n) {
          var f = n.alternate;
          if (n.child !== null || f !== null && f.child !== null)
            for (var h = b1(e); h !== null; ) {
              var y = h[op];
              if (y)
                return y;
              h = b1(h);
            }
          return n;
        }
        e = l, l = e.parentNode;
      }
      return null;
    }
    function Qu(e) {
      var n = e[op] || e[bm];
      return n && (n.tag === O || n.tag === N || n.tag === F || n.tag === E) ? n : null;
    }
    function sp(e) {
      if (e.tag === O || e.tag === N)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function fy(e) {
      return e[_S] || null;
    }
    function PS(e, n) {
      e[_S] = n;
    }
    function oL(e) {
      var n = e[xS];
      return n === void 0 && (n = e[xS] = /* @__PURE__ */ new Set()), n;
    }
    var C1 = {}, k1 = i.ReactDebugCurrentFrame;
    function py(e) {
      if (e) {
        var n = e._owner, l = ao(e.type, e._source, n ? n.type : null);
        k1.setExtraStackFrame(l);
      } else
        k1.setExtraStackFrame(null);
    }
    function qo(e, n, l, f, h) {
      {
        var y = Function.call.bind(yr);
        for (var k in e)
          if (y(e, k)) {
            var w = void 0;
            try {
              if (typeof e[k] != "function") {
                var _ = Error((f || "React class") + ": " + l + " type `" + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[k] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw _.name = "Invariant Violation", _;
              }
              w = e[k](n, k, f, l, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (L) {
              w = L;
            }
            w && !(w instanceof Error) && (py(h), c("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", f || "React class", l, k, typeof w), py(null)), w instanceof Error && !(w.message in C1) && (C1[w.message] = !0, py(h), c("Failed %s type: %s", l, w.message), py(null));
          }
      }
    }
    var DS = [], hy;
    hy = [];
    var Ll = -1;
    function Ju(e) {
      return {
        current: e
      };
    }
    function Ui(e, n) {
      if (Ll < 0) {
        c("Unexpected pop.");
        return;
      }
      n !== hy[Ll] && c("Unexpected Fiber popped."), e.current = DS[Ll], DS[Ll] = null, hy[Ll] = null, Ll--;
    }
    function Fi(e, n, l) {
      Ll++, DS[Ll] = e.current, hy[Ll] = l, e.current = n;
    }
    var OS;
    OS = {};
    var Ya = {};
    Object.freeze(Ya);
    var Al = Ju(Ya), Bs = Ju(!1), MS = Ya;
    function lp(e, n, l) {
      return l && Hs(n) ? MS : Al.current;
    }
    function T1(e, n, l) {
      {
        var f = e.stateNode;
        f.__reactInternalMemoizedUnmaskedChildContext = n, f.__reactInternalMemoizedMaskedChildContext = l;
      }
    }
    function up(e, n) {
      {
        var l = e.type, f = l.contextTypes;
        if (!f)
          return Ya;
        var h = e.stateNode;
        if (h && h.__reactInternalMemoizedUnmaskedChildContext === n)
          return h.__reactInternalMemoizedMaskedChildContext;
        var y = {};
        for (var k in f)
          y[k] = n[k];
        {
          var w = bt(e) || "Unknown";
          qo(f, y, "context", w);
        }
        return h && T1(e, n, y), y;
      }
    }
    function my() {
      return Bs.current;
    }
    function Hs(e) {
      {
        var n = e.childContextTypes;
        return n != null;
      }
    }
    function vy(e) {
      Ui(Bs, e), Ui(Al, e);
    }
    function NS(e) {
      Ui(Bs, e), Ui(Al, e);
    }
    function E1(e, n, l) {
      {
        if (Al.current !== Ya)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Fi(Al, n, e), Fi(Bs, l, e);
      }
    }
    function w1(e, n, l) {
      {
        var f = e.stateNode, h = n.childContextTypes;
        if (typeof f.getChildContext != "function") {
          {
            var y = bt(e) || "Unknown";
            OS[y] || (OS[y] = !0, c("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", y, y));
          }
          return l;
        }
        var k = f.getChildContext();
        for (var w in k)
          if (!(w in h))
            throw new Error((bt(e) || "Unknown") + '.getChildContext(): key "' + w + '" is not defined in childContextTypes.');
        {
          var _ = bt(e) || "Unknown";
          qo(h, k, "child context", _);
        }
        return Pt({}, l, k);
      }
    }
    function gy(e) {
      {
        var n = e.stateNode, l = n && n.__reactInternalMemoizedMergedChildContext || Ya;
        return MS = Al.current, Fi(Al, l, e), Fi(Bs, Bs.current, e), !0;
      }
    }
    function R1(e, n, l) {
      {
        var f = e.stateNode;
        if (!f)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (l) {
          var h = w1(e, n, MS);
          f.__reactInternalMemoizedMergedChildContext = h, Ui(Bs, e), Ui(Al, e), Fi(Al, h, e), Fi(Bs, l, e);
        } else
          Ui(Bs, e), Fi(Bs, l, e);
      }
    }
    function sL(e) {
      {
        if (!Oh(e) || e.tag !== b)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var n = e;
        do {
          switch (n.tag) {
            case E:
              return n.stateNode.context;
            case b: {
              var l = n.type;
              if (Hs(l))
                return n.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          n = n.return;
        } while (n !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Xu = 0, yy = 1, Il = null, LS = !1, AS = !1;
    function _1(e) {
      Il === null ? Il = [e] : Il.push(e);
    }
    function lL(e) {
      LS = !0, _1(e);
    }
    function x1() {
      LS && Zu();
    }
    function Zu() {
      if (!AS && Il !== null) {
        AS = !0;
        var e = 0, n = Ca();
        try {
          var l = !0, f = Il;
          for (Hn(Jn); e < f.length; e++) {
            var h = f[e];
            do
              h = h(l);
            while (h !== null);
          }
          Il = null, LS = !1;
        } catch (y) {
          throw Il !== null && (Il = Il.slice(e + 1)), of(lf, Zu), y;
        } finally {
          Hn(n), AS = !1;
        }
      }
      return null;
    }
    var cp = [], dp = 0, by = null, Sy = 0, mo = [], vo = 0, vd = null, Ul = 1, Fl = "";
    function uL(e) {
      return yd(), (e.flags & xh) !== st;
    }
    function cL(e) {
      return yd(), Sy;
    }
    function dL() {
      var e = Fl, n = Ul, l = n & ~fL(n);
      return l.toString(32) + e;
    }
    function gd(e, n) {
      yd(), cp[dp++] = Sy, cp[dp++] = by, by = e, Sy = n;
    }
    function P1(e, n, l) {
      yd(), mo[vo++] = Ul, mo[vo++] = Fl, mo[vo++] = vd, vd = e;
      var f = Ul, h = Fl, y = Cy(f) - 1, k = f & ~(1 << y), w = l + 1, _ = Cy(n) + y;
      if (_ > 30) {
        var L = y - y % 5, A = (1 << L) - 1, W = (k & A).toString(32), $ = k >> L, re = y - L, le = Cy(n) + re, me = w << re, ze = me | $, ut = W + h;
        Ul = 1 << le | ze, Fl = ut;
      } else {
        var it = w << y, qt = it | k, Ut = h;
        Ul = 1 << _ | qt, Fl = Ut;
      }
    }
    function IS(e) {
      yd();
      var n = e.return;
      if (n !== null) {
        var l = 1, f = 0;
        gd(e, l), P1(e, l, f);
      }
    }
    function Cy(e) {
      return 32 - wu(e);
    }
    function fL(e) {
      return 1 << Cy(e) - 1;
    }
    function US(e) {
      for (; e === by; )
        by = cp[--dp], cp[dp] = null, Sy = cp[--dp], cp[dp] = null;
      for (; e === vd; )
        vd = mo[--vo], mo[vo] = null, Fl = mo[--vo], mo[vo] = null, Ul = mo[--vo], mo[vo] = null;
    }
    function pL() {
      return yd(), vd !== null ? {
        id: Ul,
        overflow: Fl
      } : null;
    }
    function hL(e, n) {
      yd(), mo[vo++] = Ul, mo[vo++] = Fl, mo[vo++] = vd, Ul = n.id, Fl = n.overflow, vd = e;
    }
    function yd() {
      li() || c("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var si = null, go = null, Wo = !1, bd = !1, ec = null;
    function mL() {
      Wo && c("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function D1() {
      bd = !0;
    }
    function vL() {
      return bd;
    }
    function gL(e) {
      var n = e.stateNode.containerInfo;
      return go = AN(n), si = e, Wo = !0, ec = null, bd = !1, !0;
    }
    function yL(e, n, l) {
      return go = IN(n), si = e, Wo = !0, ec = null, bd = !1, l !== null && hL(e, l), !0;
    }
    function O1(e, n) {
      switch (e.tag) {
        case E: {
          WN(e.stateNode.containerInfo, n);
          break;
        }
        case O: {
          var l = (e.mode & rt) !== et;
          YN(
            e.type,
            e.memoizedProps,
            e.stateNode,
            n,
            // TODO: Delete this argument when we remove the legacy root API.
            l
          );
          break;
        }
        case F: {
          var f = e.memoizedState;
          f.dehydrated !== null && GN(f.dehydrated, n);
          break;
        }
      }
    }
    function M1(e, n) {
      O1(e, n);
      var l = kI();
      l.stateNode = n, l.return = e;
      var f = e.deletions;
      f === null ? (e.deletions = [l], e.flags |= tn) : f.push(l);
    }
    function FS(e, n) {
      {
        if (bd)
          return;
        switch (e.tag) {
          case E: {
            var l = e.stateNode.containerInfo;
            switch (n.tag) {
              case O:
                var f = n.type;
                n.pendingProps, KN(l, f);
                break;
              case N:
                var h = n.pendingProps;
                QN(l, h);
                break;
            }
            break;
          }
          case O: {
            var y = e.type, k = e.memoizedProps, w = e.stateNode;
            switch (n.tag) {
              case O: {
                var _ = n.type, L = n.pendingProps, A = (e.mode & rt) !== et;
                ZN(
                  y,
                  k,
                  w,
                  _,
                  L,
                  // TODO: Delete this argument when we remove the legacy root API.
                  A
                );
                break;
              }
              case N: {
                var W = n.pendingProps, $ = (e.mode & rt) !== et;
                eL(
                  y,
                  k,
                  w,
                  W,
                  // TODO: Delete this argument when we remove the legacy root API.
                  $
                );
                break;
              }
            }
            break;
          }
          case F: {
            var re = e.memoizedState, le = re.dehydrated;
            if (le !== null)
              switch (n.tag) {
                case O:
                  var me = n.type;
                  n.pendingProps, JN(le, me);
                  break;
                case N:
                  var ze = n.pendingProps;
                  XN(le, ze);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function N1(e, n) {
      n.flags = n.flags & ~ma | Tn, FS(e, n);
    }
    function L1(e, n) {
      switch (e.tag) {
        case O: {
          var l = e.type;
          e.pendingProps;
          var f = PN(n, l);
          return f !== null ? (e.stateNode = f, si = e, go = LN(f), !0) : !1;
        }
        case N: {
          var h = e.pendingProps, y = DN(n, h);
          return y !== null ? (e.stateNode = y, si = e, go = null, !0) : !1;
        }
        case F: {
          var k = ON(n);
          if (k !== null) {
            var w = {
              dehydrated: k,
              treeContext: pL(),
              retryLane: Yr
            };
            e.memoizedState = w;
            var _ = TI(k);
            return _.return = e, e.child = _, si = e, go = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function jS(e) {
      return (e.mode & rt) !== et && (e.flags & gt) === st;
    }
    function zS(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function VS(e) {
      if (Wo) {
        var n = go;
        if (!n) {
          jS(e) && (FS(si, e), zS()), N1(si, e), Wo = !1, si = e;
          return;
        }
        var l = n;
        if (!L1(e, n)) {
          jS(e) && (FS(si, e), zS()), n = ym(l);
          var f = si;
          if (!n || !L1(e, n)) {
            N1(si, e), Wo = !1, si = e;
            return;
          }
          M1(f, l);
        }
      }
    }
    function bL(e, n, l) {
      var f = e.stateNode, h = !bd, y = UN(f, e.type, e.memoizedProps, n, l, e, h);
      return e.updateQueue = y, y !== null;
    }
    function SL(e) {
      var n = e.stateNode, l = e.memoizedProps, f = FN(n, l, e);
      if (f) {
        var h = si;
        if (h !== null)
          switch (h.tag) {
            case E: {
              var y = h.stateNode.containerInfo, k = (h.mode & rt) !== et;
              $N(
                y,
                n,
                l,
                // TODO: Delete this argument when we remove the legacy root API.
                k
              );
              break;
            }
            case O: {
              var w = h.type, _ = h.memoizedProps, L = h.stateNode, A = (h.mode & rt) !== et;
              qN(
                w,
                _,
                L,
                n,
                l,
                // TODO: Delete this argument when we remove the legacy root API.
                A
              );
              break;
            }
          }
      }
      return f;
    }
    function CL(e) {
      var n = e.memoizedState, l = n !== null ? n.dehydrated : null;
      if (!l)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      jN(l, e);
    }
    function kL(e) {
      var n = e.memoizedState, l = n !== null ? n.dehydrated : null;
      if (!l)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return zN(l);
    }
    function A1(e) {
      for (var n = e.return; n !== null && n.tag !== O && n.tag !== E && n.tag !== F; )
        n = n.return;
      si = n;
    }
    function ky(e) {
      if (e !== si)
        return !1;
      if (!Wo)
        return A1(e), Wo = !0, !1;
      if (e.tag !== E && (e.tag !== O || HN(e.type) && !kS(e.type, e.memoizedProps))) {
        var n = go;
        if (n)
          if (jS(e))
            I1(e), zS();
          else
            for (; n; )
              M1(e, n), n = ym(n);
      }
      return A1(e), e.tag === F ? go = kL(e) : go = si ? ym(e.stateNode) : null, !0;
    }
    function TL() {
      return Wo && go !== null;
    }
    function I1(e) {
      for (var n = go; n; )
        O1(e, n), n = ym(n);
    }
    function fp() {
      si = null, go = null, Wo = !1, bd = !1;
    }
    function U1() {
      ec !== null && (DR(ec), ec = null);
    }
    function li() {
      return Wo;
    }
    function BS(e) {
      ec === null ? ec = [e] : ec.push(e);
    }
    var EL = i.ReactCurrentBatchConfig, wL = null;
    function RL() {
      return EL.transition;
    }
    var Go = {
      recordUnsafeLifecycleWarnings: function(e, n) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, n) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var _L = function(e) {
        for (var n = null, l = e; l !== null; )
          l.mode & At && (n = l), l = l.return;
        return n;
      }, Sd = function(e) {
        var n = [];
        return e.forEach(function(l) {
          n.push(l);
        }), n.sort().join(", ");
      }, km = [], Tm = [], Em = [], wm = [], Rm = [], _m = [], Cd = /* @__PURE__ */ new Set();
      Go.recordUnsafeLifecycleWarnings = function(e, n) {
        Cd.has(e.type) || (typeof n.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        n.componentWillMount.__suppressDeprecationWarning !== !0 && km.push(e), e.mode & At && typeof n.UNSAFE_componentWillMount == "function" && Tm.push(e), typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Em.push(e), e.mode & At && typeof n.UNSAFE_componentWillReceiveProps == "function" && wm.push(e), typeof n.componentWillUpdate == "function" && n.componentWillUpdate.__suppressDeprecationWarning !== !0 && Rm.push(e), e.mode & At && typeof n.UNSAFE_componentWillUpdate == "function" && _m.push(e));
      }, Go.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        km.length > 0 && (km.forEach(function($) {
          e.add(bt($) || "Component"), Cd.add($.type);
        }), km = []);
        var n = /* @__PURE__ */ new Set();
        Tm.length > 0 && (Tm.forEach(function($) {
          n.add(bt($) || "Component"), Cd.add($.type);
        }), Tm = []);
        var l = /* @__PURE__ */ new Set();
        Em.length > 0 && (Em.forEach(function($) {
          l.add(bt($) || "Component"), Cd.add($.type);
        }), Em = []);
        var f = /* @__PURE__ */ new Set();
        wm.length > 0 && (wm.forEach(function($) {
          f.add(bt($) || "Component"), Cd.add($.type);
        }), wm = []);
        var h = /* @__PURE__ */ new Set();
        Rm.length > 0 && (Rm.forEach(function($) {
          h.add(bt($) || "Component"), Cd.add($.type);
        }), Rm = []);
        var y = /* @__PURE__ */ new Set();
        if (_m.length > 0 && (_m.forEach(function($) {
          y.add(bt($) || "Component"), Cd.add($.type);
        }), _m = []), n.size > 0) {
          var k = Sd(n);
          c(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, k);
        }
        if (f.size > 0) {
          var w = Sd(f);
          c(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, w);
        }
        if (y.size > 0) {
          var _ = Sd(y);
          c(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, _);
        }
        if (e.size > 0) {
          var L = Sd(e);
          d(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, L);
        }
        if (l.size > 0) {
          var A = Sd(l);
          d(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, A);
        }
        if (h.size > 0) {
          var W = Sd(h);
          d(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, W);
        }
      };
      var Ty = /* @__PURE__ */ new Map(), F1 = /* @__PURE__ */ new Set();
      Go.recordLegacyContextWarning = function(e, n) {
        var l = _L(e);
        if (l === null) {
          c("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!F1.has(e.type)) {
          var f = Ty.get(l);
          (e.type.contextTypes != null || e.type.childContextTypes != null || n !== null && typeof n.getChildContext == "function") && (f === void 0 && (f = [], Ty.set(l, f)), f.push(e));
        }
      }, Go.flushLegacyContextWarning = function() {
        Ty.forEach(function(e, n) {
          if (e.length !== 0) {
            var l = e[0], f = /* @__PURE__ */ new Set();
            e.forEach(function(y) {
              f.add(bt(y) || "Component"), F1.add(y.type);
            });
            var h = Sd(f);
            try {
              sn(l), c(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, h);
            } finally {
              Vn();
            }
          }
        });
      }, Go.discardPendingWarnings = function() {
        km = [], Tm = [], Em = [], wm = [], Rm = [], _m = [], Ty = /* @__PURE__ */ new Map();
      };
    }
    var HS, $S, qS, WS, GS, j1 = function(e, n) {
    };
    HS = !1, $S = !1, qS = {}, WS = {}, GS = {}, j1 = function(e, n) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var l = bt(n) || "Component";
        WS[l] || (WS[l] = !0, c('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function xL(e) {
      return e.prototype && e.prototype.isReactComponent;
    }
    function xm(e, n, l) {
      var f = l.ref;
      if (f !== null && typeof f != "function" && typeof f != "object") {
        if ((e.mode & At || Be) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(l._owner && l._self && l._owner.stateNode !== l._self) && // Will already throw with "Function components cannot have string refs"
        !(l._owner && l._owner.tag !== b) && // Will already warn with "Function components cannot be given refs"
        !(typeof l.type == "function" && !xL(l.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        l._owner) {
          var h = bt(e) || "Component";
          qS[h] || (c('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', h, f), qS[h] = !0);
        }
        if (l._owner) {
          var y = l._owner, k;
          if (y) {
            var w = y;
            if (w.tag !== b)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            k = w.stateNode;
          }
          if (!k)
            throw new Error("Missing owner for string ref " + f + ". This error is likely caused by a bug in React. Please file an issue.");
          var _ = k;
          br(f, "ref");
          var L = "" + f;
          if (n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === L)
            return n.ref;
          var A = function(W) {
            var $ = _.refs;
            W === null ? delete $[L] : $[L] = W;
          };
          return A._stringRef = L, A;
        } else {
          if (typeof f != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!l._owner)
            throw new Error("Element ref was specified as a string (" + f + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return f;
    }
    function Ey(e, n) {
      var l = Object.prototype.toString.call(n);
      throw new Error("Objects are not valid as a React child (found: " + (l === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : l) + "). If you meant to render a collection of children, use an array instead.");
    }
    function wy(e) {
      {
        var n = bt(e) || "Component";
        if (GS[n])
          return;
        GS[n] = !0, c("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function z1(e) {
      var n = e._payload, l = e._init;
      return l(n);
    }
    function V1(e) {
      function n(J, ve) {
        if (e) {
          var X = J.deletions;
          X === null ? (J.deletions = [ve], J.flags |= tn) : X.push(ve);
        }
      }
      function l(J, ve) {
        if (!e)
          return null;
        for (var X = ve; X !== null; )
          n(J, X), X = X.sibling;
        return null;
      }
      function f(J, ve) {
        for (var X = /* @__PURE__ */ new Map(), xe = ve; xe !== null; )
          xe.key !== null ? X.set(xe.key, xe) : X.set(xe.index, xe), xe = xe.sibling;
        return X;
      }
      function h(J, ve) {
        var X = Dd(J, ve);
        return X.index = 0, X.sibling = null, X;
      }
      function y(J, ve, X) {
        if (J.index = X, !e)
          return J.flags |= xh, ve;
        var xe = J.alternate;
        if (xe !== null) {
          var We = xe.index;
          return We < ve ? (J.flags |= Tn, ve) : We;
        } else
          return J.flags |= Tn, ve;
      }
      function k(J) {
        return e && J.alternate === null && (J.flags |= Tn), J;
      }
      function w(J, ve, X, xe) {
        if (ve === null || ve.tag !== N) {
          var We = Bk(X, J.mode, xe);
          return We.return = J, We;
        } else {
          var Ve = h(ve, X);
          return Ve.return = J, Ve;
        }
      }
      function _(J, ve, X, xe) {
        var We = X.type;
        if (We === Ki)
          return A(J, ve, X.props.children, xe, X.key);
        if (ve !== null && (ve.elementType === We || // Keep this check inline so it only runs on the false path:
        WR(ve, X) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof We == "object" && We !== null && We.$$typeof === dt && z1(We) === ve.type)) {
          var Ve = h(ve, X.props);
          return Ve.ref = xm(J, ve, X), Ve.return = J, Ve._debugSource = X._source, Ve._debugOwner = X._owner, Ve;
        }
        var mt = Vk(X, J.mode, xe);
        return mt.ref = xm(J, ve, X), mt.return = J, mt;
      }
      function L(J, ve, X, xe) {
        if (ve === null || ve.tag !== x || ve.stateNode.containerInfo !== X.containerInfo || ve.stateNode.implementation !== X.implementation) {
          var We = Hk(X, J.mode, xe);
          return We.return = J, We;
        } else {
          var Ve = h(ve, X.children || []);
          return Ve.return = J, Ve;
        }
      }
      function A(J, ve, X, xe, We) {
        if (ve === null || ve.tag !== M) {
          var Ve = dc(X, J.mode, xe, We);
          return Ve.return = J, Ve;
        } else {
          var mt = h(ve, X);
          return mt.return = J, mt;
        }
      }
      function W(J, ve, X) {
        if (typeof ve == "string" && ve !== "" || typeof ve == "number") {
          var xe = Bk("" + ve, J.mode, X);
          return xe.return = J, xe;
        }
        if (typeof ve == "object" && ve !== null) {
          switch (ve.$$typeof) {
            case za: {
              var We = Vk(ve, J.mode, X);
              return We.ref = xm(J, null, ve), We.return = J, We;
            }
            case ti: {
              var Ve = Hk(ve, J.mode, X);
              return Ve.return = J, Ve;
            }
            case dt: {
              var mt = ve._payload, Tt = ve._init;
              return W(J, Tt(mt), X);
            }
          }
          if (Vt(ve) || ni(ve)) {
            var pn = dc(ve, J.mode, X, null);
            return pn.return = J, pn;
          }
          Ey(J, ve);
        }
        return typeof ve == "function" && wy(J), null;
      }
      function $(J, ve, X, xe) {
        var We = ve !== null ? ve.key : null;
        if (typeof X == "string" && X !== "" || typeof X == "number")
          return We !== null ? null : w(J, ve, "" + X, xe);
        if (typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case za:
              return X.key === We ? _(J, ve, X, xe) : null;
            case ti:
              return X.key === We ? L(J, ve, X, xe) : null;
            case dt: {
              var Ve = X._payload, mt = X._init;
              return $(J, ve, mt(Ve), xe);
            }
          }
          if (Vt(X) || ni(X))
            return We !== null ? null : A(J, ve, X, xe, null);
          Ey(J, X);
        }
        return typeof X == "function" && wy(J), null;
      }
      function re(J, ve, X, xe, We) {
        if (typeof xe == "string" && xe !== "" || typeof xe == "number") {
          var Ve = J.get(X) || null;
          return w(ve, Ve, "" + xe, We);
        }
        if (typeof xe == "object" && xe !== null) {
          switch (xe.$$typeof) {
            case za: {
              var mt = J.get(xe.key === null ? X : xe.key) || null;
              return _(ve, mt, xe, We);
            }
            case ti: {
              var Tt = J.get(xe.key === null ? X : xe.key) || null;
              return L(ve, Tt, xe, We);
            }
            case dt:
              var pn = xe._payload, Xt = xe._init;
              return re(J, ve, X, Xt(pn), We);
          }
          if (Vt(xe) || ni(xe)) {
            var mr = J.get(X) || null;
            return A(ve, mr, xe, We, null);
          }
          Ey(ve, xe);
        }
        return typeof xe == "function" && wy(ve), null;
      }
      function le(J, ve, X) {
        {
          if (typeof J != "object" || J === null)
            return ve;
          switch (J.$$typeof) {
            case za:
            case ti:
              j1(J, X);
              var xe = J.key;
              if (typeof xe != "string")
                break;
              if (ve === null) {
                ve = /* @__PURE__ */ new Set(), ve.add(xe);
                break;
              }
              if (!ve.has(xe)) {
                ve.add(xe);
                break;
              }
              c("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", xe);
              break;
            case dt:
              var We = J._payload, Ve = J._init;
              le(Ve(We), ve, X);
              break;
          }
        }
        return ve;
      }
      function me(J, ve, X, xe) {
        for (var We = null, Ve = 0; Ve < X.length; Ve++) {
          var mt = X[Ve];
          We = le(mt, We, J);
        }
        for (var Tt = null, pn = null, Xt = ve, mr = 0, Zt = 0, ar = null; Xt !== null && Zt < X.length; Zt++) {
          Xt.index > Zt ? (ar = Xt, Xt = null) : ar = Xt.sibling;
          var zi = $(J, Xt, X[Zt], xe);
          if (zi === null) {
            Xt === null && (Xt = ar);
            break;
          }
          e && Xt && zi.alternate === null && n(J, Xt), mr = y(zi, mr, Zt), pn === null ? Tt = zi : pn.sibling = zi, pn = zi, Xt = ar;
        }
        if (Zt === X.length) {
          if (l(J, Xt), li()) {
            var mi = Zt;
            gd(J, mi);
          }
          return Tt;
        }
        if (Xt === null) {
          for (; Zt < X.length; Zt++) {
            var Qa = W(J, X[Zt], xe);
            Qa !== null && (mr = y(Qa, mr, Zt), pn === null ? Tt = Qa : pn.sibling = Qa, pn = Qa);
          }
          if (li()) {
            var aa = Zt;
            gd(J, aa);
          }
          return Tt;
        }
        for (var oa = f(J, Xt); Zt < X.length; Zt++) {
          var Vi = re(oa, J, Zt, X[Zt], xe);
          Vi !== null && (e && Vi.alternate !== null && oa.delete(Vi.key === null ? Zt : Vi.key), mr = y(Vi, mr, Zt), pn === null ? Tt = Vi : pn.sibling = Vi, pn = Vi);
        }
        if (e && oa.forEach(function(Op) {
          return n(J, Op);
        }), li()) {
          var ql = Zt;
          gd(J, ql);
        }
        return Tt;
      }
      function ze(J, ve, X, xe) {
        var We = ni(X);
        if (typeof We != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          X[Symbol.toStringTag] === "Generator" && ($S || c("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), $S = !0), X.entries === We && (HS || c("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), HS = !0);
          var Ve = We.call(X);
          if (Ve)
            for (var mt = null, Tt = Ve.next(); !Tt.done; Tt = Ve.next()) {
              var pn = Tt.value;
              mt = le(pn, mt, J);
            }
        }
        var Xt = We.call(X);
        if (Xt == null)
          throw new Error("An iterable object provided no iterator.");
        for (var mr = null, Zt = null, ar = ve, zi = 0, mi = 0, Qa = null, aa = Xt.next(); ar !== null && !aa.done; mi++, aa = Xt.next()) {
          ar.index > mi ? (Qa = ar, ar = null) : Qa = ar.sibling;
          var oa = $(J, ar, aa.value, xe);
          if (oa === null) {
            ar === null && (ar = Qa);
            break;
          }
          e && ar && oa.alternate === null && n(J, ar), zi = y(oa, zi, mi), Zt === null ? mr = oa : Zt.sibling = oa, Zt = oa, ar = Qa;
        }
        if (aa.done) {
          if (l(J, ar), li()) {
            var Vi = mi;
            gd(J, Vi);
          }
          return mr;
        }
        if (ar === null) {
          for (; !aa.done; mi++, aa = Xt.next()) {
            var ql = W(J, aa.value, xe);
            ql !== null && (zi = y(ql, zi, mi), Zt === null ? mr = ql : Zt.sibling = ql, Zt = ql);
          }
          if (li()) {
            var Op = mi;
            gd(J, Op);
          }
          return mr;
        }
        for (var ov = f(J, ar); !aa.done; mi++, aa = Xt.next()) {
          var Js = re(ov, J, mi, aa.value, xe);
          Js !== null && (e && Js.alternate !== null && ov.delete(Js.key === null ? mi : Js.key), zi = y(Js, zi, mi), Zt === null ? mr = Js : Zt.sibling = Js, Zt = Js);
        }
        if (e && ov.forEach(function(e5) {
          return n(J, e5);
        }), li()) {
          var ZI = mi;
          gd(J, ZI);
        }
        return mr;
      }
      function ut(J, ve, X, xe) {
        if (ve !== null && ve.tag === N) {
          l(J, ve.sibling);
          var We = h(ve, X);
          return We.return = J, We;
        }
        l(J, ve);
        var Ve = Bk(X, J.mode, xe);
        return Ve.return = J, Ve;
      }
      function it(J, ve, X, xe) {
        for (var We = X.key, Ve = ve; Ve !== null; ) {
          if (Ve.key === We) {
            var mt = X.type;
            if (mt === Ki) {
              if (Ve.tag === M) {
                l(J, Ve.sibling);
                var Tt = h(Ve, X.props.children);
                return Tt.return = J, Tt._debugSource = X._source, Tt._debugOwner = X._owner, Tt;
              }
            } else if (Ve.elementType === mt || // Keep this check inline so it only runs on the false path:
            WR(Ve, X) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof mt == "object" && mt !== null && mt.$$typeof === dt && z1(mt) === Ve.type) {
              l(J, Ve.sibling);
              var pn = h(Ve, X.props);
              return pn.ref = xm(J, Ve, X), pn.return = J, pn._debugSource = X._source, pn._debugOwner = X._owner, pn;
            }
            l(J, Ve);
            break;
          } else
            n(J, Ve);
          Ve = Ve.sibling;
        }
        if (X.type === Ki) {
          var Xt = dc(X.props.children, J.mode, xe, X.key);
          return Xt.return = J, Xt;
        } else {
          var mr = Vk(X, J.mode, xe);
          return mr.ref = xm(J, ve, X), mr.return = J, mr;
        }
      }
      function qt(J, ve, X, xe) {
        for (var We = X.key, Ve = ve; Ve !== null; ) {
          if (Ve.key === We)
            if (Ve.tag === x && Ve.stateNode.containerInfo === X.containerInfo && Ve.stateNode.implementation === X.implementation) {
              l(J, Ve.sibling);
              var mt = h(Ve, X.children || []);
              return mt.return = J, mt;
            } else {
              l(J, Ve);
              break;
            }
          else
            n(J, Ve);
          Ve = Ve.sibling;
        }
        var Tt = Hk(X, J.mode, xe);
        return Tt.return = J, Tt;
      }
      function Ut(J, ve, X, xe) {
        var We = typeof X == "object" && X !== null && X.type === Ki && X.key === null;
        if (We && (X = X.props.children), typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case za:
              return k(it(J, ve, X, xe));
            case ti:
              return k(qt(J, ve, X, xe));
            case dt:
              var Ve = X._payload, mt = X._init;
              return Ut(J, ve, mt(Ve), xe);
          }
          if (Vt(X))
            return me(J, ve, X, xe);
          if (ni(X))
            return ze(J, ve, X, xe);
          Ey(J, X);
        }
        return typeof X == "string" && X !== "" || typeof X == "number" ? k(ut(J, ve, "" + X, xe)) : (typeof X == "function" && wy(J), l(J, ve));
      }
      return Ut;
    }
    var pp = V1(!0), B1 = V1(!1);
    function PL(e, n) {
      if (e !== null && n.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (n.child !== null) {
        var l = n.child, f = Dd(l, l.pendingProps);
        for (n.child = f, f.return = n; l.sibling !== null; )
          l = l.sibling, f = f.sibling = Dd(l, l.pendingProps), f.return = n;
        f.sibling = null;
      }
    }
    function DL(e, n) {
      for (var l = e.child; l !== null; )
        gI(l, n), l = l.sibling;
    }
    var YS = Ju(null), KS;
    KS = {};
    var Ry = null, hp = null, QS = null, _y = !1;
    function xy() {
      Ry = null, hp = null, QS = null, _y = !1;
    }
    function H1() {
      _y = !0;
    }
    function $1() {
      _y = !1;
    }
    function q1(e, n, l) {
      Fi(YS, n._currentValue, e), n._currentValue = l, n._currentRenderer !== void 0 && n._currentRenderer !== null && n._currentRenderer !== KS && c("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), n._currentRenderer = KS;
    }
    function JS(e, n) {
      var l = YS.current;
      Ui(YS, n), e._currentValue = l;
    }
    function XS(e, n, l) {
      for (var f = e; f !== null; ) {
        var h = f.alternate;
        if (Rl(f.childLanes, n) ? h !== null && !Rl(h.childLanes, n) && (h.childLanes = Et(h.childLanes, n)) : (f.childLanes = Et(f.childLanes, n), h !== null && (h.childLanes = Et(h.childLanes, n))), f === l)
          break;
        f = f.return;
      }
      f !== l && c("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function OL(e, n, l) {
      ML(e, n, l);
    }
    function ML(e, n, l) {
      var f = e.child;
      for (f !== null && (f.return = e); f !== null; ) {
        var h = void 0, y = f.dependencies;
        if (y !== null) {
          h = f.child;
          for (var k = y.firstContext; k !== null; ) {
            if (k.context === n) {
              if (f.tag === b) {
                var w = Mu(l), _ = jl(Sn, w);
                _.tag = Dy;
                var L = f.updateQueue;
                if (L !== null) {
                  var A = L.shared, W = A.pending;
                  W === null ? _.next = _ : (_.next = W.next, W.next = _), A.pending = _;
                }
              }
              f.lanes = Et(f.lanes, l);
              var $ = f.alternate;
              $ !== null && ($.lanes = Et($.lanes, l)), XS(f.return, l, e), y.lanes = Et(y.lanes, l);
              break;
            }
            k = k.next;
          }
        } else if (f.tag === ae)
          h = f.type === e.type ? null : f.child;
        else if (f.tag === ye) {
          var re = f.return;
          if (re === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          re.lanes = Et(re.lanes, l);
          var le = re.alternate;
          le !== null && (le.lanes = Et(le.lanes, l)), XS(re, l, e), h = f.sibling;
        } else
          h = f.child;
        if (h !== null)
          h.return = f;
        else
          for (h = f; h !== null; ) {
            if (h === e) {
              h = null;
              break;
            }
            var me = h.sibling;
            if (me !== null) {
              me.return = h.return, h = me;
              break;
            }
            h = h.return;
          }
        f = h;
      }
    }
    function mp(e, n) {
      Ry = e, hp = null, QS = null;
      var l = e.dependencies;
      if (l !== null) {
        var f = l.firstContext;
        f !== null && (Ai(l.lanes, n) && Hm(), l.firstContext = null);
      }
    }
    function _r(e) {
      _y && c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var n = e._currentValue;
      if (QS !== e) {
        var l = {
          context: e,
          memoizedValue: n,
          next: null
        };
        if (hp === null) {
          if (Ry === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          hp = l, Ry.dependencies = {
            lanes: Se,
            firstContext: l
          };
        } else
          hp = hp.next = l;
      }
      return n;
    }
    var kd = null;
    function ZS(e) {
      kd === null ? kd = [e] : kd.push(e);
    }
    function NL() {
      if (kd !== null) {
        for (var e = 0; e < kd.length; e++) {
          var n = kd[e], l = n.interleaved;
          if (l !== null) {
            n.interleaved = null;
            var f = l.next, h = n.pending;
            if (h !== null) {
              var y = h.next;
              h.next = f, l.next = y;
            }
            n.pending = l;
          }
        }
        kd = null;
      }
    }
    function W1(e, n, l, f) {
      var h = n.interleaved;
      return h === null ? (l.next = l, ZS(n)) : (l.next = h.next, h.next = l), n.interleaved = l, Py(e, f);
    }
    function LL(e, n, l, f) {
      var h = n.interleaved;
      h === null ? (l.next = l, ZS(n)) : (l.next = h.next, h.next = l), n.interleaved = l;
    }
    function AL(e, n, l, f) {
      var h = n.interleaved;
      return h === null ? (l.next = l, ZS(n)) : (l.next = h.next, h.next = l), n.interleaved = l, Py(e, f);
    }
    function _a(e, n) {
      return Py(e, n);
    }
    var IL = Py;
    function Py(e, n) {
      e.lanes = Et(e.lanes, n);
      var l = e.alternate;
      l !== null && (l.lanes = Et(l.lanes, n)), l === null && (e.flags & (Tn | ma)) !== st && BR(e);
      for (var f = e, h = e.return; h !== null; )
        h.childLanes = Et(h.childLanes, n), l = h.alternate, l !== null ? l.childLanes = Et(l.childLanes, n) : (h.flags & (Tn | ma)) !== st && BR(e), f = h, h = h.return;
      if (f.tag === E) {
        var y = f.stateNode;
        return y;
      } else
        return null;
    }
    var G1 = 0, Y1 = 1, Dy = 2, eC = 3, Oy = !1, tC, My;
    tC = !1, My = null;
    function nC(e) {
      var n = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Se
        },
        effects: null
      };
      e.updateQueue = n;
    }
    function K1(e, n) {
      var l = n.updateQueue, f = e.updateQueue;
      if (l === f) {
        var h = {
          baseState: f.baseState,
          firstBaseUpdate: f.firstBaseUpdate,
          lastBaseUpdate: f.lastBaseUpdate,
          shared: f.shared,
          effects: f.effects
        };
        n.updateQueue = h;
      }
    }
    function jl(e, n) {
      var l = {
        eventTime: e,
        lane: n,
        tag: G1,
        payload: null,
        callback: null,
        next: null
      };
      return l;
    }
    function tc(e, n, l) {
      var f = e.updateQueue;
      if (f === null)
        return null;
      var h = f.shared;
      if (My === h && !tC && (c("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), tC = !0), LA()) {
        var y = h.pending;
        return y === null ? n.next = n : (n.next = y.next, y.next = n), h.pending = n, IL(e, l);
      } else
        return AL(e, h, n, l);
    }
    function Ny(e, n, l) {
      var f = n.updateQueue;
      if (f !== null) {
        var h = f.shared;
        if (Hh(l)) {
          var y = h.lanes;
          y = Mf(y, e.pendingLanes);
          var k = Et(y, l);
          h.lanes = k, $h(e, k);
        }
      }
    }
    function rC(e, n) {
      var l = e.updateQueue, f = e.alternate;
      if (f !== null) {
        var h = f.updateQueue;
        if (l === h) {
          var y = null, k = null, w = l.firstBaseUpdate;
          if (w !== null) {
            var _ = w;
            do {
              var L = {
                eventTime: _.eventTime,
                lane: _.lane,
                tag: _.tag,
                payload: _.payload,
                callback: _.callback,
                next: null
              };
              k === null ? y = k = L : (k.next = L, k = L), _ = _.next;
            } while (_ !== null);
            k === null ? y = k = n : (k.next = n, k = n);
          } else
            y = k = n;
          l = {
            baseState: h.baseState,
            firstBaseUpdate: y,
            lastBaseUpdate: k,
            shared: h.shared,
            effects: h.effects
          }, e.updateQueue = l;
          return;
        }
      }
      var A = l.lastBaseUpdate;
      A === null ? l.firstBaseUpdate = n : A.next = n, l.lastBaseUpdate = n;
    }
    function UL(e, n, l, f, h, y) {
      switch (l.tag) {
        case Y1: {
          var k = l.payload;
          if (typeof k == "function") {
            H1();
            var w = k.call(y, f, h);
            {
              if (e.mode & At) {
                rr(!0);
                try {
                  k.call(y, f, h);
                } finally {
                  rr(!1);
                }
              }
              $1();
            }
            return w;
          }
          return k;
        }
        case eC:
          e.flags = e.flags & ~Tr | gt;
        case G1: {
          var _ = l.payload, L;
          if (typeof _ == "function") {
            H1(), L = _.call(y, f, h);
            {
              if (e.mode & At) {
                rr(!0);
                try {
                  _.call(y, f, h);
                } finally {
                  rr(!1);
                }
              }
              $1();
            }
          } else
            L = _;
          return L == null ? f : Pt({}, f, L);
        }
        case Dy:
          return Oy = !0, f;
      }
      return f;
    }
    function Ly(e, n, l, f) {
      var h = e.updateQueue;
      Oy = !1, My = h.shared;
      var y = h.firstBaseUpdate, k = h.lastBaseUpdate, w = h.shared.pending;
      if (w !== null) {
        h.shared.pending = null;
        var _ = w, L = _.next;
        _.next = null, k === null ? y = L : k.next = L, k = _;
        var A = e.alternate;
        if (A !== null) {
          var W = A.updateQueue, $ = W.lastBaseUpdate;
          $ !== k && ($ === null ? W.firstBaseUpdate = L : $.next = L, W.lastBaseUpdate = _);
        }
      }
      if (y !== null) {
        var re = h.baseState, le = Se, me = null, ze = null, ut = null, it = y;
        do {
          var qt = it.lane, Ut = it.eventTime;
          if (Rl(f, qt)) {
            if (ut !== null) {
              var ve = {
                eventTime: Ut,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ir,
                tag: it.tag,
                payload: it.payload,
                callback: it.callback,
                next: null
              };
              ut = ut.next = ve;
            }
            re = UL(e, h, it, re, n, l);
            var X = it.callback;
            if (X !== null && // If the update was already committed, we should not queue its
            // callback again.
            it.lane !== ir) {
              e.flags |= lo;
              var xe = h.effects;
              xe === null ? h.effects = [it] : xe.push(it);
            }
          } else {
            var J = {
              eventTime: Ut,
              lane: qt,
              tag: it.tag,
              payload: it.payload,
              callback: it.callback,
              next: null
            };
            ut === null ? (ze = ut = J, me = re) : ut = ut.next = J, le = Et(le, qt);
          }
          if (it = it.next, it === null) {
            if (w = h.shared.pending, w === null)
              break;
            var We = w, Ve = We.next;
            We.next = null, it = Ve, h.lastBaseUpdate = We, h.shared.pending = null;
          }
        } while (!0);
        ut === null && (me = re), h.baseState = me, h.firstBaseUpdate = ze, h.lastBaseUpdate = ut;
        var mt = h.shared.interleaved;
        if (mt !== null) {
          var Tt = mt;
          do
            le = Et(le, Tt.lane), Tt = Tt.next;
          while (Tt !== mt);
        } else
          y === null && (h.shared.lanes = Se);
        tv(le), e.lanes = le, e.memoizedState = re;
      }
      My = null;
    }
    function FL(e, n) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(n);
    }
    function Q1() {
      Oy = !1;
    }
    function Ay() {
      return Oy;
    }
    function J1(e, n, l) {
      var f = n.effects;
      if (n.effects = null, f !== null)
        for (var h = 0; h < f.length; h++) {
          var y = f[h], k = y.callback;
          k !== null && (y.callback = null, FL(k, l));
        }
    }
    var Pm = {}, nc = Ju(Pm), Dm = Ju(Pm), Iy = Ju(Pm);
    function Uy(e) {
      if (e === Pm)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function X1() {
      var e = Uy(Iy.current);
      return e;
    }
    function iC(e, n) {
      Fi(Iy, n, e), Fi(Dm, e, e), Fi(nc, Pm, e);
      var l = tN(n);
      Ui(nc, e), Fi(nc, l, e);
    }
    function vp(e) {
      Ui(nc, e), Ui(Dm, e), Ui(Iy, e);
    }
    function aC() {
      var e = Uy(nc.current);
      return e;
    }
    function Z1(e) {
      Uy(Iy.current);
      var n = Uy(nc.current), l = nN(n, e.type);
      n !== l && (Fi(Dm, e, e), Fi(nc, l, e));
    }
    function oC(e) {
      Dm.current === e && (Ui(nc, e), Ui(Dm, e));
    }
    var jL = 0, ew = 1, tw = 1, Om = 2, Yo = Ju(jL);
    function sC(e, n) {
      return (e & n) !== 0;
    }
    function gp(e) {
      return e & ew;
    }
    function lC(e, n) {
      return e & ew | n;
    }
    function zL(e, n) {
      return e | n;
    }
    function rc(e, n) {
      Fi(Yo, n, e);
    }
    function yp(e) {
      Ui(Yo, e);
    }
    function VL(e, n) {
      var l = e.memoizedState;
      return l !== null ? l.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Fy(e) {
      for (var n = e; n !== null; ) {
        if (n.tag === F) {
          var l = n.memoizedState;
          if (l !== null) {
            var f = l.dehydrated;
            if (f === null || y1(f) || RS(f))
              return n;
          }
        } else if (n.tag === se && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        n.memoizedProps.revealOrder !== void 0) {
          var h = (n.flags & gt) !== st;
          if (h)
            return n;
        } else if (n.child !== null) {
          n.child.return = n, n = n.child;
          continue;
        }
        if (n === e)
          return null;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e)
            return null;
          n = n.return;
        }
        n.sibling.return = n.return, n = n.sibling;
      }
      return null;
    }
    var xa = (
      /*   */
      0
    ), Mr = (
      /* */
      1
    ), $s = (
      /*  */
      2
    ), Nr = (
      /*    */
      4
    ), ui = (
      /*   */
      8
    ), uC = [];
    function cC() {
      for (var e = 0; e < uC.length; e++) {
        var n = uC[e];
        n._workInProgressVersionPrimary = null;
      }
      uC.length = 0;
    }
    function BL(e, n) {
      var l = n._getVersion, f = l(n._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, f] : e.mutableSourceEagerHydrationData.push(n, f);
    }
    var $e = i.ReactCurrentDispatcher, Mm = i.ReactCurrentBatchConfig, dC, bp;
    dC = /* @__PURE__ */ new Set();
    var Td = Se, fn = null, Lr = null, Ar = null, jy = !1, Nm = !1, Lm = 0, HL = 0, $L = 25, be = null, yo = null, ic = -1, fC = !1;
    function un() {
      {
        var e = be;
        yo === null ? yo = [e] : yo.push(e);
      }
    }
    function Fe() {
      {
        var e = be;
        yo !== null && (ic++, yo[ic] !== e && qL(e));
      }
    }
    function Sp(e) {
      e != null && !Vt(e) && c("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", be, typeof e);
    }
    function qL(e) {
      {
        var n = bt(fn);
        if (!dC.has(n) && (dC.add(n), yo !== null)) {
          for (var l = "", f = 30, h = 0; h <= ic; h++) {
            for (var y = yo[h], k = h === ic ? e : y, w = h + 1 + ". " + y; w.length < f; )
              w += " ";
            w += k + `
`, l += w;
          }
          c(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, n, l);
        }
      }
    }
    function ji() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function pC(e, n) {
      if (fC)
        return !1;
      if (n === null)
        return c("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", be), !1;
      e.length !== n.length && c(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, be, "[" + n.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var l = 0; l < n.length && l < e.length; l++)
        if (!Ke(e[l], n[l]))
          return !1;
      return !0;
    }
    function Cp(e, n, l, f, h, y) {
      Td = y, fn = n, yo = e !== null ? e._debugHookTypes : null, ic = -1, fC = e !== null && e.type !== n.type, n.memoizedState = null, n.updateQueue = null, n.lanes = Se, e !== null && e.memoizedState !== null ? $e.current = Tw : yo !== null ? $e.current = kw : $e.current = Cw;
      var k = l(f, h);
      if (Nm) {
        var w = 0;
        do {
          if (Nm = !1, Lm = 0, w >= $L)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          w += 1, fC = !1, Lr = null, Ar = null, n.updateQueue = null, ic = -1, $e.current = Ew, k = l(f, h);
        } while (Nm);
      }
      $e.current = Xy, n._debugHookTypes = yo;
      var _ = Lr !== null && Lr.next !== null;
      if (Td = Se, fn = null, Lr = null, Ar = null, be = null, yo = null, ic = -1, e !== null && (e.flags & Pr) !== (n.flags & Pr) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & rt) !== et && c("Internal React error: Expected static flag was missing. Please notify the React team."), jy = !1, _)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return k;
    }
    function kp() {
      var e = Lm !== 0;
      return Lm = 0, e;
    }
    function nw(e, n, l) {
      n.updateQueue = e.updateQueue, (n.mode & ea) !== et ? n.flags &= ~(gl | Pi | Pn | wt) : n.flags &= ~(Pn | wt), e.lanes = ed(e.lanes, l);
    }
    function rw() {
      if ($e.current = Xy, jy) {
        for (var e = fn.memoizedState; e !== null; ) {
          var n = e.queue;
          n !== null && (n.pending = null), e = e.next;
        }
        jy = !1;
      }
      Td = Se, fn = null, Lr = null, Ar = null, yo = null, ic = -1, be = null, vw = !1, Nm = !1, Lm = 0;
    }
    function qs() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ar === null ? fn.memoizedState = Ar = e : Ar = Ar.next = e, Ar;
    }
    function bo() {
      var e;
      if (Lr === null) {
        var n = fn.alternate;
        n !== null ? e = n.memoizedState : e = null;
      } else
        e = Lr.next;
      var l;
      if (Ar === null ? l = fn.memoizedState : l = Ar.next, l !== null)
        Ar = l, l = Ar.next, Lr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Lr = e;
        var f = {
          memoizedState: Lr.memoizedState,
          baseState: Lr.baseState,
          baseQueue: Lr.baseQueue,
          queue: Lr.queue,
          next: null
        };
        Ar === null ? fn.memoizedState = Ar = f : Ar = Ar.next = f;
      }
      return Ar;
    }
    function iw() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function hC(e, n) {
      return typeof n == "function" ? n(e) : n;
    }
    function mC(e, n, l) {
      var f = qs(), h;
      l !== void 0 ? h = l(n) : h = n, f.memoizedState = f.baseState = h;
      var y = {
        pending: null,
        interleaved: null,
        lanes: Se,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: h
      };
      f.queue = y;
      var k = y.dispatch = KL.bind(null, fn, y);
      return [f.memoizedState, k];
    }
    function vC(e, n, l) {
      var f = bo(), h = f.queue;
      if (h === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      h.lastRenderedReducer = e;
      var y = Lr, k = y.baseQueue, w = h.pending;
      if (w !== null) {
        if (k !== null) {
          var _ = k.next, L = w.next;
          k.next = L, w.next = _;
        }
        y.baseQueue !== k && c("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), y.baseQueue = k = w, h.pending = null;
      }
      if (k !== null) {
        var A = k.next, W = y.baseState, $ = null, re = null, le = null, me = A;
        do {
          var ze = me.lane;
          if (Rl(Td, ze)) {
            if (le !== null) {
              var it = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ir,
                action: me.action,
                hasEagerState: me.hasEagerState,
                eagerState: me.eagerState,
                next: null
              };
              le = le.next = it;
            }
            if (me.hasEagerState)
              W = me.eagerState;
            else {
              var qt = me.action;
              W = e(W, qt);
            }
          } else {
            var ut = {
              lane: ze,
              action: me.action,
              hasEagerState: me.hasEagerState,
              eagerState: me.eagerState,
              next: null
            };
            le === null ? (re = le = ut, $ = W) : le = le.next = ut, fn.lanes = Et(fn.lanes, ze), tv(ze);
          }
          me = me.next;
        } while (me !== null && me !== A);
        le === null ? $ = W : le.next = re, Ke(W, f.memoizedState) || Hm(), f.memoizedState = W, f.baseState = $, f.baseQueue = le, h.lastRenderedState = W;
      }
      var Ut = h.interleaved;
      if (Ut !== null) {
        var J = Ut;
        do {
          var ve = J.lane;
          fn.lanes = Et(fn.lanes, ve), tv(ve), J = J.next;
        } while (J !== Ut);
      } else
        k === null && (h.lanes = Se);
      var X = h.dispatch;
      return [f.memoizedState, X];
    }
    function gC(e, n, l) {
      var f = bo(), h = f.queue;
      if (h === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      h.lastRenderedReducer = e;
      var y = h.dispatch, k = h.pending, w = f.memoizedState;
      if (k !== null) {
        h.pending = null;
        var _ = k.next, L = _;
        do {
          var A = L.action;
          w = e(w, A), L = L.next;
        } while (L !== _);
        Ke(w, f.memoizedState) || Hm(), f.memoizedState = w, f.baseQueue === null && (f.baseState = w), h.lastRenderedState = w;
      }
      return [w, y];
    }
    function l9(e, n, l) {
    }
    function u9(e, n, l) {
    }
    function yC(e, n, l) {
      var f = fn, h = qs(), y, k = li();
      if (k) {
        if (l === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        y = l(), bp || y !== l() && (c("The result of getServerSnapshot should be cached to avoid an infinite loop"), bp = !0);
      } else {
        if (y = n(), !bp) {
          var w = n();
          Ke(y, w) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), bp = !0);
        }
        var _ = g0();
        if (_ === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Zc(_, Td) || aw(f, n, y);
      }
      h.memoizedState = y;
      var L = {
        value: y,
        getSnapshot: n
      };
      return h.queue = L, $y(sw.bind(null, f, L, e), [e]), f.flags |= Pn, Am(Mr | ui, ow.bind(null, f, L, y, n), void 0, null), y;
    }
    function zy(e, n, l) {
      var f = fn, h = bo(), y = n();
      if (!bp) {
        var k = n();
        Ke(y, k) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), bp = !0);
      }
      var w = h.memoizedState, _ = !Ke(w, y);
      _ && (h.memoizedState = y, Hm());
      var L = h.queue;
      if (Um(sw.bind(null, f, L, e), [e]), L.getSnapshot !== n || _ || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ar !== null && Ar.memoizedState.tag & Mr) {
        f.flags |= Pn, Am(Mr | ui, ow.bind(null, f, L, y, n), void 0, null);
        var A = g0();
        if (A === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Zc(A, Td) || aw(f, n, y);
      }
      return y;
    }
    function aw(e, n, l) {
      e.flags |= Hc;
      var f = {
        getSnapshot: n,
        value: l
      }, h = fn.updateQueue;
      if (h === null)
        h = iw(), fn.updateQueue = h, h.stores = [f];
      else {
        var y = h.stores;
        y === null ? h.stores = [f] : y.push(f);
      }
    }
    function ow(e, n, l, f) {
      n.value = l, n.getSnapshot = f, lw(n) && uw(e);
    }
    function sw(e, n, l) {
      var f = function() {
        lw(n) && uw(e);
      };
      return l(f);
    }
    function lw(e) {
      var n = e.getSnapshot, l = e.value;
      try {
        var f = n();
        return !Ke(l, f);
      } catch {
        return !0;
      }
    }
    function uw(e) {
      var n = _a(e, ot);
      n !== null && jr(n, e, ot, Sn);
    }
    function Vy(e) {
      var n = qs();
      typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e;
      var l = {
        pending: null,
        interleaved: null,
        lanes: Se,
        dispatch: null,
        lastRenderedReducer: hC,
        lastRenderedState: e
      };
      n.queue = l;
      var f = l.dispatch = QL.bind(null, fn, l);
      return [n.memoizedState, f];
    }
    function bC(e) {
      return vC(hC);
    }
    function SC(e) {
      return gC(hC);
    }
    function Am(e, n, l, f) {
      var h = {
        tag: e,
        create: n,
        destroy: l,
        deps: f,
        // Circular
        next: null
      }, y = fn.updateQueue;
      if (y === null)
        y = iw(), fn.updateQueue = y, y.lastEffect = h.next = h;
      else {
        var k = y.lastEffect;
        if (k === null)
          y.lastEffect = h.next = h;
        else {
          var w = k.next;
          k.next = h, h.next = w, y.lastEffect = h;
        }
      }
      return h;
    }
    function CC(e) {
      var n = qs();
      {
        var l = {
          current: e
        };
        return n.memoizedState = l, l;
      }
    }
    function By(e) {
      var n = bo();
      return n.memoizedState;
    }
    function Im(e, n, l, f) {
      var h = qs(), y = f === void 0 ? null : f;
      fn.flags |= e, h.memoizedState = Am(Mr | n, l, void 0, y);
    }
    function Hy(e, n, l, f) {
      var h = bo(), y = f === void 0 ? null : f, k = void 0;
      if (Lr !== null) {
        var w = Lr.memoizedState;
        if (k = w.destroy, y !== null) {
          var _ = w.deps;
          if (pC(y, _)) {
            h.memoizedState = Am(n, l, k, y);
            return;
          }
        }
      }
      fn.flags |= e, h.memoizedState = Am(Mr | n, l, k, y);
    }
    function $y(e, n) {
      return (fn.mode & ea) !== et ? Im(gl | Pn | Ms, ui, e, n) : Im(Pn | Ms, ui, e, n);
    }
    function Um(e, n) {
      return Hy(Pn, ui, e, n);
    }
    function kC(e, n) {
      return Im(wt, $s, e, n);
    }
    function qy(e, n) {
      return Hy(wt, $s, e, n);
    }
    function TC(e, n) {
      var l = wt;
      return l |= xi, (fn.mode & ea) !== et && (l |= Pi), Im(l, Nr, e, n);
    }
    function Wy(e, n) {
      return Hy(wt, Nr, e, n);
    }
    function cw(e, n) {
      if (typeof n == "function") {
        var l = n, f = e();
        return l(f), function() {
          l(null);
        };
      } else if (n != null) {
        var h = n;
        h.hasOwnProperty("current") || c("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(h).join(", ") + "}");
        var y = e();
        return h.current = y, function() {
          h.current = null;
        };
      }
    }
    function EC(e, n, l) {
      typeof n != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", n !== null ? typeof n : "null");
      var f = l != null ? l.concat([e]) : null, h = wt;
      return h |= xi, (fn.mode & ea) !== et && (h |= Pi), Im(h, Nr, cw.bind(null, n, e), f);
    }
    function Gy(e, n, l) {
      typeof n != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", n !== null ? typeof n : "null");
      var f = l != null ? l.concat([e]) : null;
      return Hy(wt, Nr, cw.bind(null, n, e), f);
    }
    function WL(e, n) {
    }
    var Yy = WL;
    function wC(e, n) {
      var l = qs(), f = n === void 0 ? null : n;
      return l.memoizedState = [e, f], e;
    }
    function Ky(e, n) {
      var l = bo(), f = n === void 0 ? null : n, h = l.memoizedState;
      if (h !== null && f !== null) {
        var y = h[1];
        if (pC(f, y))
          return h[0];
      }
      return l.memoizedState = [e, f], e;
    }
    function RC(e, n) {
      var l = qs(), f = n === void 0 ? null : n, h = e();
      return l.memoizedState = [h, f], h;
    }
    function Qy(e, n) {
      var l = bo(), f = n === void 0 ? null : n, h = l.memoizedState;
      if (h !== null && f !== null) {
        var y = h[1];
        if (pC(f, y))
          return h[0];
      }
      var k = e();
      return l.memoizedState = [k, f], k;
    }
    function _C(e) {
      var n = qs();
      return n.memoizedState = e, e;
    }
    function dw(e) {
      var n = bo(), l = Lr, f = l.memoizedState;
      return pw(n, f, e);
    }
    function fw(e) {
      var n = bo();
      if (Lr === null)
        return n.memoizedState = e, e;
      var l = Lr.memoizedState;
      return pw(n, l, e);
    }
    function pw(e, n, l) {
      var f = !Rg(Td);
      if (f) {
        if (!Ke(l, n)) {
          var h = Pg();
          fn.lanes = Et(fn.lanes, h), tv(h), e.baseState = !0;
        }
        return n;
      } else
        return e.baseState && (e.baseState = !1, Hm()), e.memoizedState = l, l;
    }
    function GL(e, n, l) {
      var f = Ca();
      Hn(Gb(f, Vo)), e(!0);
      var h = Mm.transition;
      Mm.transition = {};
      var y = Mm.transition;
      Mm.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), n();
      } finally {
        if (Hn(f), Mm.transition = h, h === null && y._updatedFibers) {
          var k = y._updatedFibers.size;
          k > 10 && d("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), y._updatedFibers.clear();
        }
      }
    }
    function xC() {
      var e = Vy(!1), n = e[0], l = e[1], f = GL.bind(null, l), h = qs();
      return h.memoizedState = f, [n, f];
    }
    function hw() {
      var e = bC(), n = e[0], l = bo(), f = l.memoizedState;
      return [n, f];
    }
    function mw() {
      var e = SC(), n = e[0], l = bo(), f = l.memoizedState;
      return [n, f];
    }
    var vw = !1;
    function YL() {
      return vw;
    }
    function PC() {
      var e = qs(), n = g0(), l = n.identifierPrefix, f;
      if (li()) {
        var h = dL();
        f = ":" + l + "R" + h;
        var y = Lm++;
        y > 0 && (f += "H" + y.toString(32)), f += ":";
      } else {
        var k = HL++;
        f = ":" + l + "r" + k.toString(32) + ":";
      }
      return e.memoizedState = f, f;
    }
    function Jy() {
      var e = bo(), n = e.memoizedState;
      return n;
    }
    function KL(e, n, l) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var f = uc(e), h = {
        lane: f,
        action: l,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (gw(e))
        yw(n, h);
      else {
        var y = W1(e, n, h, f);
        if (y !== null) {
          var k = ia();
          jr(y, e, f, k), bw(y, n, f);
        }
      }
      Sw(e, f);
    }
    function QL(e, n, l) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var f = uc(e), h = {
        lane: f,
        action: l,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (gw(e))
        yw(n, h);
      else {
        var y = e.alternate;
        if (e.lanes === Se && (y === null || y.lanes === Se)) {
          var k = n.lastRenderedReducer;
          if (k !== null) {
            var w;
            w = $e.current, $e.current = Ko;
            try {
              var _ = n.lastRenderedState, L = k(_, l);
              if (h.hasEagerState = !0, h.eagerState = L, Ke(L, _)) {
                LL(e, n, h, f);
                return;
              }
            } catch {
            } finally {
              $e.current = w;
            }
          }
        }
        var A = W1(e, n, h, f);
        if (A !== null) {
          var W = ia();
          jr(A, e, f, W), bw(A, n, f);
        }
      }
      Sw(e, f);
    }
    function gw(e) {
      var n = e.alternate;
      return e === fn || n !== null && n === fn;
    }
    function yw(e, n) {
      Nm = jy = !0;
      var l = e.pending;
      l === null ? n.next = n : (n.next = l.next, l.next = n), e.pending = n;
    }
    function bw(e, n, l) {
      if (Hh(l)) {
        var f = n.lanes;
        f = Mf(f, e.pendingLanes);
        var h = Et(f, l);
        n.lanes = h, $h(e, h);
      }
    }
    function Sw(e, n, l) {
      Gc(e, n);
    }
    var Xy = {
      readContext: _r,
      useCallback: ji,
      useContext: ji,
      useEffect: ji,
      useImperativeHandle: ji,
      useInsertionEffect: ji,
      useLayoutEffect: ji,
      useMemo: ji,
      useReducer: ji,
      useRef: ji,
      useState: ji,
      useDebugValue: ji,
      useDeferredValue: ji,
      useTransition: ji,
      useMutableSource: ji,
      useSyncExternalStore: ji,
      useId: ji,
      unstable_isNewReconciler: Pe
    }, Cw = null, kw = null, Tw = null, Ew = null, Ws = null, Ko = null, Zy = null;
    {
      var DC = function() {
        c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, St = function() {
        c("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Cw = {
        readContext: function(e) {
          return _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", un(), Sp(n), wC(e, n);
        },
        useContext: function(e) {
          return be = "useContext", un(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", un(), Sp(n), $y(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", un(), Sp(l), EC(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", un(), Sp(n), kC(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", un(), Sp(n), TC(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", un(), Sp(n);
          var l = $e.current;
          $e.current = Ws;
          try {
            return RC(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", un();
          var f = $e.current;
          $e.current = Ws;
          try {
            return mC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", un(), CC(e);
        },
        useState: function(e) {
          be = "useState", un();
          var n = $e.current;
          $e.current = Ws;
          try {
            return Vy(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", un(), void 0;
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", un(), _C(e);
        },
        useTransition: function() {
          return be = "useTransition", un(), xC();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", un(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", un(), yC(e, n, l);
        },
        useId: function() {
          return be = "useId", un(), PC();
        },
        unstable_isNewReconciler: Pe
      }, kw = {
        readContext: function(e) {
          return _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", Fe(), wC(e, n);
        },
        useContext: function(e) {
          return be = "useContext", Fe(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", Fe(), $y(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", Fe(), EC(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", Fe(), kC(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", Fe(), TC(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", Fe();
          var l = $e.current;
          $e.current = Ws;
          try {
            return RC(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", Fe();
          var f = $e.current;
          $e.current = Ws;
          try {
            return mC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", Fe(), CC(e);
        },
        useState: function(e) {
          be = "useState", Fe();
          var n = $e.current;
          $e.current = Ws;
          try {
            return Vy(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", Fe(), void 0;
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", Fe(), _C(e);
        },
        useTransition: function() {
          return be = "useTransition", Fe(), xC();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", Fe(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", Fe(), yC(e, n, l);
        },
        useId: function() {
          return be = "useId", Fe(), PC();
        },
        unstable_isNewReconciler: Pe
      }, Tw = {
        readContext: function(e) {
          return _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", Fe(), Ky(e, n);
        },
        useContext: function(e) {
          return be = "useContext", Fe(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", Fe(), Um(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", Fe(), Gy(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", Fe(), qy(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", Fe(), Wy(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", Fe();
          var l = $e.current;
          $e.current = Ko;
          try {
            return Qy(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", Fe();
          var f = $e.current;
          $e.current = Ko;
          try {
            return vC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", Fe(), By();
        },
        useState: function(e) {
          be = "useState", Fe();
          var n = $e.current;
          $e.current = Ko;
          try {
            return bC(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", Fe(), Yy();
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", Fe(), dw(e);
        },
        useTransition: function() {
          return be = "useTransition", Fe(), hw();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", Fe(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", Fe(), zy(e, n);
        },
        useId: function() {
          return be = "useId", Fe(), Jy();
        },
        unstable_isNewReconciler: Pe
      }, Ew = {
        readContext: function(e) {
          return _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", Fe(), Ky(e, n);
        },
        useContext: function(e) {
          return be = "useContext", Fe(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", Fe(), Um(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", Fe(), Gy(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", Fe(), qy(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", Fe(), Wy(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", Fe();
          var l = $e.current;
          $e.current = Zy;
          try {
            return Qy(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", Fe();
          var f = $e.current;
          $e.current = Zy;
          try {
            return gC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", Fe(), By();
        },
        useState: function(e) {
          be = "useState", Fe();
          var n = $e.current;
          $e.current = Zy;
          try {
            return SC(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", Fe(), Yy();
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", Fe(), fw(e);
        },
        useTransition: function() {
          return be = "useTransition", Fe(), mw();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", Fe(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", Fe(), zy(e, n);
        },
        useId: function() {
          return be = "useId", Fe(), Jy();
        },
        unstable_isNewReconciler: Pe
      }, Ws = {
        readContext: function(e) {
          return DC(), _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", St(), un(), wC(e, n);
        },
        useContext: function(e) {
          return be = "useContext", St(), un(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", St(), un(), $y(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", St(), un(), EC(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", St(), un(), kC(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", St(), un(), TC(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", St(), un();
          var l = $e.current;
          $e.current = Ws;
          try {
            return RC(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", St(), un();
          var f = $e.current;
          $e.current = Ws;
          try {
            return mC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", St(), un(), CC(e);
        },
        useState: function(e) {
          be = "useState", St(), un();
          var n = $e.current;
          $e.current = Ws;
          try {
            return Vy(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", St(), un(), void 0;
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", St(), un(), _C(e);
        },
        useTransition: function() {
          return be = "useTransition", St(), un(), xC();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", St(), un(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", St(), un(), yC(e, n, l);
        },
        useId: function() {
          return be = "useId", St(), un(), PC();
        },
        unstable_isNewReconciler: Pe
      }, Ko = {
        readContext: function(e) {
          return DC(), _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", St(), Fe(), Ky(e, n);
        },
        useContext: function(e) {
          return be = "useContext", St(), Fe(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", St(), Fe(), Um(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", St(), Fe(), Gy(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", St(), Fe(), qy(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", St(), Fe(), Wy(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", St(), Fe();
          var l = $e.current;
          $e.current = Ko;
          try {
            return Qy(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", St(), Fe();
          var f = $e.current;
          $e.current = Ko;
          try {
            return vC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", St(), Fe(), By();
        },
        useState: function(e) {
          be = "useState", St(), Fe();
          var n = $e.current;
          $e.current = Ko;
          try {
            return bC(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", St(), Fe(), Yy();
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", St(), Fe(), dw(e);
        },
        useTransition: function() {
          return be = "useTransition", St(), Fe(), hw();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", St(), Fe(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", St(), Fe(), zy(e, n);
        },
        useId: function() {
          return be = "useId", St(), Fe(), Jy();
        },
        unstable_isNewReconciler: Pe
      }, Zy = {
        readContext: function(e) {
          return DC(), _r(e);
        },
        useCallback: function(e, n) {
          return be = "useCallback", St(), Fe(), Ky(e, n);
        },
        useContext: function(e) {
          return be = "useContext", St(), Fe(), _r(e);
        },
        useEffect: function(e, n) {
          return be = "useEffect", St(), Fe(), Um(e, n);
        },
        useImperativeHandle: function(e, n, l) {
          return be = "useImperativeHandle", St(), Fe(), Gy(e, n, l);
        },
        useInsertionEffect: function(e, n) {
          return be = "useInsertionEffect", St(), Fe(), qy(e, n);
        },
        useLayoutEffect: function(e, n) {
          return be = "useLayoutEffect", St(), Fe(), Wy(e, n);
        },
        useMemo: function(e, n) {
          be = "useMemo", St(), Fe();
          var l = $e.current;
          $e.current = Ko;
          try {
            return Qy(e, n);
          } finally {
            $e.current = l;
          }
        },
        useReducer: function(e, n, l) {
          be = "useReducer", St(), Fe();
          var f = $e.current;
          $e.current = Ko;
          try {
            return gC(e, n, l);
          } finally {
            $e.current = f;
          }
        },
        useRef: function(e) {
          return be = "useRef", St(), Fe(), By();
        },
        useState: function(e) {
          be = "useState", St(), Fe();
          var n = $e.current;
          $e.current = Ko;
          try {
            return SC(e);
          } finally {
            $e.current = n;
          }
        },
        useDebugValue: function(e, n) {
          return be = "useDebugValue", St(), Fe(), Yy();
        },
        useDeferredValue: function(e) {
          return be = "useDeferredValue", St(), Fe(), fw(e);
        },
        useTransition: function() {
          return be = "useTransition", St(), Fe(), mw();
        },
        useMutableSource: function(e, n, l) {
          return be = "useMutableSource", St(), Fe(), void 0;
        },
        useSyncExternalStore: function(e, n, l) {
          return be = "useSyncExternalStore", St(), Fe(), zy(e, n);
        },
        useId: function() {
          return be = "useId", St(), Fe(), Jy();
        },
        unstable_isNewReconciler: Pe
      };
    }
    var ac = t.unstable_now, ww = 0, e0 = -1, Fm = -1, t0 = -1, OC = !1, n0 = !1;
    function Rw() {
      return OC;
    }
    function JL() {
      n0 = !0;
    }
    function XL() {
      OC = !1, n0 = !1;
    }
    function ZL() {
      OC = n0, n0 = !1;
    }
    function _w() {
      return ww;
    }
    function xw() {
      ww = ac();
    }
    function MC(e) {
      Fm = ac(), e.actualStartTime < 0 && (e.actualStartTime = ac());
    }
    function Pw(e) {
      Fm = -1;
    }
    function r0(e, n) {
      if (Fm >= 0) {
        var l = ac() - Fm;
        e.actualDuration += l, n && (e.selfBaseDuration = l), Fm = -1;
      }
    }
    function Gs(e) {
      if (e0 >= 0) {
        var n = ac() - e0;
        e0 = -1;
        for (var l = e.return; l !== null; ) {
          switch (l.tag) {
            case E:
              var f = l.stateNode;
              f.effectDuration += n;
              return;
            case B:
              var h = l.stateNode;
              h.effectDuration += n;
              return;
          }
          l = l.return;
        }
      }
    }
    function NC(e) {
      if (t0 >= 0) {
        var n = ac() - t0;
        t0 = -1;
        for (var l = e.return; l !== null; ) {
          switch (l.tag) {
            case E:
              var f = l.stateNode;
              f !== null && (f.passiveEffectDuration += n);
              return;
            case B:
              var h = l.stateNode;
              h !== null && (h.passiveEffectDuration += n);
              return;
          }
          l = l.return;
        }
      }
    }
    function Ys() {
      e0 = ac();
    }
    function LC() {
      t0 = ac();
    }
    function AC(e) {
      for (var n = e.child; n; )
        e.actualDuration += n.actualDuration, n = n.sibling;
    }
    function Qo(e, n) {
      if (e && e.defaultProps) {
        var l = Pt({}, n), f = e.defaultProps;
        for (var h in f)
          l[h] === void 0 && (l[h] = f[h]);
        return l;
      }
      return n;
    }
    var IC = {}, UC, FC, jC, zC, VC, Dw, i0, BC, HC, $C, jm;
    {
      UC = /* @__PURE__ */ new Set(), FC = /* @__PURE__ */ new Set(), jC = /* @__PURE__ */ new Set(), zC = /* @__PURE__ */ new Set(), BC = /* @__PURE__ */ new Set(), VC = /* @__PURE__ */ new Set(), HC = /* @__PURE__ */ new Set(), $C = /* @__PURE__ */ new Set(), jm = /* @__PURE__ */ new Set();
      var Ow = /* @__PURE__ */ new Set();
      i0 = function(e, n) {
        if (!(e === null || typeof e == "function")) {
          var l = n + "_" + e;
          Ow.has(l) || (Ow.add(l), c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", n, e));
        }
      }, Dw = function(e, n) {
        if (n === void 0) {
          var l = zt(e) || "Component";
          VC.has(l) || (VC.add(l), c("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", l));
        }
      }, Object.defineProperty(IC, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(IC);
    }
    function qC(e, n, l, f) {
      var h = e.memoizedState, y = l(f, h);
      {
        if (e.mode & At) {
          rr(!0);
          try {
            y = l(f, h);
          } finally {
            rr(!1);
          }
        }
        Dw(n, y);
      }
      var k = y == null ? h : Pt({}, h, y);
      if (e.memoizedState = k, e.lanes === Se) {
        var w = e.updateQueue;
        w.baseState = k;
      }
    }
    var WC = {
      isMounted: Xi,
      enqueueSetState: function(e, n, l) {
        var f = pa(e), h = ia(), y = uc(f), k = jl(h, y);
        k.payload = n, l != null && (i0(l, "setState"), k.callback = l);
        var w = tc(f, k, y);
        w !== null && (jr(w, f, y, h), Ny(w, f, y)), Gc(f, y);
      },
      enqueueReplaceState: function(e, n, l) {
        var f = pa(e), h = ia(), y = uc(f), k = jl(h, y);
        k.tag = Y1, k.payload = n, l != null && (i0(l, "replaceState"), k.callback = l);
        var w = tc(f, k, y);
        w !== null && (jr(w, f, y, h), Ny(w, f, y)), Gc(f, y);
      },
      enqueueForceUpdate: function(e, n) {
        var l = pa(e), f = ia(), h = uc(l), y = jl(f, h);
        y.tag = Dy, n != null && (i0(n, "forceUpdate"), y.callback = n);
        var k = tc(l, y, h);
        k !== null && (jr(k, l, h, f), Ny(k, l, h)), mf(l, h);
      }
    };
    function Mw(e, n, l, f, h, y, k) {
      var w = e.stateNode;
      if (typeof w.shouldComponentUpdate == "function") {
        var _ = w.shouldComponentUpdate(f, y, k);
        {
          if (e.mode & At) {
            rr(!0);
            try {
              _ = w.shouldComponentUpdate(f, y, k);
            } finally {
              rr(!1);
            }
          }
          _ === void 0 && c("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", zt(n) || "Component");
        }
        return _;
      }
      return n.prototype && n.prototype.isPureReactComponent ? !ht(l, f) || !ht(h, y) : !0;
    }
    function e2(e, n, l) {
      var f = e.stateNode;
      {
        var h = zt(n) || "Component", y = f.render;
        y || (n.prototype && typeof n.prototype.render == "function" ? c("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", h) : c("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", h)), f.getInitialState && !f.getInitialState.isReactClassApproved && !f.state && c("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", h), f.getDefaultProps && !f.getDefaultProps.isReactClassApproved && c("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", h), f.propTypes && c("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", h), f.contextType && c("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", h), n.childContextTypes && !jm.has(n) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (e.mode & At) === et && (jm.add(n), c(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, h)), n.contextTypes && !jm.has(n) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (e.mode & At) === et && (jm.add(n), c(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, h)), f.contextTypes && c("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", h), n.contextType && n.contextTypes && !HC.has(n) && (HC.add(n), c("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", h)), typeof f.componentShouldUpdate == "function" && c("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", h), n.prototype && n.prototype.isPureReactComponent && typeof f.shouldComponentUpdate < "u" && c("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", zt(n) || "A pure component"), typeof f.componentDidUnmount == "function" && c("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", h), typeof f.componentDidReceiveProps == "function" && c("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", h), typeof f.componentWillRecieveProps == "function" && c("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", h), typeof f.UNSAFE_componentWillRecieveProps == "function" && c("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", h);
        var k = f.props !== l;
        f.props !== void 0 && k && c("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", h, h), f.defaultProps && c("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", h, h), typeof f.getSnapshotBeforeUpdate == "function" && typeof f.componentDidUpdate != "function" && !jC.has(n) && (jC.add(n), c("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", zt(n))), typeof f.getDerivedStateFromProps == "function" && c("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", h), typeof f.getDerivedStateFromError == "function" && c("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", h), typeof n.getSnapshotBeforeUpdate == "function" && c("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", h);
        var w = f.state;
        w && (typeof w != "object" || Vt(w)) && c("%s.state: must be set to an object or null", h), typeof f.getChildContext == "function" && typeof n.childContextTypes != "object" && c("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", h);
      }
    }
    function Nw(e, n) {
      n.updater = WC, e.stateNode = n, yu(n, e), n._reactInternalInstance = IC;
    }
    function Lw(e, n, l) {
      var f = !1, h = Ya, y = Ya, k = n.contextType;
      if ("contextType" in n) {
        var w = (
          // Allow null for conditional declaration
          k === null || k !== void 0 && k.$$typeof === ke && k._context === void 0
        );
        if (!w && !$C.has(n)) {
          $C.add(n);
          var _ = "";
          k === void 0 ? _ = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof k != "object" ? _ = " However, it is set to a " + typeof k + "." : k.$$typeof === V ? _ = " Did you accidentally pass the Context.Provider instead?" : k._context !== void 0 ? _ = " Did you accidentally pass the Context.Consumer instead?" : _ = " However, it is set to an object with keys {" + Object.keys(k).join(", ") + "}.", c("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", zt(n) || "Component", _);
        }
      }
      if (typeof k == "object" && k !== null)
        y = _r(k);
      else {
        h = lp(e, n, !0);
        var L = n.contextTypes;
        f = L != null, y = f ? up(e, h) : Ya;
      }
      var A = new n(l, y);
      if (e.mode & At) {
        rr(!0);
        try {
          A = new n(l, y);
        } finally {
          rr(!1);
        }
      }
      var W = e.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null;
      Nw(e, A);
      {
        if (typeof n.getDerivedStateFromProps == "function" && W === null) {
          var $ = zt(n) || "Component";
          FC.has($) || (FC.add($), c("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $, A.state === null ? "null" : "undefined", $));
        }
        if (typeof n.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function") {
          var re = null, le = null, me = null;
          if (typeof A.componentWillMount == "function" && A.componentWillMount.__suppressDeprecationWarning !== !0 ? re = "componentWillMount" : typeof A.UNSAFE_componentWillMount == "function" && (re = "UNSAFE_componentWillMount"), typeof A.componentWillReceiveProps == "function" && A.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? le = "componentWillReceiveProps" : typeof A.UNSAFE_componentWillReceiveProps == "function" && (le = "UNSAFE_componentWillReceiveProps"), typeof A.componentWillUpdate == "function" && A.componentWillUpdate.__suppressDeprecationWarning !== !0 ? me = "componentWillUpdate" : typeof A.UNSAFE_componentWillUpdate == "function" && (me = "UNSAFE_componentWillUpdate"), re !== null || le !== null || me !== null) {
            var ze = zt(n) || "Component", ut = typeof n.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            zC.has(ze) || (zC.add(ze), c(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ze, ut, re !== null ? `
  ` + re : "", le !== null ? `
  ` + le : "", me !== null ? `
  ` + me : ""));
          }
        }
      }
      return f && T1(e, h, y), A;
    }
    function t2(e, n) {
      var l = n.state;
      typeof n.componentWillMount == "function" && n.componentWillMount(), typeof n.UNSAFE_componentWillMount == "function" && n.UNSAFE_componentWillMount(), l !== n.state && (c("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", bt(e) || "Component"), WC.enqueueReplaceState(n, n.state, null));
    }
    function Aw(e, n, l, f) {
      var h = n.state;
      if (typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(l, f), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(l, f), n.state !== h) {
        {
          var y = bt(e) || "Component";
          UC.has(y) || (UC.add(y), c("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", y));
        }
        WC.enqueueReplaceState(n, n.state, null);
      }
    }
    function GC(e, n, l, f) {
      e2(e, n, l);
      var h = e.stateNode;
      h.props = l, h.state = e.memoizedState, h.refs = {}, nC(e);
      var y = n.contextType;
      if (typeof y == "object" && y !== null)
        h.context = _r(y);
      else {
        var k = lp(e, n, !0);
        h.context = up(e, k);
      }
      {
        if (h.state === l) {
          var w = zt(n) || "Component";
          BC.has(w) || (BC.add(w), c("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", w));
        }
        e.mode & At && Go.recordLegacyContextWarning(e, h), Go.recordUnsafeLifecycleWarnings(e, h);
      }
      h.state = e.memoizedState;
      var _ = n.getDerivedStateFromProps;
      if (typeof _ == "function" && (qC(e, n, _, l), h.state = e.memoizedState), typeof n.getDerivedStateFromProps != "function" && typeof h.getSnapshotBeforeUpdate != "function" && (typeof h.UNSAFE_componentWillMount == "function" || typeof h.componentWillMount == "function") && (t2(e, h), Ly(e, l, h, f), h.state = e.memoizedState), typeof h.componentDidMount == "function") {
        var L = wt;
        L |= xi, (e.mode & ea) !== et && (L |= Pi), e.flags |= L;
      }
    }
    function n2(e, n, l, f) {
      var h = e.stateNode, y = e.memoizedProps;
      h.props = y;
      var k = h.context, w = n.contextType, _ = Ya;
      if (typeof w == "object" && w !== null)
        _ = _r(w);
      else {
        var L = lp(e, n, !0);
        _ = up(e, L);
      }
      var A = n.getDerivedStateFromProps, W = typeof A == "function" || typeof h.getSnapshotBeforeUpdate == "function";
      !W && (typeof h.UNSAFE_componentWillReceiveProps == "function" || typeof h.componentWillReceiveProps == "function") && (y !== l || k !== _) && Aw(e, h, l, _), Q1();
      var $ = e.memoizedState, re = h.state = $;
      if (Ly(e, l, h, f), re = e.memoizedState, y === l && $ === re && !my() && !Ay()) {
        if (typeof h.componentDidMount == "function") {
          var le = wt;
          le |= xi, (e.mode & ea) !== et && (le |= Pi), e.flags |= le;
        }
        return !1;
      }
      typeof A == "function" && (qC(e, n, A, l), re = e.memoizedState);
      var me = Ay() || Mw(e, n, y, l, $, re, _);
      if (me) {
        if (!W && (typeof h.UNSAFE_componentWillMount == "function" || typeof h.componentWillMount == "function") && (typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount()), typeof h.componentDidMount == "function") {
          var ze = wt;
          ze |= xi, (e.mode & ea) !== et && (ze |= Pi), e.flags |= ze;
        }
      } else {
        if (typeof h.componentDidMount == "function") {
          var ut = wt;
          ut |= xi, (e.mode & ea) !== et && (ut |= Pi), e.flags |= ut;
        }
        e.memoizedProps = l, e.memoizedState = re;
      }
      return h.props = l, h.state = re, h.context = _, me;
    }
    function r2(e, n, l, f, h) {
      var y = n.stateNode;
      K1(e, n);
      var k = n.memoizedProps, w = n.type === n.elementType ? k : Qo(n.type, k);
      y.props = w;
      var _ = n.pendingProps, L = y.context, A = l.contextType, W = Ya;
      if (typeof A == "object" && A !== null)
        W = _r(A);
      else {
        var $ = lp(n, l, !0);
        W = up(n, $);
      }
      var re = l.getDerivedStateFromProps, le = typeof re == "function" || typeof y.getSnapshotBeforeUpdate == "function";
      !le && (typeof y.UNSAFE_componentWillReceiveProps == "function" || typeof y.componentWillReceiveProps == "function") && (k !== _ || L !== W) && Aw(n, y, f, W), Q1();
      var me = n.memoizedState, ze = y.state = me;
      if (Ly(n, f, y, h), ze = n.memoizedState, k === _ && me === ze && !my() && !Ay() && !Ze)
        return typeof y.componentDidUpdate == "function" && (k !== e.memoizedProps || me !== e.memoizedState) && (n.flags |= wt), typeof y.getSnapshotBeforeUpdate == "function" && (k !== e.memoizedProps || me !== e.memoizedState) && (n.flags |= ha), !1;
      typeof re == "function" && (qC(n, l, re, f), ze = n.memoizedState);
      var ut = Ay() || Mw(n, l, w, f, me, ze, W) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Ze;
      return ut ? (!le && (typeof y.UNSAFE_componentWillUpdate == "function" || typeof y.componentWillUpdate == "function") && (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(f, ze, W), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(f, ze, W)), typeof y.componentDidUpdate == "function" && (n.flags |= wt), typeof y.getSnapshotBeforeUpdate == "function" && (n.flags |= ha)) : (typeof y.componentDidUpdate == "function" && (k !== e.memoizedProps || me !== e.memoizedState) && (n.flags |= wt), typeof y.getSnapshotBeforeUpdate == "function" && (k !== e.memoizedProps || me !== e.memoizedState) && (n.flags |= ha), n.memoizedProps = f, n.memoizedState = ze), y.props = f, y.state = ze, y.context = W, ut;
    }
    function Ed(e, n) {
      return {
        value: e,
        source: n,
        stack: au(n),
        digest: null
      };
    }
    function YC(e, n, l) {
      return {
        value: e,
        source: null,
        stack: l ?? null,
        digest: n ?? null
      };
    }
    function i2(e, n) {
      return !0;
    }
    function KC(e, n) {
      try {
        var l = i2(e, n);
        if (l === !1)
          return;
        var f = n.value, h = n.source, y = n.stack, k = y !== null ? y : "";
        if (f != null && f._suppressLogging) {
          if (e.tag === b)
            return;
          console.error(f);
        }
        var w = h ? bt(h) : null, _ = w ? "The above error occurred in the <" + w + "> component:" : "The above error occurred in one of your React components:", L;
        if (e.tag === E)
          L = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var A = bt(e) || "Anonymous";
          L = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + A + ".");
        }
        var W = _ + `
` + k + `

` + ("" + L);
        console.error(W);
      } catch ($) {
        setTimeout(function() {
          throw $;
        });
      }
    }
    var a2 = typeof WeakMap == "function" ? WeakMap : Map;
    function Iw(e, n, l) {
      var f = jl(Sn, l);
      f.tag = eC, f.payload = {
        element: null
      };
      var h = n.value;
      return f.callback = function() {
        JA(h), KC(e, n);
      }, f;
    }
    function QC(e, n, l) {
      var f = jl(Sn, l);
      f.tag = eC;
      var h = e.type.getDerivedStateFromError;
      if (typeof h == "function") {
        var y = n.value;
        f.payload = function() {
          return h(y);
        }, f.callback = function() {
          GR(e), KC(e, n);
        };
      }
      var k = e.stateNode;
      return k !== null && typeof k.componentDidCatch == "function" && (f.callback = function() {
        GR(e), KC(e, n), typeof h != "function" && KA(this);
        var _ = n.value, L = n.stack;
        this.componentDidCatch(_, {
          componentStack: L !== null ? L : ""
        }), typeof h != "function" && (Ai(e.lanes, ot) || c("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", bt(e) || "Unknown"));
      }), f;
    }
    function Uw(e, n, l) {
      var f = e.pingCache, h;
      if (f === null ? (f = e.pingCache = new a2(), h = /* @__PURE__ */ new Set(), f.set(n, h)) : (h = f.get(n), h === void 0 && (h = /* @__PURE__ */ new Set(), f.set(n, h))), !h.has(l)) {
        h.add(l);
        var y = XA.bind(null, e, n, l);
        Zi && nv(e, l), n.then(y, y);
      }
    }
    function o2(e, n, l, f) {
      var h = e.updateQueue;
      if (h === null) {
        var y = /* @__PURE__ */ new Set();
        y.add(l), e.updateQueue = y;
      } else
        h.add(l);
    }
    function s2(e, n) {
      var l = e.tag;
      if ((e.mode & rt) === et && (l === g || l === Z || l === te)) {
        var f = e.alternate;
        f ? (e.updateQueue = f.updateQueue, e.memoizedState = f.memoizedState, e.lanes = f.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function Fw(e) {
      var n = e;
      do {
        if (n.tag === F && VL(n))
          return n;
        n = n.return;
      } while (n !== null);
      return null;
    }
    function jw(e, n, l, f, h) {
      if ((e.mode & rt) === et) {
        if (e === n)
          e.flags |= Tr;
        else {
          if (e.flags |= gt, l.flags |= $c, l.flags &= ~(nf | Qi), l.tag === b) {
            var y = l.alternate;
            if (y === null)
              l.tag = pe;
            else {
              var k = jl(Sn, ot);
              k.tag = Dy, tc(l, k, ot);
            }
          }
          l.lanes = Et(l.lanes, ot);
        }
        return e;
      }
      return e.flags |= Tr, e.lanes = h, e;
    }
    function l2(e, n, l, f, h) {
      if (l.flags |= Qi, Zi && nv(e, h), f !== null && typeof f == "object" && typeof f.then == "function") {
        var y = f;
        s2(l), li() && l.mode & rt && D1();
        var k = Fw(n);
        if (k !== null) {
          k.flags &= ~Bn, jw(k, n, l, e, h), k.mode & rt && Uw(e, y, h), o2(k, e, y);
          return;
        } else {
          if (!Bh(h)) {
            Uw(e, y, h), Pk();
            return;
          }
          var w = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          f = w;
        }
      } else if (li() && l.mode & rt) {
        D1();
        var _ = Fw(n);
        if (_ !== null) {
          (_.flags & Tr) === st && (_.flags |= Bn), jw(_, n, l, e, h), BS(Ed(f, l));
          return;
        }
      }
      f = Ed(f, l), VA(f);
      var L = n;
      do {
        switch (L.tag) {
          case E: {
            var A = f;
            L.flags |= Tr;
            var W = Mu(h);
            L.lanes = Et(L.lanes, W);
            var $ = Iw(L, A, W);
            rC(L, $);
            return;
          }
          case b:
            var re = f, le = L.type, me = L.stateNode;
            if ((L.flags & gt) === st && (typeof le.getDerivedStateFromError == "function" || me !== null && typeof me.componentDidCatch == "function" && !FR(me))) {
              L.flags |= Tr;
              var ze = Mu(h);
              L.lanes = Et(L.lanes, ze);
              var ut = QC(L, re, ze);
              rC(L, ut);
              return;
            }
            break;
        }
        L = L.return;
      } while (L !== null);
    }
    function u2() {
      return null;
    }
    var zm = i.ReactCurrentOwner, Jo = !1, JC, Vm, XC, ZC, ek, wd, tk, a0, Bm;
    JC = {}, Vm = {}, XC = {}, ZC = {}, ek = {}, wd = !1, tk = {}, a0 = {}, Bm = {};
    function na(e, n, l, f) {
      e === null ? n.child = B1(n, null, l, f) : n.child = pp(n, e.child, l, f);
    }
    function c2(e, n, l, f) {
      n.child = pp(n, e.child, null, f), n.child = pp(n, null, l, f);
    }
    function zw(e, n, l, f, h) {
      if (n.type !== n.elementType) {
        var y = l.propTypes;
        y && qo(
          y,
          f,
          // Resolved props
          "prop",
          zt(l)
        );
      }
      var k = l.render, w = n.ref, _, L;
      mp(n, h), ku(n);
      {
        if (zm.current = n, wi(!0), _ = Cp(e, n, k, f, w, h), L = kp(), n.mode & At) {
          rr(!0);
          try {
            _ = Cp(e, n, k, f, w, h), L = kp();
          } finally {
            rr(!1);
          }
        }
        wi(!1);
      }
      return Mi(), e !== null && !Jo ? (nw(e, n, h), zl(e, n, h)) : (li() && L && IS(n), n.flags |= Ds, na(e, n, _, h), n.child);
    }
    function Vw(e, n, l, f, h) {
      if (e === null) {
        var y = l.type;
        if (mI(y) && l.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        l.defaultProps === void 0) {
          var k = y;
          return k = Dp(y), n.tag = te, n.type = k, ik(n, y), Bw(e, n, k, f, h);
        }
        {
          var w = y.propTypes;
          if (w && qo(
            w,
            f,
            // Resolved props
            "prop",
            zt(y)
          ), l.defaultProps !== void 0) {
            var _ = zt(y) || "Unknown";
            Bm[_] || (c("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", _), Bm[_] = !0);
          }
        }
        var L = zk(l.type, null, f, n, n.mode, h);
        return L.ref = n.ref, L.return = n, n.child = L, L;
      }
      {
        var A = l.type, W = A.propTypes;
        W && qo(
          W,
          f,
          // Resolved props
          "prop",
          zt(A)
        );
      }
      var $ = e.child, re = ck(e, h);
      if (!re) {
        var le = $.memoizedProps, me = l.compare;
        if (me = me !== null ? me : ht, me(le, f) && e.ref === n.ref)
          return zl(e, n, h);
      }
      n.flags |= Ds;
      var ze = Dd($, f);
      return ze.ref = n.ref, ze.return = n, n.child = ze, ze;
    }
    function Bw(e, n, l, f, h) {
      if (n.type !== n.elementType) {
        var y = n.elementType;
        if (y.$$typeof === dt) {
          var k = y, w = k._payload, _ = k._init;
          try {
            y = _(w);
          } catch {
            y = null;
          }
          var L = y && y.propTypes;
          L && qo(
            L,
            f,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            zt(y)
          );
        }
      }
      if (e !== null) {
        var A = e.memoizedProps;
        if (ht(A, f) && e.ref === n.ref && // Prevent bailout if the implementation changed due to hot reload.
        n.type === e.type)
          if (Jo = !1, n.pendingProps = f = A, ck(e, h))
            (e.flags & $c) !== st && (Jo = !0);
          else
            return n.lanes = e.lanes, zl(e, n, h);
      }
      return nk(e, n, l, f, h);
    }
    function Hw(e, n, l) {
      var f = n.pendingProps, h = f.children, y = e !== null ? e.memoizedState : null;
      if (f.mode === "hidden" || Ie)
        if ((n.mode & rt) === et) {
          var k = {
            baseLanes: Se,
            cachePool: null,
            transitions: null
          };
          n.memoizedState = k, y0(n, l);
        } else if (Ai(l, Yr)) {
          var W = {
            baseLanes: Se,
            cachePool: null,
            transitions: null
          };
          n.memoizedState = W;
          var $ = y !== null ? y.baseLanes : l;
          y0(n, $);
        } else {
          var w = null, _;
          if (y !== null) {
            var L = y.baseLanes;
            _ = Et(L, l);
          } else
            _ = l;
          n.lanes = n.childLanes = Yr;
          var A = {
            baseLanes: _,
            cachePool: w,
            transitions: null
          };
          return n.memoizedState = A, n.updateQueue = null, y0(n, _), null;
        }
      else {
        var re;
        y !== null ? (re = Et(y.baseLanes, l), n.memoizedState = null) : re = l, y0(n, re);
      }
      return na(e, n, h, l), n.child;
    }
    function d2(e, n, l) {
      var f = n.pendingProps;
      return na(e, n, f, l), n.child;
    }
    function f2(e, n, l) {
      var f = n.pendingProps.children;
      return na(e, n, f, l), n.child;
    }
    function p2(e, n, l) {
      {
        n.flags |= wt;
        {
          var f = n.stateNode;
          f.effectDuration = 0, f.passiveEffectDuration = 0;
        }
      }
      var h = n.pendingProps, y = h.children;
      return na(e, n, y, l), n.child;
    }
    function $w(e, n) {
      var l = n.ref;
      (e === null && l !== null || e !== null && e.ref !== l) && (n.flags |= _i, n.flags |= Ph);
    }
    function nk(e, n, l, f, h) {
      if (n.type !== n.elementType) {
        var y = l.propTypes;
        y && qo(
          y,
          f,
          // Resolved props
          "prop",
          zt(l)
        );
      }
      var k;
      {
        var w = lp(n, l, !0);
        k = up(n, w);
      }
      var _, L;
      mp(n, h), ku(n);
      {
        if (zm.current = n, wi(!0), _ = Cp(e, n, l, f, k, h), L = kp(), n.mode & At) {
          rr(!0);
          try {
            _ = Cp(e, n, l, f, k, h), L = kp();
          } finally {
            rr(!1);
          }
        }
        wi(!1);
      }
      return Mi(), e !== null && !Jo ? (nw(e, n, h), zl(e, n, h)) : (li() && L && IS(n), n.flags |= Ds, na(e, n, _, h), n.child);
    }
    function qw(e, n, l, f, h) {
      {
        switch (DI(n)) {
          case !1: {
            var y = n.stateNode, k = n.type, w = new k(n.memoizedProps, y.context), _ = w.state;
            y.updater.enqueueSetState(y, _, null);
            break;
          }
          case !0: {
            n.flags |= gt, n.flags |= Tr;
            var L = new Error("Simulated error coming from DevTools"), A = Mu(h);
            n.lanes = Et(n.lanes, A);
            var W = QC(n, Ed(L, n), A);
            rC(n, W);
            break;
          }
        }
        if (n.type !== n.elementType) {
          var $ = l.propTypes;
          $ && qo(
            $,
            f,
            // Resolved props
            "prop",
            zt(l)
          );
        }
      }
      var re;
      Hs(l) ? (re = !0, gy(n)) : re = !1, mp(n, h);
      var le = n.stateNode, me;
      le === null ? (s0(e, n), Lw(n, l, f), GC(n, l, f, h), me = !0) : e === null ? me = n2(n, l, f, h) : me = r2(e, n, l, f, h);
      var ze = rk(e, n, l, me, re, h);
      {
        var ut = n.stateNode;
        me && ut.props !== f && (wd || c("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", bt(n) || "a component"), wd = !0);
      }
      return ze;
    }
    function rk(e, n, l, f, h, y) {
      $w(e, n);
      var k = (n.flags & gt) !== st;
      if (!f && !k)
        return h && R1(n, l, !1), zl(e, n, y);
      var w = n.stateNode;
      zm.current = n;
      var _;
      if (k && typeof l.getDerivedStateFromError != "function")
        _ = null, Pw();
      else {
        ku(n);
        {
          if (wi(!0), _ = w.render(), n.mode & At) {
            rr(!0);
            try {
              w.render();
            } finally {
              rr(!1);
            }
          }
          wi(!1);
        }
        Mi();
      }
      return n.flags |= Ds, e !== null && k ? c2(e, n, _, y) : na(e, n, _, y), n.memoizedState = w.state, h && R1(n, l, !0), n.child;
    }
    function Ww(e) {
      var n = e.stateNode;
      n.pendingContext ? E1(e, n.pendingContext, n.pendingContext !== n.context) : n.context && E1(e, n.context, !1), iC(e, n.containerInfo);
    }
    function h2(e, n, l) {
      if (Ww(n), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var f = n.pendingProps, h = n.memoizedState, y = h.element;
      K1(e, n), Ly(n, f, null, l);
      var k = n.memoizedState;
      n.stateNode;
      var w = k.element;
      if (h.isDehydrated) {
        var _ = {
          element: w,
          isDehydrated: !1,
          cache: k.cache,
          pendingSuspenseBoundaries: k.pendingSuspenseBoundaries,
          transitions: k.transitions
        }, L = n.updateQueue;
        if (L.baseState = _, n.memoizedState = _, n.flags & Bn) {
          var A = Ed(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), n);
          return Gw(e, n, w, l, A);
        } else if (w !== y) {
          var W = Ed(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), n);
          return Gw(e, n, w, l, W);
        } else {
          gL(n);
          var $ = B1(n, null, w, l);
          n.child = $;
          for (var re = $; re; )
            re.flags = re.flags & ~Tn | ma, re = re.sibling;
        }
      } else {
        if (fp(), w === y)
          return zl(e, n, l);
        na(e, n, w, l);
      }
      return n.child;
    }
    function Gw(e, n, l, f, h) {
      return fp(), BS(h), n.flags |= Bn, na(e, n, l, f), n.child;
    }
    function m2(e, n, l) {
      Z1(n), e === null && VS(n);
      var f = n.type, h = n.pendingProps, y = e !== null ? e.memoizedProps : null, k = h.children, w = kS(f, h);
      return w ? k = null : y !== null && kS(f, y) && (n.flags |= ln), $w(e, n), na(e, n, k, l), n.child;
    }
    function v2(e, n) {
      return e === null && VS(n), null;
    }
    function g2(e, n, l, f) {
      s0(e, n);
      var h = n.pendingProps, y = l, k = y._payload, w = y._init, _ = w(k);
      n.type = _;
      var L = n.tag = vI(_), A = Qo(_, h), W;
      switch (L) {
        case g:
          return ik(n, _), n.type = _ = Dp(_), W = nk(null, n, _, A, f), W;
        case b:
          return n.type = _ = Lk(_), W = qw(null, n, _, A, f), W;
        case Z:
          return n.type = _ = Ak(_), W = zw(null, n, _, A, f), W;
        case K: {
          if (n.type !== n.elementType) {
            var $ = _.propTypes;
            $ && qo(
              $,
              A,
              // Resolved for outer only
              "prop",
              zt(_)
            );
          }
          return W = Vw(
            null,
            n,
            _,
            Qo(_.type, A),
            // The inner type can have defaults too
            f
          ), W;
        }
      }
      var re = "";
      throw _ !== null && typeof _ == "object" && _.$$typeof === dt && (re = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + _ + ". " + ("Lazy element type must resolve to a class or function." + re));
    }
    function y2(e, n, l, f, h) {
      s0(e, n), n.tag = b;
      var y;
      return Hs(l) ? (y = !0, gy(n)) : y = !1, mp(n, h), Lw(n, l, f), GC(n, l, f, h), rk(null, n, l, !0, y, h);
    }
    function b2(e, n, l, f) {
      s0(e, n);
      var h = n.pendingProps, y;
      {
        var k = lp(n, l, !1);
        y = up(n, k);
      }
      mp(n, f);
      var w, _;
      ku(n);
      {
        if (l.prototype && typeof l.prototype.render == "function") {
          var L = zt(l) || "Unknown";
          JC[L] || (c("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", L, L), JC[L] = !0);
        }
        n.mode & At && Go.recordLegacyContextWarning(n, null), wi(!0), zm.current = n, w = Cp(null, n, l, h, y, f), _ = kp(), wi(!1);
      }
      if (Mi(), n.flags |= Ds, typeof w == "object" && w !== null && typeof w.render == "function" && w.$$typeof === void 0) {
        var A = zt(l) || "Unknown";
        Vm[A] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", A, A, A), Vm[A] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof w == "object" && w !== null && typeof w.render == "function" && w.$$typeof === void 0
      ) {
        {
          var W = zt(l) || "Unknown";
          Vm[W] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", W, W, W), Vm[W] = !0);
        }
        n.tag = b, n.memoizedState = null, n.updateQueue = null;
        var $ = !1;
        return Hs(l) ? ($ = !0, gy(n)) : $ = !1, n.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, nC(n), Nw(n, w), GC(n, l, h, f), rk(null, n, l, !0, $, f);
      } else {
        if (n.tag = g, n.mode & At) {
          rr(!0);
          try {
            w = Cp(null, n, l, h, y, f), _ = kp();
          } finally {
            rr(!1);
          }
        }
        return li() && _ && IS(n), na(null, n, w, f), ik(n, l), n.child;
      }
    }
    function ik(e, n) {
      {
        if (n && n.childContextTypes && c("%s(...): childContextTypes cannot be defined on a function component.", n.displayName || n.name || "Component"), e.ref !== null) {
          var l = "", f = ai();
          f && (l += `

Check the render method of \`` + f + "`.");
          var h = f || "", y = e._debugSource;
          y && (h = y.fileName + ":" + y.lineNumber), ek[h] || (ek[h] = !0, c("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", l));
        }
        if (n.defaultProps !== void 0) {
          var k = zt(n) || "Unknown";
          Bm[k] || (c("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", k), Bm[k] = !0);
        }
        if (typeof n.getDerivedStateFromProps == "function") {
          var w = zt(n) || "Unknown";
          ZC[w] || (c("%s: Function components do not support getDerivedStateFromProps.", w), ZC[w] = !0);
        }
        if (typeof n.contextType == "object" && n.contextType !== null) {
          var _ = zt(n) || "Unknown";
          XC[_] || (c("%s: Function components do not support contextType.", _), XC[_] = !0);
        }
      }
    }
    var ak = {
      dehydrated: null,
      treeContext: null,
      retryLane: ir
    };
    function ok(e) {
      return {
        baseLanes: e,
        cachePool: u2(),
        transitions: null
      };
    }
    function S2(e, n) {
      var l = null;
      return {
        baseLanes: Et(e.baseLanes, n),
        cachePool: l,
        transitions: e.transitions
      };
    }
    function C2(e, n, l, f) {
      if (n !== null) {
        var h = n.memoizedState;
        if (h === null)
          return !1;
      }
      return sC(e, Om);
    }
    function k2(e, n) {
      return ed(e.childLanes, n);
    }
    function Yw(e, n, l) {
      var f = n.pendingProps;
      OI(n) && (n.flags |= gt);
      var h = Yo.current, y = !1, k = (n.flags & gt) !== st;
      if (k || C2(h, e) ? (y = !0, n.flags &= ~gt) : (e === null || e.memoizedState !== null) && (h = zL(h, tw)), h = gp(h), rc(n, h), e === null) {
        VS(n);
        var w = n.memoizedState;
        if (w !== null) {
          var _ = w.dehydrated;
          if (_ !== null)
            return _2(n, _);
        }
        var L = f.children, A = f.fallback;
        if (y) {
          var W = T2(n, L, A, l), $ = n.child;
          return $.memoizedState = ok(l), n.memoizedState = ak, W;
        } else
          return sk(n, L);
      } else {
        var re = e.memoizedState;
        if (re !== null) {
          var le = re.dehydrated;
          if (le !== null)
            return x2(e, n, k, f, le, re, l);
        }
        if (y) {
          var me = f.fallback, ze = f.children, ut = w2(e, n, ze, me, l), it = n.child, qt = e.child.memoizedState;
          return it.memoizedState = qt === null ? ok(l) : S2(qt, l), it.childLanes = k2(e, l), n.memoizedState = ak, ut;
        } else {
          var Ut = f.children, J = E2(e, n, Ut, l);
          return n.memoizedState = null, J;
        }
      }
    }
    function sk(e, n, l) {
      var f = e.mode, h = {
        mode: "visible",
        children: n
      }, y = lk(h, f);
      return y.return = e, e.child = y, y;
    }
    function T2(e, n, l, f) {
      var h = e.mode, y = e.child, k = {
        mode: "hidden",
        children: n
      }, w, _;
      return (h & rt) === et && y !== null ? (w = y, w.childLanes = Se, w.pendingProps = k, e.mode & yt && (w.actualDuration = 0, w.actualStartTime = -1, w.selfBaseDuration = 0, w.treeBaseDuration = 0), _ = dc(l, h, f, null)) : (w = lk(k, h), _ = dc(l, h, f, null)), w.return = e, _.return = e, w.sibling = _, e.child = w, _;
    }
    function lk(e, n, l) {
      return KR(e, n, Se, null);
    }
    function Kw(e, n) {
      return Dd(e, n);
    }
    function E2(e, n, l, f) {
      var h = e.child, y = h.sibling, k = Kw(h, {
        mode: "visible",
        children: l
      });
      if ((n.mode & rt) === et && (k.lanes = f), k.return = n, k.sibling = null, y !== null) {
        var w = n.deletions;
        w === null ? (n.deletions = [y], n.flags |= tn) : w.push(y);
      }
      return n.child = k, k;
    }
    function w2(e, n, l, f, h) {
      var y = n.mode, k = e.child, w = k.sibling, _ = {
        mode: "hidden",
        children: l
      }, L;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (y & rt) === et && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        n.child !== k
      ) {
        var A = n.child;
        L = A, L.childLanes = Se, L.pendingProps = _, n.mode & yt && (L.actualDuration = 0, L.actualStartTime = -1, L.selfBaseDuration = k.selfBaseDuration, L.treeBaseDuration = k.treeBaseDuration), n.deletions = null;
      } else
        L = Kw(k, _), L.subtreeFlags = k.subtreeFlags & Pr;
      var W;
      return w !== null ? W = Dd(w, f) : (W = dc(f, y, h, null), W.flags |= Tn), W.return = n, L.return = n, L.sibling = W, n.child = L, W;
    }
    function o0(e, n, l, f) {
      f !== null && BS(f), pp(n, e.child, null, l);
      var h = n.pendingProps, y = h.children, k = sk(n, y);
      return k.flags |= Tn, n.memoizedState = null, k;
    }
    function R2(e, n, l, f, h) {
      var y = n.mode, k = {
        mode: "visible",
        children: l
      }, w = lk(k, y), _ = dc(f, y, h, null);
      return _.flags |= Tn, w.return = n, _.return = n, w.sibling = _, n.child = w, (n.mode & rt) !== et && pp(n, e.child, null, h), _;
    }
    function _2(e, n, l) {
      return (e.mode & rt) === et ? (c("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = ot) : RS(n) ? e.lanes = zo : e.lanes = Yr, null;
    }
    function x2(e, n, l, f, h, y, k) {
      if (l)
        if (n.flags & Bn) {
          n.flags &= ~Bn;
          var J = YC(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return o0(e, n, k, J);
        } else {
          if (n.memoizedState !== null)
            return n.child = e.child, n.flags |= gt, null;
          var ve = f.children, X = f.fallback, xe = R2(e, n, ve, X, k), We = n.child;
          return We.memoizedState = ok(k), n.memoizedState = ak, xe;
        }
      else {
        if (mL(), (n.mode & rt) === et)
          return o0(
            e,
            n,
            k,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (RS(h)) {
          var w, _, L;
          {
            var A = MN(h);
            w = A.digest, _ = A.message, L = A.stack;
          }
          var W;
          _ ? W = new Error(_) : W = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var $ = YC(W, w, L);
          return o0(e, n, k, $);
        }
        var re = Ai(k, e.childLanes);
        if (Jo || re) {
          var le = g0();
          if (le !== null) {
            var me = Mg(le, k);
            if (me !== ir && me !== y.retryLane) {
              y.retryLane = me;
              var ze = Sn;
              _a(e, me), jr(le, e, me, ze);
            }
          }
          Pk();
          var ut = YC(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return o0(e, n, k, ut);
        } else if (y1(h)) {
          n.flags |= gt, n.child = e.child;
          var it = ZA.bind(null, e);
          return NN(h, it), null;
        } else {
          yL(n, h, y.treeContext);
          var qt = f.children, Ut = sk(n, qt);
          return Ut.flags |= ma, Ut;
        }
      }
    }
    function Qw(e, n, l) {
      e.lanes = Et(e.lanes, n);
      var f = e.alternate;
      f !== null && (f.lanes = Et(f.lanes, n)), XS(e.return, n, l);
    }
    function P2(e, n, l) {
      for (var f = n; f !== null; ) {
        if (f.tag === F) {
          var h = f.memoizedState;
          h !== null && Qw(f, l, e);
        } else if (f.tag === se)
          Qw(f, l, e);
        else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === e)
          return;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === e)
            return;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }
    function D2(e) {
      for (var n = e, l = null; n !== null; ) {
        var f = n.alternate;
        f !== null && Fy(f) === null && (l = n), n = n.sibling;
      }
      return l;
    }
    function O2(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !tk[e])
        if (tk[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              c('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          c('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function M2(e, n) {
      e !== void 0 && !a0[e] && (e !== "collapsed" && e !== "hidden" ? (a0[e] = !0, c('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : n !== "forwards" && n !== "backwards" && (a0[e] = !0, c('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function Jw(e, n) {
      {
        var l = Vt(e), f = !l && typeof ni(e) == "function";
        if (l || f) {
          var h = l ? "array" : "iterable";
          return c("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", h, n, h), !1;
        }
      }
      return !0;
    }
    function N2(e, n) {
      if ((n === "forwards" || n === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (Vt(e)) {
          for (var l = 0; l < e.length; l++)
            if (!Jw(e[l], l))
              return;
        } else {
          var f = ni(e);
          if (typeof f == "function") {
            var h = f.call(e);
            if (h)
              for (var y = h.next(), k = 0; !y.done; y = h.next()) {
                if (!Jw(y.value, k))
                  return;
                k++;
              }
          } else
            c('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', n);
        }
    }
    function uk(e, n, l, f, h) {
      var y = e.memoizedState;
      y === null ? e.memoizedState = {
        isBackwards: n,
        rendering: null,
        renderingStartTime: 0,
        last: f,
        tail: l,
        tailMode: h
      } : (y.isBackwards = n, y.rendering = null, y.renderingStartTime = 0, y.last = f, y.tail = l, y.tailMode = h);
    }
    function Xw(e, n, l) {
      var f = n.pendingProps, h = f.revealOrder, y = f.tail, k = f.children;
      O2(h), M2(y, h), N2(k, h), na(e, n, k, l);
      var w = Yo.current, _ = sC(w, Om);
      if (_)
        w = lC(w, Om), n.flags |= gt;
      else {
        var L = e !== null && (e.flags & gt) !== st;
        L && P2(n, n.child, l), w = gp(w);
      }
      if (rc(n, w), (n.mode & rt) === et)
        n.memoizedState = null;
      else
        switch (h) {
          case "forwards": {
            var A = D2(n.child), W;
            A === null ? (W = n.child, n.child = null) : (W = A.sibling, A.sibling = null), uk(
              n,
              !1,
              // isBackwards
              W,
              A,
              y
            );
            break;
          }
          case "backwards": {
            var $ = null, re = n.child;
            for (n.child = null; re !== null; ) {
              var le = re.alternate;
              if (le !== null && Fy(le) === null) {
                n.child = re;
                break;
              }
              var me = re.sibling;
              re.sibling = $, $ = re, re = me;
            }
            uk(
              n,
              !0,
              // isBackwards
              $,
              null,
              // last
              y
            );
            break;
          }
          case "together": {
            uk(
              n,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            n.memoizedState = null;
        }
      return n.child;
    }
    function L2(e, n, l) {
      iC(n, n.stateNode.containerInfo);
      var f = n.pendingProps;
      return e === null ? n.child = pp(n, null, f, l) : na(e, n, f, l), n.child;
    }
    var Zw = !1;
    function A2(e, n, l) {
      var f = n.type, h = f._context, y = n.pendingProps, k = n.memoizedProps, w = y.value;
      {
        "value" in y || Zw || (Zw = !0, c("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var _ = n.type.propTypes;
        _ && qo(_, y, "prop", "Context.Provider");
      }
      if (q1(n, h, w), k !== null) {
        var L = k.value;
        if (Ke(L, w)) {
          if (k.children === y.children && !my())
            return zl(e, n, l);
        } else
          OL(n, h, l);
      }
      var A = y.children;
      return na(e, n, A, l), n.child;
    }
    var eR = !1;
    function I2(e, n, l) {
      var f = n.type;
      f._context === void 0 ? f !== f.Consumer && (eR || (eR = !0, c("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : f = f._context;
      var h = n.pendingProps, y = h.children;
      typeof y != "function" && c("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), mp(n, l);
      var k = _r(f);
      ku(n);
      var w;
      return zm.current = n, wi(!0), w = y(k), wi(!1), Mi(), n.flags |= Ds, na(e, n, w, l), n.child;
    }
    function Hm() {
      Jo = !0;
    }
    function s0(e, n) {
      (n.mode & rt) === et && e !== null && (e.alternate = null, n.alternate = null, n.flags |= Tn);
    }
    function zl(e, n, l) {
      return e !== null && (n.dependencies = e.dependencies), Pw(), tv(n.lanes), Ai(l, n.childLanes) ? (PL(e, n), n.child) : null;
    }
    function U2(e, n, l) {
      {
        var f = n.return;
        if (f === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, n.alternate = null, l.index = n.index, l.sibling = n.sibling, l.return = n.return, l.ref = n.ref, n === f.child)
          f.child = l;
        else {
          var h = f.child;
          if (h === null)
            throw new Error("Expected parent to have a child.");
          for (; h.sibling !== n; )
            if (h = h.sibling, h === null)
              throw new Error("Expected to find the previous sibling.");
          h.sibling = l;
        }
        var y = f.deletions;
        return y === null ? (f.deletions = [e], f.flags |= tn) : y.push(e), l.flags |= Tn, l;
      }
    }
    function ck(e, n) {
      var l = e.lanes;
      return !!Ai(l, n);
    }
    function F2(e, n, l) {
      switch (n.tag) {
        case E:
          Ww(n), n.stateNode, fp();
          break;
        case O:
          Z1(n);
          break;
        case b: {
          var f = n.type;
          Hs(f) && gy(n);
          break;
        }
        case x:
          iC(n, n.stateNode.containerInfo);
          break;
        case ae: {
          var h = n.memoizedProps.value, y = n.type._context;
          q1(n, y, h);
          break;
        }
        case B:
          {
            var k = Ai(l, n.childLanes);
            k && (n.flags |= wt);
            {
              var w = n.stateNode;
              w.effectDuration = 0, w.passiveEffectDuration = 0;
            }
          }
          break;
        case F: {
          var _ = n.memoizedState;
          if (_ !== null) {
            if (_.dehydrated !== null)
              return rc(n, gp(Yo.current)), n.flags |= gt, null;
            var L = n.child, A = L.childLanes;
            if (Ai(l, A))
              return Yw(e, n, l);
            rc(n, gp(Yo.current));
            var W = zl(e, n, l);
            return W !== null ? W.sibling : null;
          } else
            rc(n, gp(Yo.current));
          break;
        }
        case se: {
          var $ = (e.flags & gt) !== st, re = Ai(l, n.childLanes);
          if ($) {
            if (re)
              return Xw(e, n, l);
            n.flags |= gt;
          }
          var le = n.memoizedState;
          if (le !== null && (le.rendering = null, le.tail = null, le.lastEffect = null), rc(n, Yo.current), re)
            break;
          return null;
        }
        case Ne:
        case Je:
          return n.lanes = Se, Hw(e, n, l);
      }
      return zl(e, n, l);
    }
    function tR(e, n, l) {
      if (n._debugNeedsRemount && e !== null)
        return U2(e, n, zk(n.type, n.key, n.pendingProps, n._debugOwner || null, n.mode, n.lanes));
      if (e !== null) {
        var f = e.memoizedProps, h = n.pendingProps;
        if (f !== h || my() || // Force a re-render if the implementation changed due to hot reload:
        n.type !== e.type)
          Jo = !0;
        else {
          var y = ck(e, l);
          if (!y && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (n.flags & gt) === st)
            return Jo = !1, F2(e, n, l);
          (e.flags & $c) !== st ? Jo = !0 : Jo = !1;
        }
      } else if (Jo = !1, li() && uL(n)) {
        var k = n.index, w = cL();
        P1(n, w, k);
      }
      switch (n.lanes = Se, n.tag) {
        case C:
          return b2(e, n, n.type, l);
        case he: {
          var _ = n.elementType;
          return g2(e, n, _, l);
        }
        case g: {
          var L = n.type, A = n.pendingProps, W = n.elementType === L ? A : Qo(L, A);
          return nk(e, n, L, W, l);
        }
        case b: {
          var $ = n.type, re = n.pendingProps, le = n.elementType === $ ? re : Qo($, re);
          return qw(e, n, $, le, l);
        }
        case E:
          return h2(e, n, l);
        case O:
          return m2(e, n, l);
        case N:
          return v2(e, n);
        case F:
          return Yw(e, n, l);
        case x:
          return L2(e, n, l);
        case Z: {
          var me = n.type, ze = n.pendingProps, ut = n.elementType === me ? ze : Qo(me, ze);
          return zw(e, n, me, ut, l);
        }
        case M:
          return d2(e, n, l);
        case I:
          return f2(e, n, l);
        case B:
          return p2(e, n, l);
        case ae:
          return A2(e, n, l);
        case U:
          return I2(e, n, l);
        case K: {
          var it = n.type, qt = n.pendingProps, Ut = Qo(it, qt);
          if (n.type !== n.elementType) {
            var J = it.propTypes;
            J && qo(
              J,
              Ut,
              // Resolved for outer only
              "prop",
              zt(it)
            );
          }
          return Ut = Qo(it.type, Ut), Vw(e, n, it, Ut, l);
        }
        case te:
          return Bw(e, n, n.type, n.pendingProps, l);
        case pe: {
          var ve = n.type, X = n.pendingProps, xe = n.elementType === ve ? X : Qo(ve, X);
          return y2(e, n, ve, xe, l);
        }
        case se:
          return Xw(e, n, l);
        case Ee:
          break;
        case Ne:
          return Hw(e, n, l);
      }
      throw new Error("Unknown unit of work tag (" + n.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Tp(e) {
      e.flags |= wt;
    }
    function nR(e) {
      e.flags |= _i, e.flags |= Ph;
    }
    var rR, dk, iR, aR;
    rR = function(e, n, l, f) {
      for (var h = n.child; h !== null; ) {
        if (h.tag === O || h.tag === N)
          oN(e, h.stateNode);
        else if (h.tag !== x) {
          if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
        }
        if (h === n)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === n)
            return;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }, dk = function(e, n) {
    }, iR = function(e, n, l, f, h) {
      var y = e.memoizedProps;
      if (y !== f) {
        var k = n.stateNode, w = aC(), _ = lN(k, l, y, f, h, w);
        n.updateQueue = _, _ && Tp(n);
      }
    }, aR = function(e, n, l, f) {
      l !== f && Tp(n);
    };
    function $m(e, n) {
      if (!li())
        switch (e.tailMode) {
          case "hidden": {
            for (var l = e.tail, f = null; l !== null; )
              l.alternate !== null && (f = l), l = l.sibling;
            f === null ? e.tail = null : f.sibling = null;
            break;
          }
          case "collapsed": {
            for (var h = e.tail, y = null; h !== null; )
              h.alternate !== null && (y = h), h = h.sibling;
            y === null ? !n && e.tail !== null ? e.tail.sibling = null : e.tail = null : y.sibling = null;
            break;
          }
        }
    }
    function ci(e) {
      var n = e.alternate !== null && e.alternate.child === e.child, l = Se, f = st;
      if (n) {
        if ((e.mode & yt) !== et) {
          for (var _ = e.selfBaseDuration, L = e.child; L !== null; )
            l = Et(l, Et(L.lanes, L.childLanes)), f |= L.subtreeFlags & Pr, f |= L.flags & Pr, _ += L.treeBaseDuration, L = L.sibling;
          e.treeBaseDuration = _;
        } else
          for (var A = e.child; A !== null; )
            l = Et(l, Et(A.lanes, A.childLanes)), f |= A.subtreeFlags & Pr, f |= A.flags & Pr, A.return = e, A = A.sibling;
        e.subtreeFlags |= f;
      } else {
        if ((e.mode & yt) !== et) {
          for (var h = e.actualDuration, y = e.selfBaseDuration, k = e.child; k !== null; )
            l = Et(l, Et(k.lanes, k.childLanes)), f |= k.subtreeFlags, f |= k.flags, h += k.actualDuration, y += k.treeBaseDuration, k = k.sibling;
          e.actualDuration = h, e.treeBaseDuration = y;
        } else
          for (var w = e.child; w !== null; )
            l = Et(l, Et(w.lanes, w.childLanes)), f |= w.subtreeFlags, f |= w.flags, w.return = e, w = w.sibling;
        e.subtreeFlags |= f;
      }
      return e.childLanes = l, n;
    }
    function j2(e, n, l) {
      if (TL() && (n.mode & rt) !== et && (n.flags & gt) === st)
        return I1(n), fp(), n.flags |= Bn | Qi | Tr, !1;
      var f = ky(n);
      if (l !== null && l.dehydrated !== null)
        if (e === null) {
          if (!f)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (CL(n), ci(n), (n.mode & yt) !== et) {
            var h = l !== null;
            if (h) {
              var y = n.child;
              y !== null && (n.treeBaseDuration -= y.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (fp(), (n.flags & gt) === st && (n.memoizedState = null), n.flags |= wt, ci(n), (n.mode & yt) !== et) {
            var k = l !== null;
            if (k) {
              var w = n.child;
              w !== null && (n.treeBaseDuration -= w.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return U1(), !0;
    }
    function oR(e, n, l) {
      var f = n.pendingProps;
      switch (US(n), n.tag) {
        case C:
        case he:
        case te:
        case g:
        case Z:
        case M:
        case I:
        case B:
        case U:
        case K:
          return ci(n), null;
        case b: {
          var h = n.type;
          return Hs(h) && vy(n), ci(n), null;
        }
        case E: {
          var y = n.stateNode;
          if (vp(n), NS(n), cC(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), e === null || e.child === null) {
            var k = ky(n);
            if (k)
              Tp(n);
            else if (e !== null) {
              var w = e.memoizedState;
              // Check if this is a client root
              (!w.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (n.flags & Bn) !== st) && (n.flags |= ha, U1());
            }
          }
          return dk(e, n), ci(n), null;
        }
        case O: {
          oC(n);
          var _ = X1(), L = n.type;
          if (e !== null && n.stateNode != null)
            iR(e, n, L, f, _), e.ref !== n.ref && nR(n);
          else {
            if (!f) {
              if (n.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return ci(n), null;
            }
            var A = aC(), W = ky(n);
            if (W)
              bL(n, _, A) && Tp(n);
            else {
              var $ = aN(L, f, _, A, n);
              rR($, n, !1, !1), n.stateNode = $, sN($, L, f, _) && Tp(n);
            }
            n.ref !== null && nR(n);
          }
          return ci(n), null;
        }
        case N: {
          var re = f;
          if (e && n.stateNode != null) {
            var le = e.memoizedProps;
            aR(e, n, le, re);
          } else {
            if (typeof re != "string" && n.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var me = X1(), ze = aC(), ut = ky(n);
            ut ? SL(n) && Tp(n) : n.stateNode = uN(re, me, ze, n);
          }
          return ci(n), null;
        }
        case F: {
          yp(n);
          var it = n.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var qt = j2(e, n, it);
            if (!qt)
              return n.flags & Tr ? n : null;
          }
          if ((n.flags & gt) !== st)
            return n.lanes = l, (n.mode & yt) !== et && AC(n), n;
          var Ut = it !== null, J = e !== null && e.memoizedState !== null;
          if (Ut !== J && Ut) {
            var ve = n.child;
            if (ve.flags |= Os, (n.mode & rt) !== et) {
              var X = e === null && (n.memoizedProps.unstable_avoidThisFallback !== !0 || !Y);
              X || sC(Yo.current, tw) ? zA() : Pk();
            }
          }
          var xe = n.updateQueue;
          if (xe !== null && (n.flags |= wt), ci(n), (n.mode & yt) !== et && Ut) {
            var We = n.child;
            We !== null && (n.treeBaseDuration -= We.treeBaseDuration);
          }
          return null;
        }
        case x:
          return vp(n), dk(e, n), e === null && nL(n.stateNode.containerInfo), ci(n), null;
        case ae:
          var Ve = n.type._context;
          return JS(Ve, n), ci(n), null;
        case pe: {
          var mt = n.type;
          return Hs(mt) && vy(n), ci(n), null;
        }
        case se: {
          yp(n);
          var Tt = n.memoizedState;
          if (Tt === null)
            return ci(n), null;
          var pn = (n.flags & gt) !== st, Xt = Tt.rendering;
          if (Xt === null)
            if (pn)
              $m(Tt, !1);
            else {
              var mr = BA() && (e === null || (e.flags & gt) === st);
              if (!mr)
                for (var Zt = n.child; Zt !== null; ) {
                  var ar = Fy(Zt);
                  if (ar !== null) {
                    pn = !0, n.flags |= gt, $m(Tt, !1);
                    var zi = ar.updateQueue;
                    return zi !== null && (n.updateQueue = zi, n.flags |= wt), n.subtreeFlags = st, DL(n, l), rc(n, lC(Yo.current, Om)), n.child;
                  }
                  Zt = Zt.sibling;
                }
              Tt.tail !== null && Un() > _R() && (n.flags |= gt, pn = !0, $m(Tt, !1), n.lanes = Cg);
            }
          else {
            if (!pn) {
              var mi = Fy(Xt);
              if (mi !== null) {
                n.flags |= gt, pn = !0;
                var Qa = mi.updateQueue;
                if (Qa !== null && (n.updateQueue = Qa, n.flags |= wt), $m(Tt, !0), Tt.tail === null && Tt.tailMode === "hidden" && !Xt.alternate && !li())
                  return ci(n), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Un() * 2 - Tt.renderingStartTime > _R() && l !== Yr && (n.flags |= gt, pn = !0, $m(Tt, !1), n.lanes = Cg);
            }
            if (Tt.isBackwards)
              Xt.sibling = n.child, n.child = Xt;
            else {
              var aa = Tt.last;
              aa !== null ? aa.sibling = Xt : n.child = Xt, Tt.last = Xt;
            }
          }
          if (Tt.tail !== null) {
            var oa = Tt.tail;
            Tt.rendering = oa, Tt.tail = oa.sibling, Tt.renderingStartTime = Un(), oa.sibling = null;
            var Vi = Yo.current;
            return pn ? Vi = lC(Vi, Om) : Vi = gp(Vi), rc(n, Vi), oa;
          }
          return ci(n), null;
        }
        case Ee:
          break;
        case Ne:
        case Je: {
          xk(n);
          var ql = n.memoizedState, Op = ql !== null;
          if (e !== null) {
            var ov = e.memoizedState, Js = ov !== null;
            Js !== Op && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !Ie && (n.flags |= Os);
          }
          return !Op || (n.mode & rt) === et ? ci(n) : Ai(Qs, Yr) && (ci(n), n.subtreeFlags & (Tn | wt) && (n.flags |= Os)), null;
        }
        case vt:
          return null;
        case Ct:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + n.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function z2(e, n, l) {
      switch (US(n), n.tag) {
        case b: {
          var f = n.type;
          Hs(f) && vy(n);
          var h = n.flags;
          return h & Tr ? (n.flags = h & ~Tr | gt, (n.mode & yt) !== et && AC(n), n) : null;
        }
        case E: {
          n.stateNode, vp(n), NS(n), cC();
          var y = n.flags;
          return (y & Tr) !== st && (y & gt) === st ? (n.flags = y & ~Tr | gt, n) : null;
        }
        case O:
          return oC(n), null;
        case F: {
          yp(n);
          var k = n.memoizedState;
          if (k !== null && k.dehydrated !== null) {
            if (n.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            fp();
          }
          var w = n.flags;
          return w & Tr ? (n.flags = w & ~Tr | gt, (n.mode & yt) !== et && AC(n), n) : null;
        }
        case se:
          return yp(n), null;
        case x:
          return vp(n), null;
        case ae:
          var _ = n.type._context;
          return JS(_, n), null;
        case Ne:
        case Je:
          return xk(n), null;
        case vt:
          return null;
        default:
          return null;
      }
    }
    function sR(e, n, l) {
      switch (US(n), n.tag) {
        case b: {
          var f = n.type.childContextTypes;
          f != null && vy(n);
          break;
        }
        case E: {
          n.stateNode, vp(n), NS(n), cC();
          break;
        }
        case O: {
          oC(n);
          break;
        }
        case x:
          vp(n);
          break;
        case F:
          yp(n);
          break;
        case se:
          yp(n);
          break;
        case ae:
          var h = n.type._context;
          JS(h, n);
          break;
        case Ne:
        case Je:
          xk(n);
          break;
      }
    }
    var lR = null;
    lR = /* @__PURE__ */ new Set();
    var l0 = !1, di = !1, V2 = typeof WeakSet == "function" ? WeakSet : Set, Qe = null, Ep = null, wp = null;
    function B2(e) {
      vl(null, function() {
        throw e;
      }), _h();
    }
    var H2 = function(e, n) {
      if (n.props = e.memoizedProps, n.state = e.memoizedState, e.mode & yt)
        try {
          Ys(), n.componentWillUnmount();
        } finally {
          Gs(e);
        }
      else
        n.componentWillUnmount();
    };
    function uR(e, n) {
      try {
        oc(Nr, e);
      } catch (l) {
        Rn(e, n, l);
      }
    }
    function fk(e, n, l) {
      try {
        H2(e, l);
      } catch (f) {
        Rn(e, n, f);
      }
    }
    function $2(e, n, l) {
      try {
        l.componentDidMount();
      } catch (f) {
        Rn(e, n, f);
      }
    }
    function cR(e, n) {
      try {
        fR(e);
      } catch (l) {
        Rn(e, n, l);
      }
    }
    function Rp(e, n) {
      var l = e.ref;
      if (l !== null)
        if (typeof l == "function") {
          var f;
          try {
            if (Rt && Ft && e.mode & yt)
              try {
                Ys(), f = l(null);
              } finally {
                Gs(e);
              }
            else
              f = l(null);
          } catch (h) {
            Rn(e, n, h);
          }
          typeof f == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", bt(e));
        } else
          l.current = null;
    }
    function u0(e, n, l) {
      try {
        l();
      } catch (f) {
        Rn(e, n, f);
      }
    }
    var dR = !1;
    function q2(e, n) {
      rN(e.containerInfo), Qe = n, W2();
      var l = dR;
      return dR = !1, l;
    }
    function W2() {
      for (; Qe !== null; ) {
        var e = Qe, n = e.child;
        (e.subtreeFlags & bu) !== st && n !== null ? (n.return = e, Qe = n) : G2();
      }
    }
    function G2() {
      for (; Qe !== null; ) {
        var e = Qe;
        sn(e);
        try {
          Y2(e);
        } catch (l) {
          Rn(e, e.return, l);
        }
        Vn();
        var n = e.sibling;
        if (n !== null) {
          n.return = e.return, Qe = n;
          return;
        }
        Qe = e.return;
      }
    }
    function Y2(e) {
      var n = e.alternate, l = e.flags;
      if ((l & ha) !== st) {
        switch (sn(e), e.tag) {
          case g:
          case Z:
          case te:
            break;
          case b: {
            if (n !== null) {
              var f = n.memoizedProps, h = n.memoizedState, y = e.stateNode;
              e.type === e.elementType && !wd && (y.props !== e.memoizedProps && c("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bt(e) || "instance"), y.state !== e.memoizedState && c("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bt(e) || "instance"));
              var k = y.getSnapshotBeforeUpdate(e.elementType === e.type ? f : Qo(e.type, f), h);
              {
                var w = lR;
                k === void 0 && !w.has(e.type) && (w.add(e.type), c("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", bt(e)));
              }
              y.__reactInternalSnapshotBeforeUpdate = k;
            }
            break;
          }
          case E: {
            {
              var _ = e.stateNode;
              xN(_.containerInfo);
            }
            break;
          }
          case O:
          case N:
          case x:
          case pe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Vn();
      }
    }
    function Xo(e, n, l) {
      var f = n.updateQueue, h = f !== null ? f.lastEffect : null;
      if (h !== null) {
        var y = h.next, k = y;
        do {
          if ((k.tag & e) === e) {
            var w = k.destroy;
            k.destroy = void 0, w !== void 0 && ((e & ui) !== xa ? yg(n) : (e & Nr) !== xa && Ga(n), (e & $s) !== xa && rv(!0), u0(n, l, w), (e & $s) !== xa && rv(!1), (e & ui) !== xa ? ff() : (e & Nr) !== xa && Tu());
          }
          k = k.next;
        } while (k !== y);
      }
    }
    function oc(e, n) {
      var l = n.updateQueue, f = l !== null ? l.lastEffect : null;
      if (f !== null) {
        var h = f.next, y = h;
        do {
          if ((y.tag & e) === e) {
            (e & ui) !== xa ? Ls(n) : (e & Nr) !== xa && bg(n);
            var k = y.create;
            (e & $s) !== xa && rv(!0), y.destroy = k(), (e & $s) !== xa && rv(!1), (e & ui) !== xa ? df() : (e & Nr) !== xa && qc();
            {
              var w = y.destroy;
              if (w !== void 0 && typeof w != "function") {
                var _ = void 0;
                (y.tag & Nr) !== st ? _ = "useLayoutEffect" : (y.tag & $s) !== st ? _ = "useInsertionEffect" : _ = "useEffect";
                var L = void 0;
                w === null ? L = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof w.then == "function" ? L = `

It looks like you wrote ` + _ + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + _ + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : L = " You returned: " + w, c("%s must not return anything besides a function, which is used for clean-up.%s", _, L);
              }
            }
          }
          y = y.next;
        } while (y !== h);
      }
    }
    function K2(e, n) {
      if ((n.flags & wt) !== st)
        switch (n.tag) {
          case B: {
            var l = n.stateNode.passiveEffectDuration, f = n.memoizedProps, h = f.id, y = f.onPostCommit, k = _w(), w = n.alternate === null ? "mount" : "update";
            Rw() && (w = "nested-update"), typeof y == "function" && y(h, w, l, k);
            var _ = n.return;
            e:
              for (; _ !== null; ) {
                switch (_.tag) {
                  case E:
                    var L = _.stateNode;
                    L.passiveEffectDuration += l;
                    break e;
                  case B:
                    var A = _.stateNode;
                    A.passiveEffectDuration += l;
                    break e;
                }
                _ = _.return;
              }
            break;
          }
        }
    }
    function Q2(e, n, l, f) {
      if ((l.flags & Wr) !== st)
        switch (l.tag) {
          case g:
          case Z:
          case te: {
            if (!di)
              if (l.mode & yt)
                try {
                  Ys(), oc(Nr | Mr, l);
                } finally {
                  Gs(l);
                }
              else
                oc(Nr | Mr, l);
            break;
          }
          case b: {
            var h = l.stateNode;
            if (l.flags & wt && !di)
              if (n === null)
                if (l.type === l.elementType && !wd && (h.props !== l.memoizedProps && c("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bt(l) || "instance"), h.state !== l.memoizedState && c("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bt(l) || "instance")), l.mode & yt)
                  try {
                    Ys(), h.componentDidMount();
                  } finally {
                    Gs(l);
                  }
                else
                  h.componentDidMount();
              else {
                var y = l.elementType === l.type ? n.memoizedProps : Qo(l.type, n.memoizedProps), k = n.memoizedState;
                if (l.type === l.elementType && !wd && (h.props !== l.memoizedProps && c("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bt(l) || "instance"), h.state !== l.memoizedState && c("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bt(l) || "instance")), l.mode & yt)
                  try {
                    Ys(), h.componentDidUpdate(y, k, h.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Gs(l);
                  }
                else
                  h.componentDidUpdate(y, k, h.__reactInternalSnapshotBeforeUpdate);
              }
            var w = l.updateQueue;
            w !== null && (l.type === l.elementType && !wd && (h.props !== l.memoizedProps && c("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bt(l) || "instance"), h.state !== l.memoizedState && c("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bt(l) || "instance")), J1(l, w, h));
            break;
          }
          case E: {
            var _ = l.updateQueue;
            if (_ !== null) {
              var L = null;
              if (l.child !== null)
                switch (l.child.tag) {
                  case O:
                    L = l.child.stateNode;
                    break;
                  case b:
                    L = l.child.stateNode;
                    break;
                }
              J1(l, _, L);
            }
            break;
          }
          case O: {
            var A = l.stateNode;
            if (n === null && l.flags & wt) {
              var W = l.type, $ = l.memoizedProps;
              hN(A, W, $);
            }
            break;
          }
          case N:
            break;
          case x:
            break;
          case B: {
            {
              var re = l.memoizedProps, le = re.onCommit, me = re.onRender, ze = l.stateNode.effectDuration, ut = _w(), it = n === null ? "mount" : "update";
              Rw() && (it = "nested-update"), typeof me == "function" && me(l.memoizedProps.id, it, l.actualDuration, l.treeBaseDuration, l.actualStartTime, ut);
              {
                typeof le == "function" && le(l.memoizedProps.id, it, ze, ut), GA(l);
                var qt = l.return;
                e:
                  for (; qt !== null; ) {
                    switch (qt.tag) {
                      case E:
                        var Ut = qt.stateNode;
                        Ut.effectDuration += ze;
                        break e;
                      case B:
                        var J = qt.stateNode;
                        J.effectDuration += ze;
                        break e;
                    }
                    qt = qt.return;
                  }
              }
            }
            break;
          }
          case F: {
            iA(e, l);
            break;
          }
          case se:
          case pe:
          case Ee:
          case Ne:
          case Je:
          case Ct:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      di || l.flags & _i && fR(l);
    }
    function J2(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          if (e.mode & yt)
            try {
              Ys(), uR(e, e.return);
            } finally {
              Gs(e);
            }
          else
            uR(e, e.return);
          break;
        }
        case b: {
          var n = e.stateNode;
          typeof n.componentDidMount == "function" && $2(e, e.return, n), cR(e, e.return);
          break;
        }
        case O: {
          cR(e, e.return);
          break;
        }
      }
    }
    function X2(e, n) {
      for (var l = null, f = e; ; ) {
        if (f.tag === O) {
          if (l === null) {
            l = f;
            try {
              var h = f.stateNode;
              n ? EN(h) : RN(f.stateNode, f.memoizedProps);
            } catch (k) {
              Rn(e, e.return, k);
            }
          }
        } else if (f.tag === N) {
          if (l === null)
            try {
              var y = f.stateNode;
              n ? wN(y) : _N(y, f.memoizedProps);
            } catch (k) {
              Rn(e, e.return, k);
            }
        } else if (!((f.tag === Ne || f.tag === Je) && f.memoizedState !== null && f !== e)) {
          if (f.child !== null) {
            f.child.return = f, f = f.child;
            continue;
          }
        }
        if (f === e)
          return;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === e)
            return;
          l === f && (l = null), f = f.return;
        }
        l === f && (l = null), f.sibling.return = f.return, f = f.sibling;
      }
    }
    function fR(e) {
      var n = e.ref;
      if (n !== null) {
        var l = e.stateNode, f;
        switch (e.tag) {
          case O:
            f = l;
            break;
          default:
            f = l;
        }
        if (typeof n == "function") {
          var h;
          if (e.mode & yt)
            try {
              Ys(), h = n(f);
            } finally {
              Gs(e);
            }
          else
            h = n(f);
          typeof h == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", bt(e));
        } else
          n.hasOwnProperty("current") || c("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", bt(e)), n.current = f;
      }
    }
    function Z2(e) {
      var n = e.alternate;
      n !== null && (n.return = null), e.return = null;
    }
    function pR(e) {
      var n = e.alternate;
      n !== null && (e.alternate = null, pR(n));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === O) {
          var l = e.stateNode;
          l !== null && aL(l);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function eA(e) {
      for (var n = e.return; n !== null; ) {
        if (hR(n))
          return n;
        n = n.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hR(e) {
      return e.tag === O || e.tag === E || e.tag === x;
    }
    function mR(e) {
      var n = e;
      e:
        for (; ; ) {
          for (; n.sibling === null; ) {
            if (n.return === null || hR(n.return))
              return null;
            n = n.return;
          }
          for (n.sibling.return = n.return, n = n.sibling; n.tag !== O && n.tag !== N && n.tag !== ye; ) {
            if (n.flags & Tn || n.child === null || n.tag === x)
              continue e;
            n.child.return = n, n = n.child;
          }
          if (!(n.flags & Tn))
            return n.stateNode;
        }
    }
    function tA(e) {
      var n = eA(e);
      switch (n.tag) {
        case O: {
          var l = n.stateNode;
          n.flags & ln && (g1(l), n.flags &= ~ln);
          var f = mR(e);
          hk(e, f, l);
          break;
        }
        case E:
        case x: {
          var h = n.stateNode.containerInfo, y = mR(e);
          pk(e, y, h);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function pk(e, n, l) {
      var f = e.tag, h = f === O || f === N;
      if (h) {
        var y = e.stateNode;
        n ? SN(l, y, n) : yN(l, y);
      } else if (f !== x) {
        var k = e.child;
        if (k !== null) {
          pk(k, n, l);
          for (var w = k.sibling; w !== null; )
            pk(w, n, l), w = w.sibling;
        }
      }
    }
    function hk(e, n, l) {
      var f = e.tag, h = f === O || f === N;
      if (h) {
        var y = e.stateNode;
        n ? bN(l, y, n) : gN(l, y);
      } else if (f !== x) {
        var k = e.child;
        if (k !== null) {
          hk(k, n, l);
          for (var w = k.sibling; w !== null; )
            hk(w, n, l), w = w.sibling;
        }
      }
    }
    var fi = null, Zo = !1;
    function nA(e, n, l) {
      {
        var f = n;
        e:
          for (; f !== null; ) {
            switch (f.tag) {
              case O: {
                fi = f.stateNode, Zo = !1;
                break e;
              }
              case E: {
                fi = f.stateNode.containerInfo, Zo = !0;
                break e;
              }
              case x: {
                fi = f.stateNode.containerInfo, Zo = !0;
                break e;
              }
            }
            f = f.return;
          }
        if (fi === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        vR(e, n, l), fi = null, Zo = !1;
      }
      Z2(l);
    }
    function sc(e, n, l) {
      for (var f = l.child; f !== null; )
        vR(e, n, f), f = f.sibling;
    }
    function vR(e, n, l) {
      switch (bl(l), l.tag) {
        case O:
          di || Rp(l, n);
        case N: {
          {
            var f = fi, h = Zo;
            fi = null, sc(e, n, l), fi = f, Zo = h, fi !== null && (Zo ? kN(fi, l.stateNode) : CN(fi, l.stateNode));
          }
          return;
        }
        case ye: {
          fi !== null && (Zo ? TN(fi, l.stateNode) : wS(fi, l.stateNode));
          return;
        }
        case x: {
          {
            var y = fi, k = Zo;
            fi = l.stateNode.containerInfo, Zo = !0, sc(e, n, l), fi = y, Zo = k;
          }
          return;
        }
        case g:
        case Z:
        case K:
        case te: {
          if (!di) {
            var w = l.updateQueue;
            if (w !== null) {
              var _ = w.lastEffect;
              if (_ !== null) {
                var L = _.next, A = L;
                do {
                  var W = A, $ = W.destroy, re = W.tag;
                  $ !== void 0 && ((re & $s) !== xa ? u0(l, n, $) : (re & Nr) !== xa && (Ga(l), l.mode & yt ? (Ys(), u0(l, n, $), Gs(l)) : u0(l, n, $), Tu())), A = A.next;
                } while (A !== L);
              }
            }
          }
          sc(e, n, l);
          return;
        }
        case b: {
          if (!di) {
            Rp(l, n);
            var le = l.stateNode;
            typeof le.componentWillUnmount == "function" && fk(l, n, le);
          }
          sc(e, n, l);
          return;
        }
        case Ee: {
          sc(e, n, l);
          return;
        }
        case Ne: {
          if (
            // TODO: Remove this dead flag
            l.mode & rt
          ) {
            var me = di;
            di = me || l.memoizedState !== null, sc(e, n, l), di = me;
          } else
            sc(e, n, l);
          break;
        }
        default: {
          sc(e, n, l);
          return;
        }
      }
    }
    function rA(e) {
      e.memoizedState;
    }
    function iA(e, n) {
      var l = n.memoizedState;
      if (l === null) {
        var f = n.alternate;
        if (f !== null) {
          var h = f.memoizedState;
          if (h !== null) {
            var y = h.dehydrated;
            y !== null && BN(y);
          }
        }
      }
    }
    function gR(e) {
      var n = e.updateQueue;
      if (n !== null) {
        e.updateQueue = null;
        var l = e.stateNode;
        l === null && (l = e.stateNode = new V2()), n.forEach(function(f) {
          var h = eI.bind(null, e, f);
          if (!l.has(f)) {
            if (l.add(f), Zi)
              if (Ep !== null && wp !== null)
                nv(wp, Ep);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            f.then(h, h);
          }
        });
      }
    }
    function aA(e, n, l) {
      Ep = l, wp = e, sn(n), yR(n, e), sn(n), Ep = null, wp = null;
    }
    function es(e, n, l) {
      var f = n.deletions;
      if (f !== null)
        for (var h = 0; h < f.length; h++) {
          var y = f[h];
          try {
            nA(e, n, y);
          } catch (_) {
            Rn(y, n, _);
          }
        }
      var k = Bd();
      if (n.subtreeFlags & Di)
        for (var w = n.child; w !== null; )
          sn(w), yR(w, e), w = w.sibling;
      sn(k);
    }
    function yR(e, n, l) {
      var f = e.alternate, h = e.flags;
      switch (e.tag) {
        case g:
        case Z:
        case K:
        case te: {
          if (es(n, e), Ks(e), h & wt) {
            try {
              Xo($s | Mr, e, e.return), oc($s | Mr, e);
            } catch (mt) {
              Rn(e, e.return, mt);
            }
            if (e.mode & yt) {
              try {
                Ys(), Xo(Nr | Mr, e, e.return);
              } catch (mt) {
                Rn(e, e.return, mt);
              }
              Gs(e);
            } else
              try {
                Xo(Nr | Mr, e, e.return);
              } catch (mt) {
                Rn(e, e.return, mt);
              }
          }
          return;
        }
        case b: {
          es(n, e), Ks(e), h & _i && f !== null && Rp(f, f.return);
          return;
        }
        case O: {
          es(n, e), Ks(e), h & _i && f !== null && Rp(f, f.return);
          {
            if (e.flags & ln) {
              var y = e.stateNode;
              try {
                g1(y);
              } catch (mt) {
                Rn(e, e.return, mt);
              }
            }
            if (h & wt) {
              var k = e.stateNode;
              if (k != null) {
                var w = e.memoizedProps, _ = f !== null ? f.memoizedProps : w, L = e.type, A = e.updateQueue;
                if (e.updateQueue = null, A !== null)
                  try {
                    mN(k, A, L, _, w, e);
                  } catch (mt) {
                    Rn(e, e.return, mt);
                  }
              }
            }
          }
          return;
        }
        case N: {
          if (es(n, e), Ks(e), h & wt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var W = e.stateNode, $ = e.memoizedProps, re = f !== null ? f.memoizedProps : $;
            try {
              vN(W, re, $);
            } catch (mt) {
              Rn(e, e.return, mt);
            }
          }
          return;
        }
        case E: {
          if (es(n, e), Ks(e), h & wt && f !== null) {
            var le = f.memoizedState;
            if (le.isDehydrated)
              try {
                VN(n.containerInfo);
              } catch (mt) {
                Rn(e, e.return, mt);
              }
          }
          return;
        }
        case x: {
          es(n, e), Ks(e);
          return;
        }
        case F: {
          es(n, e), Ks(e);
          var me = e.child;
          if (me.flags & Os) {
            var ze = me.stateNode, ut = me.memoizedState, it = ut !== null;
            if (ze.isHidden = it, it) {
              var qt = me.alternate !== null && me.alternate.memoizedState !== null;
              qt || jA();
            }
          }
          if (h & wt) {
            try {
              rA(e);
            } catch (mt) {
              Rn(e, e.return, mt);
            }
            gR(e);
          }
          return;
        }
        case Ne: {
          var Ut = f !== null && f.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & rt
          ) {
            var J = di;
            di = J || Ut, es(n, e), di = J;
          } else
            es(n, e);
          if (Ks(e), h & Os) {
            var ve = e.stateNode, X = e.memoizedState, xe = X !== null, We = e;
            if (ve.isHidden = xe, xe && !Ut && (We.mode & rt) !== et) {
              Qe = We;
              for (var Ve = We.child; Ve !== null; )
                Qe = Ve, sA(Ve), Ve = Ve.sibling;
            }
            X2(We, xe);
          }
          return;
        }
        case se: {
          es(n, e), Ks(e), h & wt && gR(e);
          return;
        }
        case Ee:
          return;
        default: {
          es(n, e), Ks(e);
          return;
        }
      }
    }
    function Ks(e) {
      var n = e.flags;
      if (n & Tn) {
        try {
          tA(e);
        } catch (l) {
          Rn(e, e.return, l);
        }
        e.flags &= ~Tn;
      }
      n & ma && (e.flags &= ~ma);
    }
    function oA(e, n, l) {
      Ep = l, wp = n, Qe = e, bR(e, n, l), Ep = null, wp = null;
    }
    function bR(e, n, l) {
      for (var f = (e.mode & rt) !== et; Qe !== null; ) {
        var h = Qe, y = h.child;
        if (h.tag === Ne && f) {
          var k = h.memoizedState !== null, w = k || l0;
          if (w) {
            mk(e, n, l);
            continue;
          } else {
            var _ = h.alternate, L = _ !== null && _.memoizedState !== null, A = L || di, W = l0, $ = di;
            l0 = w, di = A, di && !$ && (Qe = h, lA(h));
            for (var re = y; re !== null; )
              Qe = re, bR(
                re,
                // New root; bubble back up to here and stop.
                n,
                l
              ), re = re.sibling;
            Qe = h, l0 = W, di = $, mk(e, n, l);
            continue;
          }
        }
        (h.subtreeFlags & Wr) !== st && y !== null ? (y.return = h, Qe = y) : mk(e, n, l);
      }
    }
    function mk(e, n, l) {
      for (; Qe !== null; ) {
        var f = Qe;
        if ((f.flags & Wr) !== st) {
          var h = f.alternate;
          sn(f);
          try {
            Q2(n, h, f, l);
          } catch (k) {
            Rn(f, f.return, k);
          }
          Vn();
        }
        if (f === e) {
          Qe = null;
          return;
        }
        var y = f.sibling;
        if (y !== null) {
          y.return = f.return, Qe = y;
          return;
        }
        Qe = f.return;
      }
    }
    function sA(e) {
      for (; Qe !== null; ) {
        var n = Qe, l = n.child;
        switch (n.tag) {
          case g:
          case Z:
          case K:
          case te: {
            if (n.mode & yt)
              try {
                Ys(), Xo(Nr, n, n.return);
              } finally {
                Gs(n);
              }
            else
              Xo(Nr, n, n.return);
            break;
          }
          case b: {
            Rp(n, n.return);
            var f = n.stateNode;
            typeof f.componentWillUnmount == "function" && fk(n, n.return, f);
            break;
          }
          case O: {
            Rp(n, n.return);
            break;
          }
          case Ne: {
            var h = n.memoizedState !== null;
            if (h) {
              SR(e);
              continue;
            }
            break;
          }
        }
        l !== null ? (l.return = n, Qe = l) : SR(e);
      }
    }
    function SR(e) {
      for (; Qe !== null; ) {
        var n = Qe;
        if (n === e) {
          Qe = null;
          return;
        }
        var l = n.sibling;
        if (l !== null) {
          l.return = n.return, Qe = l;
          return;
        }
        Qe = n.return;
      }
    }
    function lA(e) {
      for (; Qe !== null; ) {
        var n = Qe, l = n.child;
        if (n.tag === Ne) {
          var f = n.memoizedState !== null;
          if (f) {
            CR(e);
            continue;
          }
        }
        l !== null ? (l.return = n, Qe = l) : CR(e);
      }
    }
    function CR(e) {
      for (; Qe !== null; ) {
        var n = Qe;
        sn(n);
        try {
          J2(n);
        } catch (f) {
          Rn(n, n.return, f);
        }
        if (Vn(), n === e) {
          Qe = null;
          return;
        }
        var l = n.sibling;
        if (l !== null) {
          l.return = n.return, Qe = l;
          return;
        }
        Qe = n.return;
      }
    }
    function uA(e, n, l, f) {
      Qe = n, cA(n, e, l, f);
    }
    function cA(e, n, l, f) {
      for (; Qe !== null; ) {
        var h = Qe, y = h.child;
        (h.subtreeFlags & va) !== st && y !== null ? (y.return = h, Qe = y) : dA(e, n, l, f);
      }
    }
    function dA(e, n, l, f) {
      for (; Qe !== null; ) {
        var h = Qe;
        if ((h.flags & Pn) !== st) {
          sn(h);
          try {
            fA(n, h, l, f);
          } catch (k) {
            Rn(h, h.return, k);
          }
          Vn();
        }
        if (h === e) {
          Qe = null;
          return;
        }
        var y = h.sibling;
        if (y !== null) {
          y.return = h.return, Qe = y;
          return;
        }
        Qe = h.return;
      }
    }
    function fA(e, n, l, f) {
      switch (n.tag) {
        case g:
        case Z:
        case te: {
          if (n.mode & yt) {
            LC();
            try {
              oc(ui | Mr, n);
            } finally {
              NC(n);
            }
          } else
            oc(ui | Mr, n);
          break;
        }
      }
    }
    function pA(e) {
      Qe = e, hA();
    }
    function hA() {
      for (; Qe !== null; ) {
        var e = Qe, n = e.child;
        if ((Qe.flags & tn) !== st) {
          var l = e.deletions;
          if (l !== null) {
            for (var f = 0; f < l.length; f++) {
              var h = l[f];
              Qe = h, gA(h, e);
            }
            {
              var y = e.alternate;
              if (y !== null) {
                var k = y.child;
                if (k !== null) {
                  y.child = null;
                  do {
                    var w = k.sibling;
                    k.sibling = null, k = w;
                  } while (k !== null);
                }
              }
            }
            Qe = e;
          }
        }
        (e.subtreeFlags & va) !== st && n !== null ? (n.return = e, Qe = n) : mA();
      }
    }
    function mA() {
      for (; Qe !== null; ) {
        var e = Qe;
        (e.flags & Pn) !== st && (sn(e), vA(e), Vn());
        var n = e.sibling;
        if (n !== null) {
          n.return = e.return, Qe = n;
          return;
        }
        Qe = e.return;
      }
    }
    function vA(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          e.mode & yt ? (LC(), Xo(ui | Mr, e, e.return), NC(e)) : Xo(ui | Mr, e, e.return);
          break;
        }
      }
    }
    function gA(e, n) {
      for (; Qe !== null; ) {
        var l = Qe;
        sn(l), bA(l, n), Vn();
        var f = l.child;
        f !== null ? (f.return = l, Qe = f) : yA(e);
      }
    }
    function yA(e) {
      for (; Qe !== null; ) {
        var n = Qe, l = n.sibling, f = n.return;
        if (pR(n), n === e) {
          Qe = null;
          return;
        }
        if (l !== null) {
          l.return = f, Qe = l;
          return;
        }
        Qe = f;
      }
    }
    function bA(e, n) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          e.mode & yt ? (LC(), Xo(ui, e, n), NC(e)) : Xo(ui, e, n);
          break;
        }
      }
    }
    function SA(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          try {
            oc(Nr | Mr, e);
          } catch (l) {
            Rn(e, e.return, l);
          }
          break;
        }
        case b: {
          var n = e.stateNode;
          try {
            n.componentDidMount();
          } catch (l) {
            Rn(e, e.return, l);
          }
          break;
        }
      }
    }
    function CA(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          try {
            oc(ui | Mr, e);
          } catch (n) {
            Rn(e, e.return, n);
          }
          break;
        }
      }
    }
    function kA(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te: {
          try {
            Xo(Nr | Mr, e, e.return);
          } catch (l) {
            Rn(e, e.return, l);
          }
          break;
        }
        case b: {
          var n = e.stateNode;
          typeof n.componentWillUnmount == "function" && fk(e, e.return, n);
          break;
        }
      }
    }
    function TA(e) {
      switch (e.tag) {
        case g:
        case Z:
        case te:
          try {
            Xo(ui | Mr, e, e.return);
          } catch (n) {
            Rn(e, e.return, n);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var qm = Symbol.for;
      qm("selector.component"), qm("selector.has_pseudo_class"), qm("selector.role"), qm("selector.test_id"), qm("selector.text");
    }
    var EA = [];
    function wA() {
      EA.forEach(function(e) {
        return e();
      });
    }
    var RA = i.ReactCurrentActQueue;
    function _A(e) {
      {
        var n = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), l = typeof jest < "u";
        return l && n !== !1;
      }
    }
    function kR() {
      {
        var e = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && RA.current !== null && c("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var xA = Math.ceil, vk = i.ReactCurrentDispatcher, gk = i.ReactCurrentOwner, pi = i.ReactCurrentBatchConfig, ts = i.ReactCurrentActQueue, Ir = (
      /*             */
      0
    ), TR = (
      /*               */
      1
    ), hi = (
      /*                */
      2
    ), So = (
      /*                */
      4
    ), Vl = 0, Wm = 1, Rd = 2, c0 = 3, Gm = 4, ER = 5, yk = 6, $t = Ir, ra = null, Zn = null, Ur = Se, Qs = Se, bk = Ju(Se), Fr = Vl, Ym = null, d0 = Se, Km = Se, f0 = Se, Qm = null, Pa = null, Sk = 0, wR = 500, RR = 1 / 0, PA = 500, Bl = null;
    function Jm() {
      RR = Un() + PA;
    }
    function _R() {
      return RR;
    }
    var p0 = !1, Ck = null, _p = null, _d = !1, lc = null, Xm = Se, kk = [], Tk = null, DA = 50, Zm = 0, Ek = null, wk = !1, h0 = !1, OA = 50, xp = 0, m0 = null, ev = Sn, v0 = Se, xR = !1;
    function g0() {
      return ra;
    }
    function ia() {
      return ($t & (hi | So)) !== Ir ? Un() : (ev !== Sn || (ev = Un()), ev);
    }
    function uc(e) {
      var n = e.mode;
      if ((n & rt) === et)
        return ot;
      if (($t & hi) !== Ir && Ur !== Se)
        return Mu(Ur);
      var l = RL() !== wL;
      if (l) {
        if (pi.transition !== null) {
          var f = pi.transition;
          f._updatedFibers || (f._updatedFibers = /* @__PURE__ */ new Set()), f._updatedFibers.add(e);
        }
        return v0 === ir && (v0 = Pg()), v0;
      }
      var h = Ca();
      if (h !== ir)
        return h;
      var y = cN();
      return y;
    }
    function MA(e) {
      var n = e.mode;
      return (n & rt) === et ? ot : Li();
    }
    function jr(e, n, l, f) {
      nI(), xR && c("useInsertionEffect must not schedule updates."), wk && (h0 = !0), _l(e, l, f), ($t & hi) !== Se && e === ra ? aI(n) : (Zi && Af(e, n, l), oI(n), e === ra && (($t & hi) === Ir && (Km = Et(Km, l)), Fr === Gm && cc(e, Ur)), Da(e, f), l === ot && $t === Ir && (n.mode & rt) === et && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ts.isBatchingLegacy && (Jm(), x1()));
    }
    function NA(e, n, l) {
      var f = e.current;
      f.lanes = n, _l(e, n, l), Da(e, l);
    }
    function LA(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        ($t & hi) !== Ir
      );
    }
    function Da(e, n) {
      var l = e.callbackNode;
      Eg(e, n);
      var f = wl(e, e === ra ? Ur : Se);
      if (f === Se) {
        l !== null && $R(l), e.callbackNode = null, e.callbackPriority = ir;
        return;
      }
      var h = Qn(f), y = e.callbackPriority;
      if (y === h && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ts.current !== null && l !== Mk)) {
        l == null && y !== ot && c("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      l != null && $R(l);
      var k;
      if (h === ot)
        e.tag === Xu ? (ts.isBatchingLegacy !== null && (ts.didScheduleLegacyUpdate = !0), lL(OR.bind(null, e))) : _1(OR.bind(null, e)), ts.current !== null ? ts.current.push(Zu) : fN(function() {
          ($t & (hi | So)) === Ir && Zu();
        }), k = null;
      else {
        var w;
        switch (Or(f)) {
          case Jn:
            w = lf;
            break;
          case Vo:
            w = yl;
            break;
          case co:
            w = uo;
            break;
          case Nu:
            w = uf;
            break;
          default:
            w = uo;
            break;
        }
        k = Nk(w, PR.bind(null, e));
      }
      e.callbackPriority = h, e.callbackNode = k;
    }
    function PR(e, n) {
      if (XL(), ev = Sn, v0 = Se, ($t & (hi | So)) !== Ir)
        throw new Error("Should not already be working.");
      var l = e.callbackNode, f = $l();
      if (f && e.callbackNode !== l)
        return null;
      var h = wl(e, e === ra ? Ur : Se);
      if (h === Se)
        return null;
      var y = !Zc(e, h) && !xg(e, h) && !n, k = y ? $A(e, h) : b0(e, h);
      if (k !== Vl) {
        if (k === Rd) {
          var w = Is(e);
          w !== Se && (h = w, k = Rk(e, w));
        }
        if (k === Wm) {
          var _ = Ym;
          throw xd(e, Se), cc(e, h), Da(e, Un()), _;
        }
        if (k === yk)
          cc(e, h);
        else {
          var L = !Zc(e, h), A = e.current.alternate;
          if (L && !IA(A)) {
            if (k = b0(e, h), k === Rd) {
              var W = Is(e);
              W !== Se && (h = W, k = Rk(e, W));
            }
            if (k === Wm) {
              var $ = Ym;
              throw xd(e, Se), cc(e, h), Da(e, Un()), $;
            }
          }
          e.finishedWork = A, e.finishedLanes = h, AA(e, k, h);
        }
      }
      return Da(e, Un()), e.callbackNode === l ? PR.bind(null, e) : null;
    }
    function Rk(e, n) {
      var l = Qm;
      if (If(e)) {
        var f = xd(e, n);
        f.flags |= Bn, tL(e.containerInfo);
      }
      var h = b0(e, n);
      if (h !== Rd) {
        var y = Pa;
        Pa = l, y !== null && DR(y);
      }
      return h;
    }
    function DR(e) {
      Pa === null ? Pa = e : Pa.push.apply(Pa, e);
    }
    function AA(e, n, l) {
      switch (n) {
        case Vl:
        case Wm:
          throw new Error("Root did not complete. This is a bug in React.");
        case Rd: {
          Pd(e, Pa, Bl);
          break;
        }
        case c0: {
          if (cc(e, l), wg(l) && // do not delay if we're inside an act() scope
          !qR()) {
            var f = Sk + wR - Un();
            if (f > 10) {
              var h = wl(e, Se);
              if (h !== Se)
                break;
              var y = e.suspendedLanes;
              if (!Rl(y, l)) {
                ia(), Nf(e, y);
                break;
              }
              e.timeoutHandle = TS(Pd.bind(null, e, Pa, Bl), f);
              break;
            }
          }
          Pd(e, Pa, Bl);
          break;
        }
        case Gm: {
          if (cc(e, l), _g(l))
            break;
          if (!qR()) {
            var k = kg(e, l), w = k, _ = Un() - w, L = tI(_) - _;
            if (L > 10) {
              e.timeoutHandle = TS(Pd.bind(null, e, Pa, Bl), L);
              break;
            }
          }
          Pd(e, Pa, Bl);
          break;
        }
        case ER: {
          Pd(e, Pa, Bl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function IA(e) {
      for (var n = e; ; ) {
        if (n.flags & Hc) {
          var l = n.updateQueue;
          if (l !== null) {
            var f = l.stores;
            if (f !== null)
              for (var h = 0; h < f.length; h++) {
                var y = f[h], k = y.getSnapshot, w = y.value;
                try {
                  if (!Ke(k(), w))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var _ = n.child;
        if (n.subtreeFlags & Hc && _ !== null) {
          _.return = n, n = _;
          continue;
        }
        if (n === e)
          return !0;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e)
            return !0;
          n = n.return;
        }
        n.sibling.return = n.return, n = n.sibling;
      }
      return !0;
    }
    function cc(e, n) {
      n = ed(n, f0), n = ed(n, Km), Og(e, n);
    }
    function OR(e) {
      if (ZL(), ($t & (hi | So)) !== Ir)
        throw new Error("Should not already be working.");
      $l();
      var n = wl(e, Se);
      if (!Ai(n, ot))
        return Da(e, Un()), null;
      var l = b0(e, n);
      if (e.tag !== Xu && l === Rd) {
        var f = Is(e);
        f !== Se && (n = f, l = Rk(e, f));
      }
      if (l === Wm) {
        var h = Ym;
        throw xd(e, Se), cc(e, n), Da(e, Un()), h;
      }
      if (l === yk)
        throw new Error("Root did not complete. This is a bug in React.");
      var y = e.current.alternate;
      return e.finishedWork = y, e.finishedLanes = n, Pd(e, Pa, Bl), Da(e, Un()), null;
    }
    function UA(e, n) {
      n !== Se && ($h(e, Et(n, ot)), Da(e, Un()), ($t & (hi | So)) === Ir && (Jm(), Zu()));
    }
    function _k(e, n) {
      var l = $t;
      $t |= TR;
      try {
        return e(n);
      } finally {
        $t = l, $t === Ir && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ts.isBatchingLegacy && (Jm(), x1());
      }
    }
    function FA(e, n, l, f, h) {
      var y = Ca(), k = pi.transition;
      try {
        return pi.transition = null, Hn(Jn), e(n, l, f, h);
      } finally {
        Hn(y), pi.transition = k, $t === Ir && Jm();
      }
    }
    function Hl(e) {
      lc !== null && lc.tag === Xu && ($t & (hi | So)) === Ir && $l();
      var n = $t;
      $t |= TR;
      var l = pi.transition, f = Ca();
      try {
        return pi.transition = null, Hn(Jn), e ? e() : void 0;
      } finally {
        Hn(f), pi.transition = l, $t = n, ($t & (hi | So)) === Ir && Zu();
      }
    }
    function MR() {
      return ($t & (hi | So)) !== Ir;
    }
    function y0(e, n) {
      Fi(bk, Qs, e), Qs = Et(Qs, n);
    }
    function xk(e) {
      Qs = bk.current, Ui(bk, e);
    }
    function xd(e, n) {
      e.finishedWork = null, e.finishedLanes = Se;
      var l = e.timeoutHandle;
      if (l !== ES && (e.timeoutHandle = ES, dN(l)), Zn !== null)
        for (var f = Zn.return; f !== null; ) {
          var h = f.alternate;
          sR(h, f), f = f.return;
        }
      ra = e;
      var y = Dd(e.current, null);
      return Zn = y, Ur = Qs = n, Fr = Vl, Ym = null, d0 = Se, Km = Se, f0 = Se, Qm = null, Pa = null, NL(), Go.discardPendingWarnings(), y;
    }
    function NR(e, n) {
      do {
        var l = Zn;
        try {
          if (xy(), rw(), Vn(), gk.current = null, l === null || l.return === null) {
            Fr = Wm, Ym = n, Zn = null;
            return;
          }
          if (Rt && l.mode & yt && r0(l, !0), kt)
            if (Mi(), n !== null && typeof n == "object" && typeof n.then == "function") {
              var f = n;
              Sl(l, f, Ur);
            } else
              Wc(l, n, Ur);
          l2(e, l.return, l, n, Ur), UR(l);
        } catch (h) {
          n = h, Zn === l && l !== null ? (l = l.return, Zn = l) : l = Zn;
          continue;
        }
        return;
      } while (!0);
    }
    function LR() {
      var e = vk.current;
      return vk.current = Xy, e === null ? Xy : e;
    }
    function AR(e) {
      vk.current = e;
    }
    function jA() {
      Sk = Un();
    }
    function tv(e) {
      d0 = Et(e, d0);
    }
    function zA() {
      Fr === Vl && (Fr = c0);
    }
    function Pk() {
      (Fr === Vl || Fr === c0 || Fr === Rd) && (Fr = Gm), ra !== null && (Xc(d0) || Xc(Km)) && cc(ra, Ur);
    }
    function VA(e) {
      Fr !== Gm && (Fr = Rd), Qm === null ? Qm = [e] : Qm.push(e);
    }
    function BA() {
      return Fr === Vl;
    }
    function b0(e, n) {
      var l = $t;
      $t |= hi;
      var f = LR();
      if (ra !== e || Ur !== n) {
        if (Zi) {
          var h = e.memoizedUpdaters;
          h.size > 0 && (nv(e, Ur), h.clear()), qh(e, n);
        }
        Bl = nd(), xd(e, n);
      }
      Dn(n);
      do
        try {
          HA();
          break;
        } catch (y) {
          NR(e, y);
        }
      while (!0);
      if (xy(), $t = l, AR(f), Zn !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return hf(), ra = null, Ur = Se, Fr;
    }
    function HA() {
      for (; Zn !== null; )
        IR(Zn);
    }
    function $A(e, n) {
      var l = $t;
      $t |= hi;
      var f = LR();
      if (ra !== e || Ur !== n) {
        if (Zi) {
          var h = e.memoizedUpdaters;
          h.size > 0 && (nv(e, Ur), h.clear()), qh(e, n);
        }
        Bl = nd(), Jm(), xd(e, n);
      }
      Dn(n);
      do
        try {
          qA();
          break;
        } catch (y) {
          NR(e, y);
        }
      while (!0);
      return xy(), AR(f), $t = l, Zn !== null ? (pf(), Vl) : (hf(), ra = null, Ur = Se, Fr);
    }
    function qA() {
      for (; Zn !== null && !sf(); )
        IR(Zn);
    }
    function IR(e) {
      var n = e.alternate;
      sn(e);
      var l;
      (e.mode & yt) !== et ? (MC(e), l = Dk(n, e, Qs), r0(e, !0)) : l = Dk(n, e, Qs), Vn(), e.memoizedProps = e.pendingProps, l === null ? UR(e) : Zn = l, gk.current = null;
    }
    function UR(e) {
      var n = e;
      do {
        var l = n.alternate, f = n.return;
        if ((n.flags & Qi) === st) {
          sn(n);
          var h = void 0;
          if ((n.mode & yt) === et ? h = oR(l, n, Qs) : (MC(n), h = oR(l, n, Qs), r0(n, !1)), Vn(), h !== null) {
            Zn = h;
            return;
          }
        } else {
          var y = z2(l, n);
          if (y !== null) {
            y.flags &= dg, Zn = y;
            return;
          }
          if ((n.mode & yt) !== et) {
            r0(n, !1);
            for (var k = n.actualDuration, w = n.child; w !== null; )
              k += w.actualDuration, w = w.sibling;
            n.actualDuration = k;
          }
          if (f !== null)
            f.flags |= Qi, f.subtreeFlags = st, f.deletions = null;
          else {
            Fr = yk, Zn = null;
            return;
          }
        }
        var _ = n.sibling;
        if (_ !== null) {
          Zn = _;
          return;
        }
        n = f, Zn = n;
      } while (n !== null);
      Fr === Vl && (Fr = ER);
    }
    function Pd(e, n, l) {
      var f = Ca(), h = pi.transition;
      try {
        pi.transition = null, Hn(Jn), WA(e, n, l, f);
      } finally {
        pi.transition = h, Hn(f);
      }
      return null;
    }
    function WA(e, n, l, f) {
      do
        $l();
      while (lc !== null);
      if (rI(), ($t & (hi | So)) !== Ir)
        throw new Error("Should not already be working.");
      var h = e.finishedWork, y = e.finishedLanes;
      if (Ns(y), h === null)
        return cf(), null;
      if (y === Se && c("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = Se, h === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = ir;
      var k = Et(h.lanes, h.childLanes);
      Lf(e, k), e === ra && (ra = null, Zn = null, Ur = Se), ((h.subtreeFlags & va) !== st || (h.flags & va) !== st) && (_d || (_d = !0, Tk = l, Nk(uo, function() {
        return $l(), null;
      })));
      var w = (h.subtreeFlags & (bu | Di | Wr | va)) !== st, _ = (h.flags & (bu | Di | Wr | va)) !== st;
      if (w || _) {
        var L = pi.transition;
        pi.transition = null;
        var A = Ca();
        Hn(Jn);
        var W = $t;
        $t |= So, gk.current = null, q2(e, h), xw(), aA(e, h, y), iN(e.containerInfo), e.current = h, Ih(y), oA(h, e, y), Eu(), hg(), $t = W, Hn(A), pi.transition = L;
      } else
        e.current = h, xw();
      var $ = _d;
      if (_d ? (_d = !1, lc = e, Xm = y) : (xp = 0, m0 = null), k = e.pendingLanes, k === Se && (_p = null), $ || VR(e.current, !1), Cu(h.stateNode, f), Zi && e.memoizedUpdaters.clear(), wA(), Da(e, Un()), n !== null)
        for (var re = e.onRecoverableError, le = 0; le < n.length; le++) {
          var me = n[le], ze = me.stack, ut = me.digest;
          re(me.value, {
            componentStack: ze,
            digest: ut
          });
        }
      if (p0) {
        p0 = !1;
        var it = Ck;
        throw Ck = null, it;
      }
      return Ai(Xm, ot) && e.tag !== Xu && $l(), k = e.pendingLanes, Ai(k, ot) ? (JL(), e === Ek ? Zm++ : (Zm = 0, Ek = e)) : Zm = 0, Zu(), cf(), null;
    }
    function $l() {
      if (lc !== null) {
        var e = Or(Xm), n = Yb(co, e), l = pi.transition, f = Ca();
        try {
          return pi.transition = null, Hn(n), YA();
        } finally {
          Hn(f), pi.transition = l;
        }
      }
      return !1;
    }
    function GA(e) {
      kk.push(e), _d || (_d = !0, Nk(uo, function() {
        return $l(), null;
      }));
    }
    function YA() {
      if (lc === null)
        return !1;
      var e = Tk;
      Tk = null;
      var n = lc, l = Xm;
      if (lc = null, Xm = Se, ($t & (hi | So)) !== Ir)
        throw new Error("Cannot flush passive effects while already rendering.");
      wk = !0, h0 = !1, Sg(l);
      var f = $t;
      $t |= So, pA(n.current), uA(n, n.current, l, e);
      {
        var h = kk;
        kk = [];
        for (var y = 0; y < h.length; y++) {
          var k = h[y];
          K2(n, k);
        }
      }
      Uh(), VR(n.current, !0), $t = f, Zu(), h0 ? n === m0 ? xp++ : (xp = 0, m0 = n) : xp = 0, wk = !1, h0 = !1, ba(n);
      {
        var w = n.current.stateNode;
        w.effectDuration = 0, w.passiveEffectDuration = 0;
      }
      return !0;
    }
    function FR(e) {
      return _p !== null && _p.has(e);
    }
    function KA(e) {
      _p === null ? _p = /* @__PURE__ */ new Set([e]) : _p.add(e);
    }
    function QA(e) {
      p0 || (p0 = !0, Ck = e);
    }
    var JA = QA;
    function jR(e, n, l) {
      var f = Ed(l, n), h = Iw(e, f, ot), y = tc(e, h, ot), k = ia();
      y !== null && (_l(y, ot, k), Da(y, k));
    }
    function Rn(e, n, l) {
      if (B2(l), rv(!1), e.tag === E) {
        jR(e, e, l);
        return;
      }
      var f = null;
      for (f = n; f !== null; ) {
        if (f.tag === E) {
          jR(f, e, l);
          return;
        } else if (f.tag === b) {
          var h = f.type, y = f.stateNode;
          if (typeof h.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && !FR(y)) {
            var k = Ed(l, e), w = QC(f, k, ot), _ = tc(f, w, ot), L = ia();
            _ !== null && (_l(_, ot, L), Da(_, L));
            return;
          }
        }
        f = f.return;
      }
      c(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, l);
    }
    function XA(e, n, l) {
      var f = e.pingCache;
      f !== null && f.delete(n);
      var h = ia();
      Nf(e, l), sI(e), ra === e && Rl(Ur, l) && (Fr === Gm || Fr === c0 && wg(Ur) && Un() - Sk < wR ? xd(e, Se) : f0 = Et(f0, l)), Da(e, h);
    }
    function zR(e, n) {
      n === ir && (n = MA(e));
      var l = ia(), f = _a(e, n);
      f !== null && (_l(f, n, l), Da(f, l));
    }
    function ZA(e) {
      var n = e.memoizedState, l = ir;
      n !== null && (l = n.retryLane), zR(e, l);
    }
    function eI(e, n) {
      var l = ir, f;
      switch (e.tag) {
        case F:
          f = e.stateNode;
          var h = e.memoizedState;
          h !== null && (l = h.retryLane);
          break;
        case se:
          f = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      f !== null && f.delete(n), zR(e, l);
    }
    function tI(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : xA(e / 1960) * 1960;
    }
    function nI() {
      if (Zm > DA)
        throw Zm = 0, Ek = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      xp > OA && (xp = 0, m0 = null, c("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function rI() {
      Go.flushLegacyContextWarning(), Go.flushPendingUnsafeLifecycleWarnings();
    }
    function VR(e, n) {
      sn(e), S0(e, Pi, kA), n && S0(e, gl, TA), S0(e, Pi, SA), n && S0(e, gl, CA), Vn();
    }
    function S0(e, n, l) {
      for (var f = e, h = null; f !== null; ) {
        var y = f.subtreeFlags & n;
        f !== h && f.child !== null && y !== st ? f = f.child : ((f.flags & n) !== st && l(f), f.sibling !== null ? f = f.sibling : f = h = f.return);
      }
    }
    var C0 = null;
    function BR(e) {
      {
        if (($t & hi) !== Ir || !(e.mode & rt))
          return;
        var n = e.tag;
        if (n !== C && n !== E && n !== b && n !== g && n !== Z && n !== K && n !== te)
          return;
        var l = bt(e) || "ReactComponent";
        if (C0 !== null) {
          if (C0.has(l))
            return;
          C0.add(l);
        } else
          C0 = /* @__PURE__ */ new Set([l]);
        var f = In;
        try {
          sn(e), c("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          f ? sn(e) : Vn();
        }
      }
    }
    var Dk;
    {
      var iI = null;
      Dk = function(e, n, l) {
        var f = QR(iI, n);
        try {
          return tR(e, n, l);
        } catch (y) {
          if (vL() || y !== null && typeof y == "object" && typeof y.then == "function")
            throw y;
          if (xy(), rw(), sR(e, n), QR(n, f), n.mode & yt && MC(n), vl(null, tR, null, e, n, l), Hb()) {
            var h = _h();
            typeof h == "object" && h !== null && h._suppressLogging && typeof y == "object" && y !== null && !y._suppressLogging && (y._suppressLogging = !0);
          }
          throw y;
        }
      };
    }
    var HR = !1, Ok;
    Ok = /* @__PURE__ */ new Set();
    function aI(e) {
      if (Ei && !YL())
        switch (e.tag) {
          case g:
          case Z:
          case te: {
            var n = Zn && bt(Zn) || "Unknown", l = n;
            if (!Ok.has(l)) {
              Ok.add(l);
              var f = bt(e) || "Unknown";
              c("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", f, n, n);
            }
            break;
          }
          case b: {
            HR || (c("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), HR = !0);
            break;
          }
        }
    }
    function nv(e, n) {
      if (Zi) {
        var l = e.memoizedUpdaters;
        l.forEach(function(f) {
          Af(e, f, n);
        });
      }
    }
    var Mk = {};
    function Nk(e, n) {
      {
        var l = ts.current;
        return l !== null ? (l.push(n), Mk) : of(e, n);
      }
    }
    function $R(e) {
      if (e !== Mk)
        return pg(e);
    }
    function qR() {
      return ts.current !== null;
    }
    function oI(e) {
      {
        if (e.mode & rt) {
          if (!kR())
            return;
        } else if (!_A() || $t !== Ir || e.tag !== g && e.tag !== Z && e.tag !== te)
          return;
        if (ts.current === null) {
          var n = In;
          try {
            sn(e), c(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, bt(e));
          } finally {
            n ? sn(e) : Vn();
          }
        }
      }
    }
    function sI(e) {
      e.tag !== Xu && kR() && ts.current === null && c(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function rv(e) {
      xR = e;
    }
    var Co = null, Pp = null, lI = function(e) {
      Co = e;
    };
    function Dp(e) {
      {
        if (Co === null)
          return e;
        var n = Co(e);
        return n === void 0 ? e : n.current;
      }
    }
    function Lk(e) {
      return Dp(e);
    }
    function Ak(e) {
      {
        if (Co === null)
          return e;
        var n = Co(e);
        if (n === void 0) {
          if (e != null && typeof e.render == "function") {
            var l = Dp(e.render);
            if (e.render !== l) {
              var f = {
                $$typeof: _e,
                render: l
              };
              return e.displayName !== void 0 && (f.displayName = e.displayName), f;
            }
          }
          return e;
        }
        return n.current;
      }
    }
    function WR(e, n) {
      {
        if (Co === null)
          return !1;
        var l = e.elementType, f = n.type, h = !1, y = typeof f == "object" && f !== null ? f.$$typeof : null;
        switch (e.tag) {
          case b: {
            typeof f == "function" && (h = !0);
            break;
          }
          case g: {
            (typeof f == "function" || y === dt) && (h = !0);
            break;
          }
          case Z: {
            (y === _e || y === dt) && (h = !0);
            break;
          }
          case K:
          case te: {
            (y === jt || y === dt) && (h = !0);
            break;
          }
          default:
            return !1;
        }
        if (h) {
          var k = Co(l);
          if (k !== void 0 && k === Co(f))
            return !0;
        }
        return !1;
      }
    }
    function GR(e) {
      {
        if (Co === null || typeof WeakSet != "function")
          return;
        Pp === null && (Pp = /* @__PURE__ */ new WeakSet()), Pp.add(e);
      }
    }
    var uI = function(e, n) {
      {
        if (Co === null)
          return;
        var l = n.staleFamilies, f = n.updatedFamilies;
        $l(), Hl(function() {
          Ik(e.current, f, l);
        });
      }
    }, cI = function(e, n) {
      {
        if (e.context !== Ya)
          return;
        $l(), Hl(function() {
          iv(n, e, null, null);
        });
      }
    };
    function Ik(e, n, l) {
      {
        var f = e.alternate, h = e.child, y = e.sibling, k = e.tag, w = e.type, _ = null;
        switch (k) {
          case g:
          case te:
          case b:
            _ = w;
            break;
          case Z:
            _ = w.render;
            break;
        }
        if (Co === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var L = !1, A = !1;
        if (_ !== null) {
          var W = Co(_);
          W !== void 0 && (l.has(W) ? A = !0 : n.has(W) && (k === b ? A = !0 : L = !0));
        }
        if (Pp !== null && (Pp.has(e) || f !== null && Pp.has(f)) && (A = !0), A && (e._debugNeedsRemount = !0), A || L) {
          var $ = _a(e, ot);
          $ !== null && jr($, e, ot, Sn);
        }
        h !== null && !A && Ik(h, n, l), y !== null && Ik(y, n, l);
      }
    }
    var dI = function(e, n) {
      {
        var l = /* @__PURE__ */ new Set(), f = new Set(n.map(function(h) {
          return h.current;
        }));
        return Uk(e.current, f, l), l;
      }
    };
    function Uk(e, n, l) {
      {
        var f = e.child, h = e.sibling, y = e.tag, k = e.type, w = null;
        switch (y) {
          case g:
          case te:
          case b:
            w = k;
            break;
          case Z:
            w = k.render;
            break;
        }
        var _ = !1;
        w !== null && n.has(w) && (_ = !0), _ ? fI(e, l) : f !== null && Uk(f, n, l), h !== null && Uk(h, n, l);
      }
    }
    function fI(e, n) {
      {
        var l = pI(e, n);
        if (l)
          return;
        for (var f = e; ; ) {
          switch (f.tag) {
            case O:
              n.add(f.stateNode);
              return;
            case x:
              n.add(f.stateNode.containerInfo);
              return;
            case E:
              n.add(f.stateNode.containerInfo);
              return;
          }
          if (f.return === null)
            throw new Error("Expected to reach root first.");
          f = f.return;
        }
      }
    }
    function pI(e, n) {
      for (var l = e, f = !1; ; ) {
        if (l.tag === O)
          f = !0, n.add(l.stateNode);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === e)
          return f;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === e)
            return f;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return !1;
    }
    var Fk;
    {
      Fk = !1;
      try {
        var YR = Object.preventExtensions({});
      } catch {
        Fk = !0;
      }
    }
    function hI(e, n, l, f) {
      this.tag = e, this.key = l, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = n, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = f, this.flags = st, this.subtreeFlags = st, this.deletions = null, this.lanes = Se, this.childLanes = Se, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Fk && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ka = function(e, n, l, f) {
      return new hI(e, n, l, f);
    };
    function jk(e) {
      var n = e.prototype;
      return !!(n && n.isReactComponent);
    }
    function mI(e) {
      return typeof e == "function" && !jk(e) && e.defaultProps === void 0;
    }
    function vI(e) {
      if (typeof e == "function")
        return jk(e) ? b : g;
      if (e != null) {
        var n = e.$$typeof;
        if (n === _e)
          return Z;
        if (n === jt)
          return K;
      }
      return C;
    }
    function Dd(e, n) {
      var l = e.alternate;
      l === null ? (l = Ka(e.tag, n, e.key, e.mode), l.elementType = e.elementType, l.type = e.type, l.stateNode = e.stateNode, l._debugSource = e._debugSource, l._debugOwner = e._debugOwner, l._debugHookTypes = e._debugHookTypes, l.alternate = e, e.alternate = l) : (l.pendingProps = n, l.type = e.type, l.flags = st, l.subtreeFlags = st, l.deletions = null, l.actualDuration = 0, l.actualStartTime = -1), l.flags = e.flags & Pr, l.childLanes = e.childLanes, l.lanes = e.lanes, l.child = e.child, l.memoizedProps = e.memoizedProps, l.memoizedState = e.memoizedState, l.updateQueue = e.updateQueue;
      var f = e.dependencies;
      switch (l.dependencies = f === null ? null : {
        lanes: f.lanes,
        firstContext: f.firstContext
      }, l.sibling = e.sibling, l.index = e.index, l.ref = e.ref, l.selfBaseDuration = e.selfBaseDuration, l.treeBaseDuration = e.treeBaseDuration, l._debugNeedsRemount = e._debugNeedsRemount, l.tag) {
        case C:
        case g:
        case te:
          l.type = Dp(e.type);
          break;
        case b:
          l.type = Lk(e.type);
          break;
        case Z:
          l.type = Ak(e.type);
          break;
      }
      return l;
    }
    function gI(e, n) {
      e.flags &= Pr | Tn;
      var l = e.alternate;
      if (l === null)
        e.childLanes = Se, e.lanes = n, e.child = null, e.subtreeFlags = st, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = l.childLanes, e.lanes = l.lanes, e.child = l.child, e.subtreeFlags = st, e.deletions = null, e.memoizedProps = l.memoizedProps, e.memoizedState = l.memoizedState, e.updateQueue = l.updateQueue, e.type = l.type;
        var f = l.dependencies;
        e.dependencies = f === null ? null : {
          lanes: f.lanes,
          firstContext: f.firstContext
        }, e.selfBaseDuration = l.selfBaseDuration, e.treeBaseDuration = l.treeBaseDuration;
      }
      return e;
    }
    function yI(e, n, l) {
      var f;
      return e === yy ? (f = rt, n === !0 && (f |= At, f |= ea)) : f = et, Zi && (f |= yt), Ka(E, null, null, f);
    }
    function zk(e, n, l, f, h, y) {
      var k = C, w = e;
      if (typeof e == "function")
        jk(e) ? (k = b, w = Lk(w)) : w = Dp(w);
      else if (typeof e == "string")
        k = O;
      else
        e:
          switch (e) {
            case Ki:
              return dc(l.children, h, y, n);
            case no:
              k = I, h |= At, (h & rt) !== et && (h |= ea);
              break;
            case ro:
              return bI(l, h, y, n);
            case nt:
              return SI(l, h, y, n);
            case Nt:
              return CI(l, h, y, n);
            case hn:
              return KR(l, h, y, n);
            case kn:
            case xt:
            case qr:
            case io:
            case tr:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case V:
                    k = ae;
                    break e;
                  case ke:
                    k = U;
                    break e;
                  case _e:
                    k = Z, w = Ak(w);
                    break e;
                  case jt:
                    k = K;
                    break e;
                  case dt:
                    k = he, w = null;
                    break e;
                }
              var _ = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (_ += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var L = f ? bt(f) : null;
                L && (_ += `

Check the render method of \`` + L + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + _));
            }
          }
      var A = Ka(k, l, n, h);
      return A.elementType = e, A.type = w, A.lanes = y, A._debugOwner = f, A;
    }
    function Vk(e, n, l) {
      var f = null;
      f = e._owner;
      var h = e.type, y = e.key, k = e.props, w = zk(h, y, k, f, n, l);
      return w._debugSource = e._source, w._debugOwner = e._owner, w;
    }
    function dc(e, n, l, f) {
      var h = Ka(M, e, f, n);
      return h.lanes = l, h;
    }
    function bI(e, n, l, f) {
      typeof e.id != "string" && c('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var h = Ka(B, e, f, n | yt);
      return h.elementType = ro, h.lanes = l, h.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, h;
    }
    function SI(e, n, l, f) {
      var h = Ka(F, e, f, n);
      return h.elementType = nt, h.lanes = l, h;
    }
    function CI(e, n, l, f) {
      var h = Ka(se, e, f, n);
      return h.elementType = Nt, h.lanes = l, h;
    }
    function KR(e, n, l, f) {
      var h = Ka(Ne, e, f, n);
      h.elementType = hn, h.lanes = l;
      var y = {
        isHidden: !1
      };
      return h.stateNode = y, h;
    }
    function Bk(e, n, l) {
      var f = Ka(N, e, null, n);
      return f.lanes = l, f;
    }
    function kI() {
      var e = Ka(O, null, null, et);
      return e.elementType = "DELETED", e;
    }
    function TI(e) {
      var n = Ka(ye, null, null, et);
      return n.stateNode = e, n;
    }
    function Hk(e, n, l) {
      var f = e.children !== null ? e.children : [], h = Ka(x, f, e.key, n);
      return h.lanes = l, h.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, h;
    }
    function QR(e, n) {
      return e === null && (e = Ka(C, null, null, et)), e.tag = n.tag, e.key = n.key, e.elementType = n.elementType, e.type = n.type, e.stateNode = n.stateNode, e.return = n.return, e.child = n.child, e.sibling = n.sibling, e.index = n.index, e.ref = n.ref, e.pendingProps = n.pendingProps, e.memoizedProps = n.memoizedProps, e.updateQueue = n.updateQueue, e.memoizedState = n.memoizedState, e.dependencies = n.dependencies, e.mode = n.mode, e.flags = n.flags, e.subtreeFlags = n.subtreeFlags, e.deletions = n.deletions, e.lanes = n.lanes, e.childLanes = n.childLanes, e.alternate = n.alternate, e.actualDuration = n.actualDuration, e.actualStartTime = n.actualStartTime, e.selfBaseDuration = n.selfBaseDuration, e.treeBaseDuration = n.treeBaseDuration, e._debugSource = n._debugSource, e._debugOwner = n._debugOwner, e._debugNeedsRemount = n._debugNeedsRemount, e._debugHookTypes = n._debugHookTypes, e;
    }
    function EI(e, n, l, f, h) {
      this.tag = n, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = ES, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = ir, this.eventTimes = td(Se), this.expirationTimes = td(Sn), this.pendingLanes = Se, this.suspendedLanes = Se, this.pingedLanes = Se, this.expiredLanes = Se, this.mutableReadLanes = Se, this.finishedLanes = Se, this.entangledLanes = Se, this.entanglements = td(Se), this.identifierPrefix = f, this.onRecoverableError = h, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var y = this.pendingUpdatersLaneMap = [], k = 0; k < Kc; k++)
          y.push(/* @__PURE__ */ new Set());
      }
      switch (n) {
        case yy:
          this._debugRootType = l ? "hydrateRoot()" : "createRoot()";
          break;
        case Xu:
          this._debugRootType = l ? "hydrate()" : "render()";
          break;
      }
    }
    function JR(e, n, l, f, h, y, k, w, _, L) {
      var A = new EI(e, n, l, w, _), W = yI(n, y);
      A.current = W, W.stateNode = A;
      {
        var $ = {
          element: f,
          isDehydrated: l,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        W.memoizedState = $;
      }
      return nC(W), A;
    }
    var $k = "18.3.1";
    function wI(e, n, l) {
      var f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Si(f), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ti,
        key: f == null ? null : "" + f,
        children: e,
        containerInfo: n,
        implementation: l
      };
    }
    var qk, Wk;
    qk = !1, Wk = {};
    function XR(e) {
      if (!e)
        return Ya;
      var n = pa(e), l = sL(n);
      if (n.tag === b) {
        var f = n.type;
        if (Hs(f))
          return w1(n, f, l);
      }
      return l;
    }
    function RI(e, n) {
      {
        var l = pa(e);
        if (l === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var f = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + f);
        }
        var h = ga(l);
        if (h === null)
          return null;
        if (h.mode & At) {
          var y = bt(l) || "Component";
          if (!Wk[y]) {
            Wk[y] = !0;
            var k = In;
            try {
              sn(h), l.mode & At ? c("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", n, n, y) : c("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", n, n, y);
            } finally {
              k ? sn(k) : Vn();
            }
          }
        }
        return h.stateNode;
      }
    }
    function ZR(e, n, l, f, h, y, k, w) {
      var _ = !1, L = null;
      return JR(e, n, _, L, l, f, h, y, k);
    }
    function e_(e, n, l, f, h, y, k, w, _, L) {
      var A = !0, W = JR(l, f, A, e, h, y, k, w, _);
      W.context = XR(null);
      var $ = W.current, re = ia(), le = uc($), me = jl(re, le);
      return me.callback = n ?? null, tc($, me, le), NA(W, le, re), W;
    }
    function iv(e, n, l, f) {
      Ah(n, e);
      var h = n.current, y = ia(), k = uc(h);
      Fh(k);
      var w = XR(l);
      n.context === null ? n.context = w : n.pendingContext = w, Ei && In !== null && !qk && (qk = !0, c(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, bt(In) || "Unknown"));
      var _ = jl(y, k);
      _.payload = {
        element: e
      }, f = f === void 0 ? null : f, f !== null && (typeof f != "function" && c("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f), _.callback = f);
      var L = tc(h, _, k);
      return L !== null && (jr(L, h, k, y), Ny(L, h, k)), k;
    }
    function k0(e) {
      var n = e.current;
      if (!n.child)
        return null;
      switch (n.child.tag) {
        case O:
          return n.child.stateNode;
        default:
          return n.child.stateNode;
      }
    }
    function _I(e) {
      switch (e.tag) {
        case E: {
          var n = e.stateNode;
          if (If(n)) {
            var l = Vh(n);
            UA(n, l);
          }
          break;
        }
        case F: {
          Hl(function() {
            var h = _a(e, ot);
            if (h !== null) {
              var y = ia();
              jr(h, e, ot, y);
            }
          });
          var f = ot;
          Gk(e, f);
          break;
        }
      }
    }
    function t_(e, n) {
      var l = e.memoizedState;
      l !== null && l.dehydrated !== null && (l.retryLane = Dg(l.retryLane, n));
    }
    function Gk(e, n) {
      t_(e, n);
      var l = e.alternate;
      l && t_(l, n);
    }
    function xI(e) {
      if (e.tag === F) {
        var n = Jc, l = _a(e, n);
        if (l !== null) {
          var f = ia();
          jr(l, e, n, f);
        }
        Gk(e, n);
      }
    }
    function PI(e) {
      if (e.tag === F) {
        var n = uc(e), l = _a(e, n);
        if (l !== null) {
          var f = ia();
          jr(l, e, n, f);
        }
        Gk(e, n);
      }
    }
    function n_(e) {
      var n = fg(e);
      return n === null ? null : n.stateNode;
    }
    var r_ = function(e) {
      return null;
    };
    function DI(e) {
      return r_(e);
    }
    var i_ = function(e) {
      return !1;
    };
    function OI(e) {
      return i_(e);
    }
    var a_ = null, o_ = null, s_ = null, l_ = null, u_ = null, c_ = null, d_ = null, f_ = null, p_ = null;
    {
      var h_ = function(e, n, l) {
        var f = n[l], h = Vt(e) ? e.slice() : Pt({}, e);
        return l + 1 === n.length ? (Vt(h) ? h.splice(f, 1) : delete h[f], h) : (h[f] = h_(e[f], n, l + 1), h);
      }, m_ = function(e, n) {
        return h_(e, n, 0);
      }, v_ = function(e, n, l, f) {
        var h = n[f], y = Vt(e) ? e.slice() : Pt({}, e);
        if (f + 1 === n.length) {
          var k = l[f];
          y[k] = y[h], Vt(y) ? y.splice(h, 1) : delete y[h];
        } else
          y[h] = v_(
            // $FlowFixMe number or string is fine here
            e[h],
            n,
            l,
            f + 1
          );
        return y;
      }, g_ = function(e, n, l) {
        if (n.length !== l.length) {
          d("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var f = 0; f < l.length - 1; f++)
            if (n[f] !== l[f]) {
              d("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return v_(e, n, l, 0);
      }, y_ = function(e, n, l, f) {
        if (l >= n.length)
          return f;
        var h = n[l], y = Vt(e) ? e.slice() : Pt({}, e);
        return y[h] = y_(e[h], n, l + 1, f), y;
      }, b_ = function(e, n, l) {
        return y_(e, n, 0, l);
      }, Yk = function(e, n) {
        for (var l = e.memoizedState; l !== null && n > 0; )
          l = l.next, n--;
        return l;
      };
      a_ = function(e, n, l, f) {
        var h = Yk(e, n);
        if (h !== null) {
          var y = b_(h.memoizedState, l, f);
          h.memoizedState = y, h.baseState = y, e.memoizedProps = Pt({}, e.memoizedProps);
          var k = _a(e, ot);
          k !== null && jr(k, e, ot, Sn);
        }
      }, o_ = function(e, n, l) {
        var f = Yk(e, n);
        if (f !== null) {
          var h = m_(f.memoizedState, l);
          f.memoizedState = h, f.baseState = h, e.memoizedProps = Pt({}, e.memoizedProps);
          var y = _a(e, ot);
          y !== null && jr(y, e, ot, Sn);
        }
      }, s_ = function(e, n, l, f) {
        var h = Yk(e, n);
        if (h !== null) {
          var y = g_(h.memoizedState, l, f);
          h.memoizedState = y, h.baseState = y, e.memoizedProps = Pt({}, e.memoizedProps);
          var k = _a(e, ot);
          k !== null && jr(k, e, ot, Sn);
        }
      }, l_ = function(e, n, l) {
        e.pendingProps = b_(e.memoizedProps, n, l), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var f = _a(e, ot);
        f !== null && jr(f, e, ot, Sn);
      }, u_ = function(e, n) {
        e.pendingProps = m_(e.memoizedProps, n), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var l = _a(e, ot);
        l !== null && jr(l, e, ot, Sn);
      }, c_ = function(e, n, l) {
        e.pendingProps = g_(e.memoizedProps, n, l), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var f = _a(e, ot);
        f !== null && jr(f, e, ot, Sn);
      }, d_ = function(e) {
        var n = _a(e, ot);
        n !== null && jr(n, e, ot, Sn);
      }, f_ = function(e) {
        r_ = e;
      }, p_ = function(e) {
        i_ = e;
      };
    }
    function MI(e) {
      var n = ga(e);
      return n === null ? null : n.stateNode;
    }
    function NI(e) {
      return null;
    }
    function LI() {
      return In;
    }
    function AI(e) {
      var n = e.findFiberByHostInstance, l = i.ReactCurrentDispatcher;
      return Lh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: a_,
        overrideHookStateDeletePath: o_,
        overrideHookStateRenamePath: s_,
        overrideProps: l_,
        overridePropsDeletePath: u_,
        overridePropsRenamePath: c_,
        setErrorHandler: f_,
        setSuspenseHandler: p_,
        scheduleUpdate: d_,
        currentDispatcherRef: l,
        findHostInstanceByFiber: MI,
        findFiberByHostInstance: n || NI,
        // React Refresh
        findHostInstancesForRefresh: dI,
        scheduleRefresh: uI,
        scheduleRoot: cI,
        setRefreshHandler: lI,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: LI,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: $k
      });
    }
    var S_ = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function Kk(e) {
      this._internalRoot = e;
    }
    T0.prototype.render = Kk.prototype.render = function(e) {
      var n = this._internalRoot;
      if (n === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? c("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : E0(arguments[1]) ? c("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && c("You passed a second argument to root.render(...) but it only accepts one argument.");
        var l = n.containerInfo;
        if (l.nodeType !== nr) {
          var f = n_(n.current);
          f && f.parentNode !== l && c("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      iv(e, n, null, null);
    }, T0.prototype.unmount = Kk.prototype.unmount = function() {
      typeof arguments[0] == "function" && c("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var n = e.containerInfo;
        MR() && c("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Hl(function() {
          iv(null, e, null, null);
        }), S1(n);
      }
    };
    function II(e, n) {
      if (!E0(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      C_(e);
      var l = !1, f = !1, h = "", y = S_;
      n != null && (n.hydrate ? d("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof n == "object" && n !== null && n.$$typeof === za && c(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), n.unstable_strictMode === !0 && (l = !0), n.identifierPrefix !== void 0 && (h = n.identifierPrefix), n.onRecoverableError !== void 0 && (y = n.onRecoverableError), n.transitionCallbacks !== void 0 && n.transitionCallbacks);
      var k = ZR(e, yy, null, l, f, h, y);
      dy(k.current, e);
      var w = e.nodeType === nr ? e.parentNode : e;
      return cm(w), new Kk(k);
    }
    function T0(e) {
      this._internalRoot = e;
    }
    function UI(e) {
      e && Jb(e);
    }
    T0.prototype.unstable_scheduleHydration = UI;
    function FI(e, n, l) {
      if (!E0(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      C_(e), n === void 0 && c("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var f = l ?? null, h = l != null && l.hydratedSources || null, y = !1, k = !1, w = "", _ = S_;
      l != null && (l.unstable_strictMode === !0 && (y = !0), l.identifierPrefix !== void 0 && (w = l.identifierPrefix), l.onRecoverableError !== void 0 && (_ = l.onRecoverableError));
      var L = e_(n, null, e, yy, f, y, k, w, _);
      if (dy(L.current, e), cm(e), h)
        for (var A = 0; A < h.length; A++) {
          var W = h[A];
          BL(L, W);
        }
      return new T0(L);
    }
    function E0(e) {
      return !!(e && (e.nodeType === Ri || e.nodeType === $a || e.nodeType === cl || !ge));
    }
    function av(e) {
      return !!(e && (e.nodeType === Ri || e.nodeType === $a || e.nodeType === cl || e.nodeType === nr && e.nodeValue === " react-mount-point-unstable "));
    }
    function C_(e) {
      e.nodeType === Ri && e.tagName && e.tagName.toUpperCase() === "BODY" && c("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Cm(e) && (e._reactRootContainer ? c("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : c("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var jI = i.ReactCurrentOwner, k_;
    k_ = function(e) {
      if (e._reactRootContainer && e.nodeType !== nr) {
        var n = n_(e._reactRootContainer.current);
        n && n.parentNode !== e && c("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var l = !!e._reactRootContainer, f = Qk(e), h = !!(f && Qu(f));
      h && !l && c("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === Ri && e.tagName && e.tagName.toUpperCase() === "BODY" && c("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function Qk(e) {
      return e ? e.nodeType === $a ? e.documentElement : e.firstChild : null;
    }
    function T_() {
    }
    function zI(e, n, l, f, h) {
      if (h) {
        if (typeof f == "function") {
          var y = f;
          f = function() {
            var $ = k0(k);
            y.call($);
          };
        }
        var k = e_(
          n,
          f,
          e,
          Xu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          T_
        );
        e._reactRootContainer = k, dy(k.current, e);
        var w = e.nodeType === nr ? e.parentNode : e;
        return cm(w), Hl(), k;
      } else {
        for (var _; _ = e.lastChild; )
          e.removeChild(_);
        if (typeof f == "function") {
          var L = f;
          f = function() {
            var $ = k0(A);
            L.call($);
          };
        }
        var A = ZR(
          e,
          Xu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          T_
        );
        e._reactRootContainer = A, dy(A.current, e);
        var W = e.nodeType === nr ? e.parentNode : e;
        return cm(W), Hl(function() {
          iv(n, A, l, f);
        }), A;
      }
    }
    function VI(e, n) {
      e !== null && typeof e != "function" && c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", n, e);
    }
    function w0(e, n, l, f, h) {
      k_(l), VI(h === void 0 ? null : h, "render");
      var y = l._reactRootContainer, k;
      if (!y)
        k = zI(l, n, e, h, f);
      else {
        if (k = y, typeof h == "function") {
          var w = h;
          h = function() {
            var _ = k0(k);
            w.call(_);
          };
        }
        iv(n, k, e, h);
      }
      return k0(k);
    }
    var E_ = !1;
    function BI(e) {
      {
        E_ || (E_ = !0, c("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var n = jI.current;
        if (n !== null && n.stateNode !== null) {
          var l = n.stateNode._warnedAboutRefsInRender;
          l || c("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", zt(n.type) || "A component"), n.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === Ri ? e : RI(e, "findDOMNode");
    }
    function HI(e, n, l) {
      if (c("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !av(n))
        throw new Error("Target container is not a DOM element.");
      {
        var f = Cm(n) && n._reactRootContainer === void 0;
        f && c("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return w0(null, e, n, !0, l);
    }
    function $I(e, n, l) {
      if (c("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !av(n))
        throw new Error("Target container is not a DOM element.");
      {
        var f = Cm(n) && n._reactRootContainer === void 0;
        f && c("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return w0(null, e, n, !1, l);
    }
    function qI(e, n, l, f) {
      if (c("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !av(l))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !Bc(e))
        throw new Error("parentComponent must be a valid React Component");
      return w0(e, n, l, !1, f);
    }
    var w_ = !1;
    function WI(e) {
      if (w_ || (w_ = !0, c("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !av(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var n = Cm(e) && e._reactRootContainer === void 0;
        n && c("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var l = Qk(e), f = l && !Qu(l);
          f && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Hl(function() {
          w0(null, null, e, !1, function() {
            e._reactRootContainer = null, S1(e);
          });
        }), !0;
      } else {
        {
          var h = Qk(e), y = !!(h && Qu(h)), k = e.nodeType === Ri && av(e.parentNode) && !!e.parentNode._reactRootContainer;
          y && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", k ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Iu(_I), Kb(xI), Ff(PI), Ng(Ca), Lg(Kr), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && c("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), ug(YM), ef(_k, FA, Hl);
    function GI(e, n) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!E0(n))
        throw new Error("Target container is not a DOM element.");
      return wI(e, n, null, l);
    }
    function YI(e, n, l, f) {
      return qI(e, n, l, f);
    }
    var Jk = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Qu, sp, fy, Zd, jc, _k]
    };
    function KI(e, n) {
      return Jk.usingClientEntryPoint || c('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), II(e, n);
    }
    function QI(e, n, l) {
      return Jk.usingClientEntryPoint || c('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), FI(e, n, l);
    }
    function JI(e) {
      return MR() && c("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Hl(e);
    }
    var XI = AI({
      findFiberByHostInstance: md,
      bundleType: 1,
      version: $k,
      rendererPackageName: "react-dom"
    });
    if (!XI && Nn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var R_ = window.location.protocol;
      /^(https?|file):$/.test(R_) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (R_ === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Ma.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Jk, Ma.createPortal = GI, Ma.createRoot = KI, Ma.findDOMNode = BI, Ma.flushSync = JI, Ma.hydrate = HI, Ma.hydrateRoot = QI, Ma.render = $I, Ma.unmountComponentAtNode = WI, Ma.unstable_batchedUpdates = _k, Ma.unstable_renderSubtreeIntoContainer = YI, Ma.version = $k, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Ma;
}
function gP() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(gP);
    } catch (r) {
      console.error(r);
    }
  }
}
process.env.NODE_ENV === "production" ? (gP(), ET.exports = l5()) : ET.exports = u5();
var c5 = ET.exports, uv = c5;
if (process.env.NODE_ENV === "production")
  vv.createRoot = uv.createRoot, vv.hydrateRoot = uv.hydrateRoot;
else {
  var _0 = uv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  vv.createRoot = function(r, t) {
    _0.usingClientEntryPoint = !0;
    try {
      return uv.createRoot(r, t);
    } finally {
      _0.usingClientEntryPoint = !1;
    }
  }, vv.hydrateRoot = function(r, t, i) {
    _0.usingClientEntryPoint = !0;
    try {
      return uv.hydrateRoot(r, t, i);
    } finally {
      _0.usingClientEntryPoint = !1;
    }
  };
}
const d5 = {
  connectionDetailsEndpoint: "",
  e2eeEnabled: !0,
  e2eePassphrase: "your-e2ee-passphrase",
  showSettingsMenu: !0,
  formatChatMessageLinks: (r) => r,
  roomName: "your-room-name",
  participantName: "your-participant-name",
  region: void 0,
  codec: "vp9",
  hq: !0,
  miniView: !1,
  onError: (r) => {
  },
  onLeave: () => {
  },
  onJoin: () => {
  },
  onFullScreen: () => {
  },
  onRecording: () => {
    window.alert("This meeting is being recorded");
  },
  onRoomCreated: (r) => {
  }
  // Add other app-specific options here...
}, yP = R.createContext(void 0);
let wT;
const f5 = (r) => {
  wT && wT(r);
}, p5 = ({ children: r, initialOptions: t }) => {
  const [i, o] = R.useState(t), u = (d) => {
    o((c) => ({ ...c, miniView: d }));
  };
  return wT = u, /* @__PURE__ */ Mt.jsx(yP.Provider, { value: { ...i, setMiniView: u }, children: r });
}, cb = () => {
  const r = R.useContext(yP);
  if (r === void 0)
    throw new Error("useAppContext must be used within an AppProvider");
  return r;
};
function I_(r) {
  return decodeURIComponent(r);
}
function h5(r, t) {
  return t.forEach(function(i) {
    i && typeof i != "string" && !Array.isArray(i) && Object.keys(i).forEach(function(o) {
      if (o !== "default" && !(o in r)) {
        var u = Object.getOwnPropertyDescriptor(i, o);
        Object.defineProperty(r, o, u.get ? u : {
          enumerable: !0,
          get: function() {
            return i[o];
          }
        });
      }
    });
  }), Object.freeze(r);
}
var m5 = Object.defineProperty, v5 = (r, t, i) => t in r ? m5(r, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: i
}) : r[t] = i, U_ = (r, t, i) => v5(r, typeof t != "symbol" ? t + "" : t, i);
let Aa = class {
  constructor() {
    U_(this, "_locking"), U_(this, "_locks"), this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let t;
    const i = new Promise((u) => t = () => {
      this._locks -= 1, u();
    }), o = this._locking.then(() => t);
    return this._locking = this._locking.then(() => i), o;
  }
};
function lr(r, t) {
  if (!r)
    throw new Error(t);
}
const g5 = 34028234663852886e22, y5 = -34028234663852886e22, b5 = 4294967295, S5 = 2147483647, C5 = -2147483648;
function L0(r) {
  if (typeof r != "number")
    throw new Error("invalid int 32: " + typeof r);
  if (!Number.isInteger(r) || r > S5 || r < C5)
    throw new Error("invalid int 32: " + r);
}
function RT(r) {
  if (typeof r != "number")
    throw new Error("invalid uint 32: " + typeof r);
  if (!Number.isInteger(r) || r > b5 || r < 0)
    throw new Error("invalid uint 32: " + r);
}
function bP(r) {
  if (typeof r != "number")
    throw new Error("invalid float 32: " + typeof r);
  if (Number.isFinite(r) && (r > g5 || r < y5))
    throw new Error("invalid float 32: " + r);
}
const SP = Symbol("@bufbuild/protobuf/enum-type");
function k5(r) {
  const t = r[SP];
  return lr(t, "missing enum type on enum object"), t;
}
function CP(r, t, i, o) {
  r[SP] = kP(t, i.map((u) => ({
    no: u.no,
    name: u.name,
    localName: r[u.no]
  })));
}
function kP(r, t, i) {
  const o = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null), d = [];
  for (const c of t) {
    const m = TP(c);
    d.push(m), o[c.name] = m, u[c.no] = m;
  }
  return {
    typeName: r,
    values: d,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(c) {
      return o[c];
    },
    findNumber(c) {
      return u[c];
    }
  };
}
function T5(r, t, i) {
  const o = {};
  for (const u of t) {
    const d = TP(u);
    o[d.localName] = d.no, o[d.no] = d.localName;
  }
  return CP(o, r, t), o;
}
function TP(r) {
  return "localName" in r ? r : Object.assign(Object.assign({}, r), {
    localName: r.name
  });
}
class hE {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(t) {
    return this.getType().runtime.util.equals(this.getType(), this, t);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(t, i) {
    const o = this.getType(), u = o.runtime.bin, d = u.makeReadOptions(i);
    return u.readMessage(this, d.readerFactory(t), t.byteLength, d), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(t, i) {
    const o = this.getType(), u = o.runtime.json, d = u.makeReadOptions(i);
    return u.readMessage(o, t, d, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(t, i) {
    let o;
    try {
      o = JSON.parse(t);
    } catch (u) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(u instanceof Error ? u.message : String(u)));
    }
    return this.fromJson(o, i);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(t) {
    const i = this.getType(), o = i.runtime.bin, u = o.makeWriteOptions(t), d = u.writerFactory();
    return o.writeMessage(this, d, u), d.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(t) {
    const i = this.getType(), o = i.runtime.json, u = o.makeWriteOptions(t);
    return o.writeMessage(this, u);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(t) {
    var i;
    const o = this.toJson(t);
    return JSON.stringify(o, null, (i = t == null ? void 0 : t.prettySpaces) !== null && i !== void 0 ? i : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function E5(r, t, i, o) {
  var u;
  const d = (u = o == null ? void 0 : o.localName) !== null && u !== void 0 ? u : t.substring(t.lastIndexOf(".") + 1), c = {
    [d]: function(m) {
      r.util.initFields(this), r.util.initPartial(m, this);
    }
  }[d];
  return Object.setPrototypeOf(c.prototype, new hE()), Object.assign(c, {
    runtime: r,
    typeName: t,
    fields: r.util.newFieldList(i),
    fromBinary(m, g) {
      return new c().fromBinary(m, g);
    },
    fromJson(m, g) {
      return new c().fromJson(m, g);
    },
    fromJsonString(m, g) {
      return new c().fromJsonString(m, g);
    },
    equals(m, g) {
      return r.util.equals(c, m, g);
    }
  }), c;
}
function w5() {
  let r = 0, t = 0;
  for (let o = 0; o < 28; o += 7) {
    let u = this.buf[this.pos++];
    if (r |= (u & 127) << o, !(u & 128))
      return this.assertBounds(), [r, t];
  }
  let i = this.buf[this.pos++];
  if (r |= (i & 15) << 28, t = (i & 112) >> 4, !(i & 128))
    return this.assertBounds(), [r, t];
  for (let o = 3; o <= 31; o += 7) {
    let u = this.buf[this.pos++];
    if (t |= (u & 127) << o, !(u & 128))
      return this.assertBounds(), [r, t];
  }
  throw new Error("invalid varint");
}
function eT(r, t, i) {
  for (let d = 0; d < 28; d = d + 7) {
    const c = r >>> d, m = !(!(c >>> 7) && t == 0), g = (m ? c | 128 : c) & 255;
    if (i.push(g), !m)
      return;
  }
  const o = r >>> 28 & 15 | (t & 7) << 4, u = !!(t >> 3);
  if (i.push((u ? o | 128 : o) & 255), !!u) {
    for (let d = 3; d < 31; d = d + 7) {
      const c = t >>> d, m = !!(c >>> 7), g = (m ? c | 128 : c) & 255;
      if (i.push(g), !m)
        return;
    }
    i.push(t >>> 31 & 1);
  }
}
const A0 = 4294967296;
function F_(r) {
  const t = r[0] === "-";
  t && (r = r.slice(1));
  const i = 1e6;
  let o = 0, u = 0;
  function d(c, m) {
    const g = Number(r.slice(c, m));
    u *= i, o = o * i + g, o >= A0 && (u = u + (o / A0 | 0), o = o % A0);
  }
  return d(-24, -18), d(-18, -12), d(-12, -6), d(-6), t ? wP(o, u) : mE(o, u);
}
function R5(r, t) {
  let i = mE(r, t);
  const o = i.hi & 2147483648;
  o && (i = wP(i.lo, i.hi));
  const u = EP(i.lo, i.hi);
  return o ? "-" + u : u;
}
function EP(r, t) {
  if ({
    lo: r,
    hi: t
  } = _5(r, t), t <= 2097151)
    return String(A0 * t + r);
  const i = r & 16777215, o = (r >>> 24 | t << 8) & 16777215, u = t >> 16 & 65535;
  let d = i + o * 6777216 + u * 6710656, c = o + u * 8147497, m = u * 2;
  const g = 1e7;
  return d >= g && (c += Math.floor(d / g), d %= g), c >= g && (m += Math.floor(c / g), c %= g), m.toString() + j_(c) + j_(d);
}
function _5(r, t) {
  return {
    lo: r >>> 0,
    hi: t >>> 0
  };
}
function mE(r, t) {
  return {
    lo: r | 0,
    hi: t | 0
  };
}
function wP(r, t) {
  return t = ~t, r ? r = ~r + 1 : t += 1, mE(r, t);
}
const j_ = (r) => {
  const t = String(r);
  return "0000000".slice(t.length) + t;
};
function z_(r, t) {
  if (r >= 0) {
    for (; r > 127; )
      t.push(r & 127 | 128), r = r >>> 7;
    t.push(r);
  } else {
    for (let i = 0; i < 9; i++)
      t.push(r & 127 | 128), r = r >> 7;
    t.push(1);
  }
}
function x5() {
  let r = this.buf[this.pos++], t = r & 127;
  if (!(r & 128))
    return this.assertBounds(), t;
  if (r = this.buf[this.pos++], t |= (r & 127) << 7, !(r & 128))
    return this.assertBounds(), t;
  if (r = this.buf[this.pos++], t |= (r & 127) << 14, !(r & 128))
    return this.assertBounds(), t;
  if (r = this.buf[this.pos++], t |= (r & 127) << 21, !(r & 128))
    return this.assertBounds(), t;
  r = this.buf[this.pos++], t |= (r & 15) << 28;
  for (let i = 5; r & 128 && i < 10; i++)
    r = this.buf[this.pos++];
  if (r & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
function P5() {
  const r = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof r.getBigInt64 == "function" && typeof r.getBigUint64 == "function" && typeof r.setBigInt64 == "function" && typeof r.setBigUint64 == "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const u = BigInt("-9223372036854775808"), d = BigInt("9223372036854775807"), c = BigInt("0"), m = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(g) {
        const b = typeof g == "bigint" ? g : BigInt(g);
        if (b > d || b < u)
          throw new Error("int64 invalid: ".concat(g));
        return b;
      },
      uParse(g) {
        const b = typeof g == "bigint" ? g : BigInt(g);
        if (b > m || b < c)
          throw new Error("uint64 invalid: ".concat(g));
        return b;
      },
      enc(g) {
        return r.setBigInt64(0, this.parse(g), !0), {
          lo: r.getInt32(0, !0),
          hi: r.getInt32(4, !0)
        };
      },
      uEnc(g) {
        return r.setBigInt64(0, this.uParse(g), !0), {
          lo: r.getInt32(0, !0),
          hi: r.getInt32(4, !0)
        };
      },
      dec(g, b) {
        return r.setInt32(0, g, !0), r.setInt32(4, b, !0), r.getBigInt64(0, !0);
      },
      uDec(g, b) {
        return r.setInt32(0, g, !0), r.setInt32(4, b, !0), r.getBigUint64(0, !0);
      }
    };
  }
  const i = (u) => lr(/^-?[0-9]+$/.test(u), "int64 invalid: ".concat(u)), o = (u) => lr(/^[0-9]+$/.test(u), "uint64 invalid: ".concat(u));
  return {
    zero: "0",
    supported: !1,
    parse(u) {
      return typeof u != "string" && (u = u.toString()), i(u), u;
    },
    uParse(u) {
      return typeof u != "string" && (u = u.toString()), o(u), u;
    },
    enc(u) {
      return typeof u != "string" && (u = u.toString()), i(u), F_(u);
    },
    uEnc(u) {
      return typeof u != "string" && (u = u.toString()), o(u), F_(u);
    },
    dec(u, d) {
      return R5(u, d);
    },
    uDec(u, d) {
      return EP(u, d);
    }
  };
}
const Gn = P5();
var Ce;
(function(r) {
  r[r.DOUBLE = 1] = "DOUBLE", r[r.FLOAT = 2] = "FLOAT", r[r.INT64 = 3] = "INT64", r[r.UINT64 = 4] = "UINT64", r[r.INT32 = 5] = "INT32", r[r.FIXED64 = 6] = "FIXED64", r[r.FIXED32 = 7] = "FIXED32", r[r.BOOL = 8] = "BOOL", r[r.STRING = 9] = "STRING", r[r.BYTES = 12] = "BYTES", r[r.UINT32 = 13] = "UINT32", r[r.SFIXED32 = 15] = "SFIXED32", r[r.SFIXED64 = 16] = "SFIXED64", r[r.SINT32 = 17] = "SINT32", r[r.SINT64 = 18] = "SINT64";
})(Ce || (Ce = {}));
var Sc;
(function(r) {
  r[r.BIGINT = 0] = "BIGINT", r[r.STRING = 1] = "STRING";
})(Sc || (Sc = {}));
function fc(r, t, i) {
  if (t === i)
    return !0;
  if (r == Ce.BYTES) {
    if (!(t instanceof Uint8Array) || !(i instanceof Uint8Array) || t.length !== i.length)
      return !1;
    for (let o = 0; o < t.length; o++)
      if (t[o] !== i[o])
        return !1;
    return !0;
  }
  switch (r) {
    case Ce.UINT64:
    case Ce.FIXED64:
    case Ce.INT64:
    case Ce.SFIXED64:
    case Ce.SINT64:
      return t == i;
  }
  return !1;
}
function Yp(r, t) {
  switch (r) {
    case Ce.BOOL:
      return !1;
    case Ce.UINT64:
    case Ce.FIXED64:
    case Ce.INT64:
    case Ce.SFIXED64:
    case Ce.SINT64:
      return t == 0 ? Gn.zero : "0";
    case Ce.DOUBLE:
    case Ce.FLOAT:
      return 0;
    case Ce.BYTES:
      return new Uint8Array(0);
    case Ce.STRING:
      return "";
    default:
      return 0;
  }
}
function RP(r, t) {
  switch (r) {
    case Ce.BOOL:
      return t === !1;
    case Ce.STRING:
      return t === "";
    case Ce.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
var vr;
(function(r) {
  r[r.Varint = 0] = "Varint", r[r.Bit64 = 1] = "Bit64", r[r.LengthDelimited = 2] = "LengthDelimited", r[r.StartGroup = 3] = "StartGroup", r[r.EndGroup = 4] = "EndGroup", r[r.Bit32 = 5] = "Bit32";
})(vr || (vr = {}));
class D5 {
  constructor(t) {
    this.stack = [], this.textEncoder = t ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let t = 0;
    for (let u = 0; u < this.chunks.length; u++)
      t += this.chunks[u].length;
    let i = new Uint8Array(t), o = 0;
    for (let u = 0; u < this.chunks.length; u++)
      i.set(this.chunks[u], o), o += this.chunks[u].length;
    return this.chunks = [], i;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), i = this.stack.pop();
    if (!i)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = i.chunks, this.buf = i.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, i) {
    return this.uint32((t << 3 | i) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (RT(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return L0(t), z_(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let i = this.textEncoder.encode(t);
    return this.uint32(i.byteLength), this.raw(i);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    bP(t);
    let i = new Uint8Array(4);
    return new DataView(i.buffer).setFloat32(0, t, !0), this.raw(i);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let i = new Uint8Array(8);
    return new DataView(i.buffer).setFloat64(0, t, !0), this.raw(i);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    RT(t);
    let i = new Uint8Array(4);
    return new DataView(i.buffer).setUint32(0, t, !0), this.raw(i);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    L0(t);
    let i = new Uint8Array(4);
    return new DataView(i.buffer).setInt32(0, t, !0), this.raw(i);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return L0(t), t = (t << 1 ^ t >> 31) >>> 0, z_(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let i = new Uint8Array(8), o = new DataView(i.buffer), u = Gn.enc(t);
    return o.setInt32(0, u.lo, !0), o.setInt32(4, u.hi, !0), this.raw(i);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let i = new Uint8Array(8), o = new DataView(i.buffer), u = Gn.uEnc(t);
    return o.setInt32(0, u.lo, !0), o.setInt32(4, u.hi, !0), this.raw(i);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let i = Gn.enc(t);
    return eT(i.lo, i.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    let i = Gn.enc(t), o = i.hi >> 31, u = i.lo << 1 ^ o, d = (i.hi << 1 | i.lo >>> 31) ^ o;
    return eT(u, d, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    let i = Gn.uEnc(t);
    return eT(i.lo, i.hi, this.buf), this;
  }
}
class O5 {
  constructor(t, i) {
    this.varint64 = w5, this.uint32 = x5, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength), this.textDecoder = i ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), i = t >>> 3, o = t & 7;
    if (i <= 0 || o < 0 || o > 5)
      throw new Error("illegal tag: field no " + i + " wire type " + o);
    return [i, o];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, i) {
    let o = this.pos;
    switch (t) {
      case vr.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case vr.Bit64:
        this.pos += 4;
      case vr.Bit32:
        this.pos += 4;
        break;
      case vr.LengthDelimited:
        let u = this.uint32();
        this.pos += u;
        break;
      case vr.StartGroup:
        for (; ; ) {
          const [d, c] = this.tag();
          if (c === vr.EndGroup) {
            if (i !== void 0 && d !== i)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(c, d);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(o, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return Gn.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return Gn.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, i] = this.varint64(), o = -(t & 1);
    return t = (t >>> 1 | (i & 1) << 31) ^ o, i = i >>> 1 ^ o, Gn.dec(t, i);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, i] = this.varint64();
    return t !== 0 || i !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return Gn.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return Gn.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), i = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(i, i + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function M5(r, t, i, o) {
  let u;
  return {
    typeName: t,
    extendee: i,
    get field() {
      if (!u) {
        const d = typeof o == "function" ? o() : o;
        d.name = t.split(".").pop(), d.jsonName = "[".concat(t, "]"), u = r.util.newFieldList([d]).list()[0];
      }
      return u;
    },
    runtime: r
  };
}
function _P(r) {
  const t = r.field.localName, i = /* @__PURE__ */ Object.create(null);
  return i[t] = N5(r), [i, () => i[t]];
}
function N5(r) {
  const t = r.field;
  if (t.repeated)
    return [];
  if (t.default !== void 0)
    return t.default;
  switch (t.kind) {
    case "enum":
      return t.T.values[0].no;
    case "scalar":
      return Yp(t.T, t.L);
    case "message":
      const i = t.T, o = new i();
      return i.fieldWrapper ? i.fieldWrapper.unwrapField(o) : o;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function L5(r, t) {
  if (!t.repeated && (t.kind == "enum" || t.kind == "scalar")) {
    for (let i = r.length - 1; i >= 0; --i)
      if (r[i].no == t.no)
        return [r[i]];
    return [];
  }
  return r.filter((i) => i.no === t.no);
}
let Wl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), db = [];
for (let r = 0; r < Wl.length; r++)
  db[Wl[r].charCodeAt(0)] = r;
db["-".charCodeAt(0)] = Wl.indexOf("+");
db["_".charCodeAt(0)] = Wl.indexOf("/");
const xP = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(r) {
    let t = r.length * 3 / 4;
    r[r.length - 2] == "=" ? t -= 2 : r[r.length - 1] == "=" && (t -= 1);
    let i = new Uint8Array(t), o = 0, u = 0, d, c = 0;
    for (let m = 0; m < r.length; m++) {
      if (d = db[r.charCodeAt(m)], d === void 0)
        switch (r[m]) {
          case "=":
            u = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (u) {
        case 0:
          c = d, u = 1;
          break;
        case 1:
          i[o++] = c << 2 | (d & 48) >> 4, c = d, u = 2;
          break;
        case 2:
          i[o++] = (c & 15) << 4 | (d & 60) >> 2, c = d, u = 3;
          break;
        case 3:
          i[o++] = (c & 3) << 6 | d, u = 0;
          break;
      }
    }
    if (u == 1)
      throw Error("invalid base64 string.");
    return i.subarray(0, o);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(r) {
    let t = "", i = 0, o, u = 0;
    for (let d = 0; d < r.length; d++)
      switch (o = r[d], i) {
        case 0:
          t += Wl[o >> 2], u = (o & 3) << 4, i = 1;
          break;
        case 1:
          t += Wl[u | o >> 4], u = (o & 15) << 2, i = 2;
          break;
        case 2:
          t += Wl[u | o >> 6], t += Wl[o & 63], i = 0;
          break;
      }
    return i && (t += Wl[u], t += "=", i == 1 && (t += "=")), t;
  }
};
function A5(r, t, i) {
  DP(t, r);
  const o = t.runtime.bin.makeReadOptions(i), u = L5(r.getType().runtime.bin.listUnknownFields(r), t.field), [d, c] = _P(t);
  for (const m of u)
    t.runtime.bin.readField(d, o.readerFactory(m.data), t.field, m.wireType, o);
  return c();
}
function I5(r, t, i, o) {
  DP(t, r);
  const u = t.runtime.bin.makeReadOptions(o), d = t.runtime.bin.makeWriteOptions(o);
  if (PP(r, t)) {
    const b = r.getType().runtime.bin.listUnknownFields(r).filter((C) => C.no != t.field.no);
    r.getType().runtime.bin.discardUnknownFields(r);
    for (const C of b)
      r.getType().runtime.bin.onUnknownField(r, C.no, C.wireType, C.data);
  }
  const c = d.writerFactory();
  let m = t.field;
  !m.opt && !m.repeated && (m.kind == "enum" || m.kind == "scalar") && (m = Object.assign(Object.assign({}, t.field), {
    opt: !0
  })), t.runtime.bin.writeField(m, i, c, d);
  const g = u.readerFactory(c.finish());
  for (; g.pos < g.len; ) {
    const [b, C] = g.tag(), E = g.skip(C, b);
    r.getType().runtime.bin.onUnknownField(r, b, C, E);
  }
}
function PP(r, t) {
  const i = r.getType();
  return t.extendee.typeName === i.typeName && !!i.runtime.bin.listUnknownFields(r).find((o) => o.no == t.field.no);
}
function DP(r, t) {
  lr(r.extendee.typeName == t.getType().typeName, "extension ".concat(r.typeName, " can only be applied to message ").concat(r.extendee.typeName));
}
function OP(r, t) {
  const i = r.localName;
  if (r.repeated)
    return t[i].length > 0;
  if (r.oneof)
    return t[r.oneof.localName].case === i;
  switch (r.kind) {
    case "enum":
    case "scalar":
      return r.opt || r.req ? t[i] !== void 0 : r.kind == "enum" ? t[i] !== r.T.values[0].no : !RP(r.T, t[i]);
    case "message":
      return t[i] !== void 0;
    case "map":
      return Object.keys(t[i]).length > 0;
  }
}
function V_(r, t) {
  const i = r.localName, o = !r.opt && !r.req;
  if (r.repeated)
    t[i] = [];
  else if (r.oneof)
    t[r.oneof.localName] = {
      case: void 0
    };
  else
    switch (r.kind) {
      case "map":
        t[i] = {};
        break;
      case "enum":
        t[i] = o ? r.T.values[0].no : void 0;
        break;
      case "scalar":
        t[i] = o ? Yp(r.T, r.L) : void 0;
        break;
      case "message":
        t[i] = void 0;
        break;
    }
}
function Od(r, t) {
  if (r === null || typeof r != "object" || !Object.getOwnPropertyNames(hE.prototype).every((o) => o in r && typeof r[o] == "function"))
    return !1;
  const i = r.getType();
  return i === null || typeof i != "function" || !("typeName" in i) || typeof i.typeName != "string" ? !1 : t === void 0 ? !0 : i.typeName == t.typeName;
}
function MP(r, t) {
  return Od(t) || !r.fieldWrapper ? t : r.fieldWrapper.wrapField(t);
}
Ce.DOUBLE, Ce.FLOAT, Ce.INT64, Ce.UINT64, Ce.INT32, Ce.UINT32, Ce.BOOL, Ce.STRING, Ce.BYTES;
const B_ = {
  ignoreUnknownFields: !1
}, H_ = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function U5(r) {
  return r ? Object.assign(Object.assign({}, B_), r) : B_;
}
function F5(r) {
  return r ? Object.assign(Object.assign({}, H_), r) : H_;
}
const Q0 = Symbol(), I0 = Symbol();
function j5() {
  return {
    makeReadOptions: U5,
    makeWriteOptions: F5,
    readMessage(r, t, i, o) {
      if (t == null || Array.isArray(t) || typeof t != "object")
        throw new Error("cannot decode message ".concat(r.typeName, " from JSON: ").concat(Zs(t)));
      o = o ?? new r();
      const u = /* @__PURE__ */ new Map(), d = i.typeRegistry;
      for (const [c, m] of Object.entries(t)) {
        const g = r.fields.findJsonName(c);
        if (g) {
          if (g.oneof) {
            if (m === null && g.kind == "scalar")
              continue;
            const b = u.get(g.oneof);
            if (b !== void 0)
              throw new Error("cannot decode message ".concat(r.typeName, ' from JSON: multiple keys for oneof "').concat(g.oneof.name, '" present: "').concat(b, '", "').concat(c, '"'));
            u.set(g.oneof, c);
          }
          $_(o, m, g, i, r);
        } else {
          let b = !1;
          if (d != null && d.findExtension && c.startsWith("[") && c.endsWith("]")) {
            const C = d.findExtension(c.substring(1, c.length - 1));
            if (C && C.extendee.typeName == r.typeName) {
              b = !0;
              const [E, x] = _P(C);
              $_(E, m, C.field, i, C), I5(o, C, x(), i);
            }
          }
          if (!b && !i.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(r.typeName, ' from JSON: key "').concat(c, '" is unknown'));
        }
      }
      return o;
    },
    writeMessage(r, t) {
      const i = r.getType(), o = {};
      let u;
      try {
        for (u of i.fields.byNumber()) {
          if (!OP(u, r)) {
            if (u.req)
              throw "required field not set";
            if (!t.emitDefaultValues || !V5(u))
              continue;
          }
          const c = u.oneof ? r[u.oneof.localName].value : r[u.localName], m = q_(u, c, t);
          m !== void 0 && (o[t.useProtoFieldName ? u.name : u.jsonName] = m);
        }
        const d = t.typeRegistry;
        if (d != null && d.findExtensionFor)
          for (const c of i.runtime.bin.listUnknownFields(r)) {
            const m = d.findExtensionFor(i.typeName, c.no);
            if (m && PP(r, m)) {
              const g = A5(r, m, t), b = q_(m.field, g, t);
              b !== void 0 && (o[m.field.jsonName] = b);
            }
          }
      } catch (d) {
        const c = u ? "cannot encode field ".concat(i.typeName, ".").concat(u.name, " to JSON") : "cannot encode message ".concat(i.typeName, " to JSON"), m = d instanceof Error ? d.message : String(d);
        throw new Error(c + (m.length > 0 ? ": ".concat(m) : ""));
      }
      return o;
    },
    readScalar(r, t, i) {
      return bv(r, t, i ?? Sc.BIGINT, !0);
    },
    writeScalar(r, t, i) {
      if (t !== void 0 && (i || RP(r, t)))
        return U0(r, t);
    },
    debug: Zs
  };
}
function Zs(r) {
  if (r === null)
    return "null";
  switch (typeof r) {
    case "object":
      return Array.isArray(r) ? "array" : "object";
    case "string":
      return r.length > 100 ? "string" : '"'.concat(r.split('"').join('\\"'), '"');
    default:
      return String(r);
  }
}
function $_(r, t, i, o, u) {
  let d = i.localName;
  if (i.repeated) {
    if (lr(i.kind != "map"), t === null)
      return;
    if (!Array.isArray(t))
      throw new Error("cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(t)));
    const c = r[d];
    for (const m of t) {
      if (m === null)
        throw new Error("cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(m)));
      switch (i.kind) {
        case "message":
          c.push(i.T.fromJson(m, o));
          break;
        case "enum":
          const g = tT(i.T, m, o.ignoreUnknownFields, !0);
          g !== I0 && c.push(g);
          break;
        case "scalar":
          try {
            c.push(bv(i.T, m, i.L, !0));
          } catch (b) {
            let C = "cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(m));
            throw b instanceof Error && b.message.length > 0 && (C += ": ".concat(b.message)), new Error(C);
          }
          break;
      }
    }
  } else if (i.kind == "map") {
    if (t === null)
      return;
    if (typeof t != "object" || Array.isArray(t))
      throw new Error("cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(t)));
    const c = r[d];
    for (const [m, g] of Object.entries(t)) {
      if (g === null)
        throw new Error("cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: map value null"));
      let b;
      try {
        b = z5(i.K, m);
      } catch (C) {
        let E = "cannot decode map key for field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(t));
        throw C instanceof Error && C.message.length > 0 && (E += ": ".concat(C.message)), new Error(E);
      }
      switch (i.V.kind) {
        case "message":
          c[b] = i.V.T.fromJson(g, o);
          break;
        case "enum":
          const C = tT(i.V.T, g, o.ignoreUnknownFields, !0);
          C !== I0 && (c[b] = C);
          break;
        case "scalar":
          try {
            c[b] = bv(i.V.T, g, Sc.BIGINT, !0);
          } catch (E) {
            let x = "cannot decode map value for field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(t));
            throw E instanceof Error && E.message.length > 0 && (x += ": ".concat(E.message)), new Error(x);
          }
          break;
      }
    }
  } else
    switch (i.oneof && (r = r[i.oneof.localName] = {
      case: d
    }, d = "value"), i.kind) {
      case "message":
        const c = i.T;
        if (t === null && c.typeName != "google.protobuf.Value")
          return;
        let m = r[d];
        Od(m) ? m.fromJson(t, o) : (r[d] = m = c.fromJson(t, o), c.fieldWrapper && !i.oneof && (r[d] = c.fieldWrapper.unwrapField(m)));
        break;
      case "enum":
        const g = tT(i.T, t, o.ignoreUnknownFields, !1);
        switch (g) {
          case Q0:
            V_(i, r);
            break;
          case I0:
            break;
          default:
            r[d] = g;
            break;
        }
        break;
      case "scalar":
        try {
          const b = bv(i.T, t, i.L, !1);
          switch (b) {
            case Q0:
              V_(i, r);
              break;
            default:
              r[d] = b;
              break;
          }
        } catch (b) {
          let C = "cannot decode field ".concat(u.typeName, ".").concat(i.name, " from JSON: ").concat(Zs(t));
          throw b instanceof Error && b.message.length > 0 && (C += ": ".concat(b.message)), new Error(C);
        }
        break;
    }
}
function z5(r, t) {
  if (r === Ce.BOOL)
    switch (t) {
      case "true":
        t = !0;
        break;
      case "false":
        t = !1;
        break;
    }
  return bv(r, t, Sc.BIGINT, !0).toString();
}
function bv(r, t, i, o) {
  if (t === null)
    return o ? Yp(r, i) : Q0;
  switch (r) {
    case Ce.DOUBLE:
    case Ce.FLOAT:
      if (t === "NaN")
        return Number.NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (t === "" || typeof t == "string" && t.trim().length !== t.length || typeof t != "string" && typeof t != "number")
        break;
      const u = Number(t);
      if (Number.isNaN(u) || !Number.isFinite(u))
        break;
      return r == Ce.FLOAT && bP(u), u;
    case Ce.INT32:
    case Ce.FIXED32:
    case Ce.SFIXED32:
    case Ce.SINT32:
    case Ce.UINT32:
      let d;
      if (typeof t == "number" ? d = t : typeof t == "string" && t.length > 0 && t.trim().length === t.length && (d = Number(t)), d === void 0)
        break;
      return r == Ce.UINT32 || r == Ce.FIXED32 ? RT(d) : L0(d), d;
    case Ce.INT64:
    case Ce.SFIXED64:
    case Ce.SINT64:
      if (typeof t != "number" && typeof t != "string")
        break;
      const c = Gn.parse(t);
      return i ? c.toString() : c;
    case Ce.FIXED64:
    case Ce.UINT64:
      if (typeof t != "number" && typeof t != "string")
        break;
      const m = Gn.uParse(t);
      return i ? m.toString() : m;
    case Ce.BOOL:
      if (typeof t != "boolean")
        break;
      return t;
    case Ce.STRING:
      if (typeof t != "string")
        break;
      try {
        encodeURIComponent(t);
      } catch {
        throw new Error("invalid UTF8");
      }
      return t;
    case Ce.BYTES:
      if (t === "")
        return new Uint8Array(0);
      if (typeof t != "string")
        break;
      return xP.dec(t);
  }
  throw new Error();
}
function tT(r, t, i, o) {
  if (t === null)
    return r.typeName == "google.protobuf.NullValue" ? 0 : o ? r.values[0].no : Q0;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const u = r.findName(t);
      if (u !== void 0)
        return u.no;
      if (i)
        return I0;
      break;
  }
  throw new Error("cannot decode enum ".concat(r.typeName, " from JSON: ").concat(Zs(t)));
}
function V5(r) {
  return r.repeated || r.kind == "map" ? !0 : !(r.oneof || r.kind == "message" || r.opt || r.req);
}
function q_(r, t, i) {
  if (r.kind == "map") {
    lr(typeof t == "object" && t != null);
    const o = {}, u = Object.entries(t);
    switch (r.V.kind) {
      case "scalar":
        for (const [c, m] of u)
          o[c.toString()] = U0(r.V.T, m);
        break;
      case "message":
        for (const [c, m] of u)
          o[c.toString()] = m.toJson(i);
        break;
      case "enum":
        const d = r.V.T;
        for (const [c, m] of u)
          o[c.toString()] = nT(d, m, i.enumAsInteger);
        break;
    }
    return i.emitDefaultValues || u.length > 0 ? o : void 0;
  }
  if (r.repeated) {
    lr(Array.isArray(t));
    const o = [];
    switch (r.kind) {
      case "scalar":
        for (let u = 0; u < t.length; u++)
          o.push(U0(r.T, t[u]));
        break;
      case "enum":
        for (let u = 0; u < t.length; u++)
          o.push(nT(r.T, t[u], i.enumAsInteger));
        break;
      case "message":
        for (let u = 0; u < t.length; u++)
          o.push(t[u].toJson(i));
        break;
    }
    return i.emitDefaultValues || o.length > 0 ? o : void 0;
  }
  switch (r.kind) {
    case "scalar":
      return U0(r.T, t);
    case "enum":
      return nT(r.T, t, i.enumAsInteger);
    case "message":
      return MP(r.T, t).toJson(i);
  }
}
function nT(r, t, i) {
  var o;
  if (lr(typeof t == "number"), r.typeName == "google.protobuf.NullValue")
    return null;
  if (i)
    return t;
  const u = r.findNumber(t);
  return (o = u == null ? void 0 : u.name) !== null && o !== void 0 ? o : t;
}
function U0(r, t) {
  switch (r) {
    case Ce.INT32:
    case Ce.SFIXED32:
    case Ce.SINT32:
    case Ce.FIXED32:
    case Ce.UINT32:
      return lr(typeof t == "number"), t;
    case Ce.FLOAT:
    case Ce.DOUBLE:
      return lr(typeof t == "number"), Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    case Ce.STRING:
      return lr(typeof t == "string"), t;
    case Ce.BOOL:
      return lr(typeof t == "boolean"), t;
    case Ce.UINT64:
    case Ce.FIXED64:
    case Ce.INT64:
    case Ce.SFIXED64:
    case Ce.SINT64:
      return lr(typeof t == "bigint" || typeof t == "string" || typeof t == "number"), t.toString();
    case Ce.BYTES:
      return lr(t instanceof Uint8Array), xP.enc(t);
  }
}
const Mp = Symbol("@bufbuild/protobuf/unknown-fields"), W_ = {
  readUnknownFields: !0,
  readerFactory: (r) => new O5(r)
}, G_ = {
  writeUnknownFields: !0,
  writerFactory: () => new D5()
};
function B5(r) {
  return r ? Object.assign(Object.assign({}, W_), r) : W_;
}
function H5(r) {
  return r ? Object.assign(Object.assign({}, G_), r) : G_;
}
function $5() {
  return {
    makeReadOptions: B5,
    makeWriteOptions: H5,
    listUnknownFields(r) {
      var t;
      return (t = r[Mp]) !== null && t !== void 0 ? t : [];
    },
    discardUnknownFields(r) {
      delete r[Mp];
    },
    writeUnknownFields(r, t) {
      const o = r[Mp];
      if (o)
        for (const u of o)
          t.tag(u.no, u.wireType).raw(u.data);
    },
    onUnknownField(r, t, i, o) {
      const u = r;
      Array.isArray(u[Mp]) || (u[Mp] = []), u[Mp].push({
        no: t,
        wireType: i,
        data: o
      });
    },
    readMessage(r, t, i, o, u) {
      const d = r.getType(), c = u ? t.len : t.pos + i;
      let m, g;
      for (; t.pos < c && ([m, g] = t.tag(), !(u === !0 && g == vr.EndGroup)); ) {
        const b = d.fields.find(m);
        if (!b) {
          const C = t.skip(g, m);
          o.readUnknownFields && this.onUnknownField(r, m, g, C);
          continue;
        }
        Y_(r, t, b, g, o);
      }
      if (u && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (g != vr.EndGroup || m !== i))
        throw new Error("invalid end group tag");
    },
    readField: Y_,
    writeMessage(r, t, i) {
      const o = r.getType();
      for (const u of o.fields.byNumber()) {
        if (!OP(u, r)) {
          if (u.req)
            throw new Error("cannot encode field ".concat(o.typeName, ".").concat(u.name, " to binary: required field not set"));
          continue;
        }
        const d = u.oneof ? r[u.oneof.localName].value : r[u.localName];
        K_(u, d, t, i);
      }
      return i.writeUnknownFields && this.writeUnknownFields(r, t), t;
    },
    writeField(r, t, i, o) {
      t !== void 0 && K_(r, t, i, o);
    }
  };
}
function Y_(r, t, i, o, u) {
  let {
    repeated: d,
    localName: c
  } = i;
  switch (i.oneof && (r = r[i.oneof.localName], r.case != c && delete r.value, r.case = c, c = "value"), i.kind) {
    case "scalar":
    case "enum":
      const m = i.kind == "enum" ? Ce.INT32 : i.T;
      let g = J0;
      if (i.kind == "scalar" && i.L > 0 && (g = W5), d) {
        let x = r[c];
        if (o == vr.LengthDelimited && m != Ce.STRING && m != Ce.BYTES) {
          let N = t.uint32() + t.pos;
          for (; t.pos < N; )
            x.push(g(t, m));
        } else
          x.push(g(t, m));
      } else
        r[c] = g(t, m);
      break;
    case "message":
      const b = i.T;
      d ? r[c].push(F0(t, new b(), u, i)) : Od(r[c]) ? F0(t, r[c], u, i) : (r[c] = F0(t, new b(), u, i), b.fieldWrapper && !i.oneof && !i.repeated && (r[c] = b.fieldWrapper.unwrapField(r[c])));
      break;
    case "map":
      let [C, E] = q5(i, t, u);
      r[c][C] = E;
      break;
  }
}
function F0(r, t, i, o) {
  const u = t.getType().runtime.bin, d = o == null ? void 0 : o.delimited;
  return u.readMessage(
    t,
    r,
    d ? o.no : r.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    i,
    d
  ), t;
}
function q5(r, t, i) {
  const o = t.uint32(), u = t.pos + o;
  let d, c;
  for (; t.pos < u; ) {
    const [m] = t.tag();
    switch (m) {
      case 1:
        d = J0(t, r.K);
        break;
      case 2:
        switch (r.V.kind) {
          case "scalar":
            c = J0(t, r.V.T);
            break;
          case "enum":
            c = t.int32();
            break;
          case "message":
            c = F0(t, new r.V.T(), i, void 0);
            break;
        }
        break;
    }
  }
  if (d === void 0 && (d = Yp(r.K, Sc.BIGINT)), typeof d != "string" && typeof d != "number" && (d = d.toString()), c === void 0)
    switch (r.V.kind) {
      case "scalar":
        c = Yp(r.V.T, Sc.BIGINT);
        break;
      case "enum":
        c = r.V.T.values[0].no;
        break;
      case "message":
        c = new r.V.T();
        break;
    }
  return [d, c];
}
function W5(r, t) {
  const i = J0(r, t);
  return typeof i == "bigint" ? i.toString() : i;
}
function J0(r, t) {
  switch (t) {
    case Ce.STRING:
      return r.string();
    case Ce.BOOL:
      return r.bool();
    case Ce.DOUBLE:
      return r.double();
    case Ce.FLOAT:
      return r.float();
    case Ce.INT32:
      return r.int32();
    case Ce.INT64:
      return r.int64();
    case Ce.UINT64:
      return r.uint64();
    case Ce.FIXED64:
      return r.fixed64();
    case Ce.BYTES:
      return r.bytes();
    case Ce.FIXED32:
      return r.fixed32();
    case Ce.SFIXED32:
      return r.sfixed32();
    case Ce.SFIXED64:
      return r.sfixed64();
    case Ce.SINT64:
      return r.sint64();
    case Ce.UINT32:
      return r.uint32();
    case Ce.SINT32:
      return r.sint32();
  }
}
function K_(r, t, i, o) {
  lr(t !== void 0);
  const u = r.repeated;
  switch (r.kind) {
    case "scalar":
    case "enum":
      let d = r.kind == "enum" ? Ce.INT32 : r.T;
      if (u)
        if (lr(Array.isArray(t)), r.packed)
          Y5(i, d, r.no, t);
        else
          for (const c of t)
            Sv(i, d, r.no, c);
      else
        Sv(i, d, r.no, t);
      break;
    case "message":
      if (u) {
        lr(Array.isArray(t));
        for (const c of t)
          Q_(i, o, r, c);
      } else
        Q_(i, o, r, t);
      break;
    case "map":
      lr(typeof t == "object" && t != null);
      for (const [c, m] of Object.entries(t))
        G5(i, o, r, c, m);
      break;
  }
}
function G5(r, t, i, o, u) {
  r.tag(i.no, vr.LengthDelimited), r.fork();
  let d = o;
  switch (i.K) {
    case Ce.INT32:
    case Ce.FIXED32:
    case Ce.UINT32:
    case Ce.SFIXED32:
    case Ce.SINT32:
      d = Number.parseInt(o);
      break;
    case Ce.BOOL:
      lr(o == "true" || o == "false"), d = o == "true";
      break;
  }
  switch (Sv(r, i.K, 1, d), i.V.kind) {
    case "scalar":
      Sv(r, i.V.T, 2, u);
      break;
    case "enum":
      Sv(r, Ce.INT32, 2, u);
      break;
    case "message":
      lr(u !== void 0), r.tag(2, vr.LengthDelimited).bytes(u.toBinary(t));
      break;
  }
  r.join();
}
function Q_(r, t, i, o) {
  const u = MP(i.T, o);
  i.delimited ? r.tag(i.no, vr.StartGroup).raw(u.toBinary(t)).tag(i.no, vr.EndGroup) : r.tag(i.no, vr.LengthDelimited).bytes(u.toBinary(t));
}
function Sv(r, t, i, o) {
  lr(o !== void 0);
  let [u, d] = NP(t);
  r.tag(i, u)[d](o);
}
function Y5(r, t, i, o) {
  if (!o.length)
    return;
  r.tag(i, vr.LengthDelimited).fork();
  let [, u] = NP(t);
  for (let d = 0; d < o.length; d++)
    r[u](o[d]);
  r.join();
}
function NP(r) {
  let t = vr.Varint;
  switch (r) {
    case Ce.BYTES:
    case Ce.STRING:
      t = vr.LengthDelimited;
      break;
    case Ce.DOUBLE:
    case Ce.FIXED64:
    case Ce.SFIXED64:
      t = vr.Bit64;
      break;
    case Ce.FIXED32:
    case Ce.SFIXED32:
    case Ce.FLOAT:
      t = vr.Bit32;
      break;
  }
  const i = Ce[r].toLowerCase();
  return [t, i];
}
function K5() {
  return {
    setEnumType: CP,
    initPartial(r, t) {
      if (r === void 0)
        return;
      const i = t.getType();
      for (const o of i.fields.byMember()) {
        const u = o.localName, d = t, c = r;
        if (c[u] != null)
          switch (o.kind) {
            case "oneof":
              const m = c[u].case;
              if (m === void 0)
                continue;
              const g = o.findField(m);
              let b = c[u].value;
              g && g.kind == "message" && !Od(b, g.T) ? b = new g.T(b) : g && g.kind === "scalar" && g.T === Ce.BYTES && (b = cv(b)), d[u] = {
                case: m,
                value: b
              };
              break;
            case "scalar":
            case "enum":
              let C = c[u];
              o.T === Ce.BYTES && (C = o.repeated ? C.map(cv) : cv(C)), d[u] = C;
              break;
            case "map":
              switch (o.V.kind) {
                case "scalar":
                case "enum":
                  if (o.V.T === Ce.BYTES)
                    for (const [O, N] of Object.entries(c[u]))
                      d[u][O] = cv(N);
                  else
                    Object.assign(d[u], c[u]);
                  break;
                case "message":
                  const x = o.V.T;
                  for (const O of Object.keys(c[u])) {
                    let N = c[u][O];
                    x.fieldWrapper || (N = new x(N)), d[u][O] = N;
                  }
                  break;
              }
              break;
            case "message":
              const E = o.T;
              if (o.repeated)
                d[u] = c[u].map((x) => Od(x, E) ? x : new E(x));
              else {
                const x = c[u];
                E.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ E.typeName === "google.protobuf.BytesValue" ? d[u] = cv(x) : d[u] = x : d[u] = Od(x, E) ? x : new E(x);
              }
              break;
          }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(r, t, i) {
      return t === i ? !0 : !t || !i ? !1 : r.fields.byMember().every((o) => {
        const u = t[o.localName], d = i[o.localName];
        if (o.repeated) {
          if (u.length !== d.length)
            return !1;
          switch (o.kind) {
            case "message":
              return u.every((c, m) => o.T.equals(c, d[m]));
            case "scalar":
              return u.every((c, m) => fc(o.T, c, d[m]));
            case "enum":
              return u.every((c, m) => fc(Ce.INT32, c, d[m]));
          }
          throw new Error("repeated cannot contain ".concat(o.kind));
        }
        switch (o.kind) {
          case "message":
            return o.T.equals(u, d);
          case "enum":
            return fc(Ce.INT32, u, d);
          case "scalar":
            return fc(o.T, u, d);
          case "oneof":
            if (u.case !== d.case)
              return !1;
            const c = o.findField(u.case);
            if (c === void 0)
              return !0;
            switch (c.kind) {
              case "message":
                return c.T.equals(u.value, d.value);
              case "enum":
                return fc(Ce.INT32, u.value, d.value);
              case "scalar":
                return fc(c.T, u.value, d.value);
            }
            throw new Error("oneof cannot contain ".concat(c.kind));
          case "map":
            const m = Object.keys(u).concat(Object.keys(d));
            switch (o.V.kind) {
              case "message":
                const g = o.V.T;
                return m.every((C) => g.equals(u[C], d[C]));
              case "enum":
                return m.every((C) => fc(Ce.INT32, u[C], d[C]));
              case "scalar":
                const b = o.V.T;
                return m.every((C) => fc(b, u[C], d[C]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(r) {
      const t = r.getType(), i = new t(), o = i;
      for (const u of t.fields.byMember()) {
        const d = r[u.localName];
        let c;
        if (u.repeated)
          c = d.map(x0);
        else if (u.kind == "map") {
          c = o[u.localName];
          for (const [m, g] of Object.entries(d))
            c[m] = x0(g);
        } else
          u.kind == "oneof" ? c = u.findField(d.case) ? {
            case: d.case,
            value: x0(d.value)
          } : {
            case: void 0
          } : c = x0(d);
        o[u.localName] = c;
      }
      for (const u of t.runtime.bin.listUnknownFields(r))
        t.runtime.bin.onUnknownField(o, u.no, u.wireType, u.data);
      return i;
    }
  };
}
function x0(r) {
  if (r === void 0)
    return r;
  if (Od(r))
    return r.clone();
  if (r instanceof Uint8Array) {
    const t = new Uint8Array(r.byteLength);
    return t.set(r), t;
  }
  return r;
}
function cv(r) {
  return r instanceof Uint8Array ? r : new Uint8Array(r);
}
function Q5(r, t, i) {
  return {
    syntax: r,
    json: j5(),
    bin: $5(),
    util: Object.assign(Object.assign({}, K5()), {
      newFieldList: t,
      initFields: i
    }),
    makeMessageType(o, u, d) {
      return E5(this, o, u, d);
    },
    makeEnum: T5,
    makeEnumType: kP,
    getEnumType: k5,
    makeExtension(o, u, d) {
      return M5(this, o, u, d);
    }
  };
}
class J5 {
  constructor(t, i) {
    this._fields = t, this._normalizer = i;
  }
  findJsonName(t) {
    if (!this.jsonNames) {
      const i = {};
      for (const o of this.list())
        i[o.jsonName] = i[o.name] = o;
      this.jsonNames = i;
    }
    return this.jsonNames[t];
  }
  find(t) {
    if (!this.numbers) {
      const i = {};
      for (const o of this.list())
        i[o.no] = o;
      this.numbers = i;
    }
    return this.numbers[t];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((t, i) => t.no - i.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const t = this.members;
      let i;
      for (const o of this.list())
        o.oneof ? o.oneof !== i && (i = o.oneof, t.push(i)) : t.push(o);
    }
    return this.members;
  }
}
function LP(r, t) {
  const i = AP(r);
  return t ? i : rU(nU(i));
}
function X5(r) {
  return LP(r, !1);
}
const Z5 = AP;
function AP(r) {
  let t = !1;
  const i = [];
  for (let o = 0; o < r.length; o++) {
    let u = r.charAt(o);
    switch (u) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        i.push(u), t = !1;
        break;
      default:
        t && (t = !1, u = u.toUpperCase()), i.push(u);
        break;
    }
  }
  return i.join("");
}
const eU = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), tU = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), IP = (r) => "".concat(r, "$"), nU = (r) => tU.has(r) ? IP(r) : r, rU = (r) => eU.has(r) ? IP(r) : r;
class iU {
  constructor(t) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.req = !1, this.default = void 0, this.fields = [], this.name = t, this.localName = X5(t);
  }
  addField(t) {
    lr(t.oneof === this, "field ".concat(t.name, " not one of ").concat(this.name)), this.fields.push(t);
  }
  findField(t) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++)
        this._lookup[this.fields[i].localName] = this.fields[i];
    }
    return this._lookup[t];
  }
}
function aU(r, t) {
  var i, o, u, d, c, m;
  const g = [];
  let b;
  for (const C of typeof r == "function" ? r() : r) {
    const E = C;
    if (E.localName = LP(C.name, C.oneof !== void 0), E.jsonName = (i = C.jsonName) !== null && i !== void 0 ? i : Z5(C.name), E.repeated = (o = C.repeated) !== null && o !== void 0 ? o : !1, C.kind == "scalar" && (E.L = (u = C.L) !== null && u !== void 0 ? u : Sc.BIGINT), E.delimited = (d = C.delimited) !== null && d !== void 0 ? d : !1, E.req = (c = C.req) !== null && c !== void 0 ? c : !1, E.opt = (m = C.opt) !== null && m !== void 0 ? m : !1, C.packed === void 0 && (E.packed = C.kind == "enum" || C.kind == "scalar" && C.T != Ce.BYTES && C.T != Ce.STRING), C.oneof !== void 0) {
      const x = typeof C.oneof == "string" ? C.oneof : C.oneof.name;
      (!b || b.name != x) && (b = new iU(x)), E.oneof = b, b.addField(E);
    }
    g.push(E);
  }
  return g;
}
const fe = Q5(
  "proto3",
  (r) => new J5(r, (t) => aU(t)),
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (r) => {
    for (const t of r.getType().fields.byMember()) {
      if (t.opt)
        continue;
      const i = t.localName, o = r;
      if (t.repeated) {
        o[i] = [];
        continue;
      }
      switch (t.kind) {
        case "oneof":
          o[i] = {
            case: void 0
          };
          break;
        case "enum":
          o[i] = 0;
          break;
        case "map":
          o[i] = {};
          break;
        case "scalar":
          o[i] = Yp(t.T, t.L);
          break;
      }
    }
  }
);
class La extends hE {
  constructor(t) {
    super(), this.seconds = Gn.zero, this.nanos = 0, fe.util.initPartial(t, this);
  }
  fromJson(t, i) {
    if (typeof t != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(fe.json.debug(t)));
    const o = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!o)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const u = Date.parse(o[1] + "-" + o[2] + "-" + o[3] + "T" + o[4] + ":" + o[5] + ":" + o[6] + (o[8] ? o[8] : "Z"));
    if (Number.isNaN(u))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (u < Date.parse("0001-01-01T00:00:00Z") || u > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = Gn.parse(u / 1e3), this.nanos = 0, o[7] && (this.nanos = parseInt("1" + o[7] + "0".repeat(9 - o[7].length)) - 1e9), this;
  }
  toJson(t) {
    const i = Number(this.seconds) * 1e3;
    if (i < Date.parse("0001-01-01T00:00:00Z") || i > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let o = "Z";
    if (this.nanos > 0) {
      const u = (this.nanos + 1e9).toString().substring(1);
      u.substring(3) === "000000" ? o = "." + u.substring(0, 3) + "Z" : u.substring(6) === "000" ? o = "." + u.substring(0, 6) + "Z" : o = "." + u + "Z";
    }
    return new Date(i).toISOString().replace(".000Z", o);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return La.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(t) {
    const i = t.getTime();
    return new La({
      seconds: Gn.parse(Math.floor(i / 1e3)),
      nanos: i % 1e3 * 1e6
    });
  }
  static fromBinary(t, i) {
    return new La().fromBinary(t, i);
  }
  static fromJson(t, i) {
    return new La().fromJson(t, i);
  }
  static fromJsonString(t, i) {
    return new La().fromJsonString(t, i);
  }
  static equals(t, i) {
    return fe.util.equals(La, t, i);
  }
}
La.runtime = fe;
La.typeName = "google.protobuf.Timestamp";
La.fields = fe.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const oU = /* @__PURE__ */ fe.makeMessageType("livekit.MetricsBatch", () => [{
  no: 1,
  name: "timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "normalized_timestamp",
  kind: "message",
  T: La
}, {
  no: 3,
  name: "str_data",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "time_series",
  kind: "message",
  T: sU,
  repeated: !0
}, {
  no: 5,
  name: "events",
  kind: "message",
  T: uU,
  repeated: !0
}]), sU = /* @__PURE__ */ fe.makeMessageType("livekit.TimeSeriesMetric", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "samples",
  kind: "message",
  T: lU,
  repeated: !0
}, {
  no: 5,
  name: "rid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), lU = /* @__PURE__ */ fe.makeMessageType("livekit.MetricSample", () => [{
  no: 1,
  name: "timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "normalized_timestamp",
  kind: "message",
  T: La
}, {
  no: 3,
  name: "value",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]), uU = /* @__PURE__ */ fe.makeMessageType("livekit.EventMetric", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "start_timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "end_timestamp_ms",
  kind: "scalar",
  T: 3,
  opt: !0
}, {
  no: 6,
  name: "normalized_start_timestamp",
  kind: "message",
  T: La
}, {
  no: 7,
  name: "normalized_end_timestamp",
  kind: "message",
  T: La,
  opt: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "rid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), os = /* @__PURE__ */ fe.makeEnum("livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]), Hi = /* @__PURE__ */ fe.makeEnum("livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]), vE = /* @__PURE__ */ fe.makeEnum("livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]), gv = /* @__PURE__ */ fe.makeEnum("livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]), Ev = /* @__PURE__ */ fe.makeEnum("livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]), ls = /* @__PURE__ */ fe.makeEnum("livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}, {
  no: 10,
  name: "ROOM_CLOSED"
}, {
  no: 11,
  name: "USER_UNAVAILABLE"
}, {
  no: 12,
  name: "USER_REJECTED"
}, {
  no: 13,
  name: "SIP_TRUNK_FAILURE"
}]), Np = /* @__PURE__ */ fe.makeEnum("livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]), cU = /* @__PURE__ */ fe.makeEnum("livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]), el = /* @__PURE__ */ fe.makeEnum("livekit.AudioTrackFeature", [{
  no: 0,
  name: "TF_STEREO"
}, {
  no: 1,
  name: "TF_NO_DTX"
}, {
  no: 2,
  name: "TF_AUTO_GAIN_CONTROL"
}, {
  no: 3,
  name: "TF_ECHO_CANCELLATION"
}, {
  no: 4,
  name: "TF_NOISE_SUPPRESSION"
}, {
  no: 5,
  name: "TF_ENHANCED_NOISE_CANCELLATION"
}]), gE = /* @__PURE__ */ fe.makeMessageType("livekit.Room", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 14,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: X0,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: YP
}]), X0 = /* @__PURE__ */ fe.makeMessageType("livekit.Codec", () => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), dU = /* @__PURE__ */ fe.makeMessageType("livekit.ParticipantPermission", () => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: fe.getEnumType(Hi),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "can_subscribe_metrics",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), wv = /* @__PURE__ */ fe.makeMessageType("livekit.ParticipantInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: fe.getEnumType(_T)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: Up,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: dU
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: fe.getEnumType(Z0)
}, {
  no: 15,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 16,
  name: "disconnect_reason",
  kind: "enum",
  T: fe.getEnumType(ls)
}]), _T = /* @__PURE__ */ fe.makeEnum("livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]), Z0 = /* @__PURE__ */ fe.makeEnum("livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]), Ja = /* @__PURE__ */ fe.makeEnum("livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]), fU = /* @__PURE__ */ fe.makeMessageType("livekit.SimulcastCodecInfo", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: Md,
  repeated: !0
}]), Up = /* @__PURE__ */ fe.makeMessageType("livekit.TrackInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: fe.getEnumType(os)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: fe.getEnumType(Hi)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: Md,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: fU,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: fe.getEnumType(Ja)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: YP
}, {
  no: 19,
  name: "audio_features",
  kind: "enum",
  T: fe.getEnumType(el),
  repeated: !0
}]), Md = /* @__PURE__ */ fe.makeMessageType("livekit.VideoLayer", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: fe.getEnumType(vE)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), pc = /* @__PURE__ */ fe.makeMessageType("livekit.DataPacket", () => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: fe.getEnumType(zn)
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: FP,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: pU,
  oneof: "value"
}, {
  no: 6,
  name: "sip_dtmf",
  kind: "message",
  T: jP,
  oneof: "value"
}, {
  no: 7,
  name: "transcription",
  kind: "message",
  T: hU,
  oneof: "value"
}, {
  no: 8,
  name: "metrics",
  kind: "message",
  T: oU,
  oneof: "value"
}, {
  no: 9,
  name: "chat_message",
  kind: "message",
  T: xT,
  oneof: "value"
}, {
  no: 10,
  name: "rpc_request",
  kind: "message",
  T: zP,
  oneof: "value"
}, {
  no: 11,
  name: "rpc_ack",
  kind: "message",
  T: VP,
  oneof: "value"
}, {
  no: 12,
  name: "rpc_response",
  kind: "message",
  T: BP,
  oneof: "value"
}, {
  no: 13,
  name: "stream_header",
  kind: "message",
  T: kU,
  oneof: "value"
}, {
  no: 14,
  name: "stream_chunk",
  kind: "message",
  T: TU,
  oneof: "value"
}]), zn = /* @__PURE__ */ fe.makeEnum("livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]), pU = /* @__PURE__ */ fe.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: UP,
  repeated: !0
}]), UP = /* @__PURE__ */ fe.makeMessageType("livekit.SpeakerInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), FP = /* @__PURE__ */ fe.makeMessageType("livekit.UserPacket", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}, {
  no: 8,
  name: "id",
  kind: "scalar",
  T: 9,
  opt: !0
}, {
  no: 9,
  name: "start_time",
  kind: "scalar",
  T: 4,
  opt: !0
}, {
  no: 10,
  name: "end_time",
  kind: "scalar",
  T: 4,
  opt: !0
}]), jP = /* @__PURE__ */ fe.makeMessageType("livekit.SipDTMF", () => [{
  no: 3,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "digit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), hU = /* @__PURE__ */ fe.makeMessageType("livekit.Transcription", () => [{
  no: 2,
  name: "transcribed_participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "segments",
  kind: "message",
  T: mU,
  repeated: !0
}]), mU = /* @__PURE__ */ fe.makeMessageType("livekit.TranscriptionSegment", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "text",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "start_time",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 4,
  name: "end_time",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "final",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "language",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), xT = /* @__PURE__ */ fe.makeMessageType("livekit.ChatMessage", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "edit_timestamp",
  kind: "scalar",
  T: 3,
  opt: !0
}, {
  no: 4,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "deleted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "generated",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), zP = /* @__PURE__ */ fe.makeMessageType("livekit.RpcRequest", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "method",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "payload",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "response_timeout_ms",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), VP = /* @__PURE__ */ fe.makeMessageType("livekit.RpcAck", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), BP = /* @__PURE__ */ fe.makeMessageType("livekit.RpcResponse", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 9,
  oneof: "value"
}, {
  no: 3,
  name: "error",
  kind: "message",
  T: HP,
  oneof: "value"
}]), HP = /* @__PURE__ */ fe.makeMessageType("livekit.RpcError", () => [{
  no: 1,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "data",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), $P = /* @__PURE__ */ fe.makeMessageType("livekit.ParticipantTracks", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), vU = /* @__PURE__ */ fe.makeMessageType("livekit.ServerInfo", () => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: fe.getEnumType(qP)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "agent_protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]), qP = /* @__PURE__ */ fe.makeEnum("livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]), gU = /* @__PURE__ */ fe.makeMessageType("livekit.ClientInfo", () => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: fe.getEnumType(WP)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "other_sdks",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), WP = /* @__PURE__ */ fe.makeEnum("livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}, {
  no: 11,
  name: "UNITY_WEB"
}, {
  no: 12,
  name: "NODE"
}]), GP = /* @__PURE__ */ fe.makeMessageType("livekit.ClientConfiguration", () => [{
  no: 1,
  name: "video",
  kind: "message",
  T: J_
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: J_
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: fe.getEnumType(Ev)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: yU
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: fe.getEnumType(Ev)
}]), J_ = /* @__PURE__ */ fe.makeMessageType("livekit.VideoConfiguration", () => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: fe.getEnumType(Ev)
}]), yU = /* @__PURE__ */ fe.makeMessageType("livekit.DisabledCodecs", () => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: X0,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: X0,
  repeated: !0
}]), YP = /* @__PURE__ */ fe.makeMessageType("livekit.TimedVersion", () => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]), bU = /* @__PURE__ */ fe.makeEnum("livekit.DataStream.OperationType", [{
  no: 0,
  name: "CREATE"
}, {
  no: 1,
  name: "UPDATE"
}, {
  no: 2,
  name: "DELETE"
}, {
  no: 3,
  name: "REACTION"
}]), SU = /* @__PURE__ */ fe.makeMessageType("livekit.DataStream.TextHeader", () => [{
  no: 1,
  name: "operation_type",
  kind: "enum",
  T: fe.getEnumType(bU)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "reply_to_stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "attached_stream_ids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 5,
  name: "generated",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}], {
  localName: "DataStream_TextHeader"
}), CU = /* @__PURE__ */ fe.makeMessageType("livekit.DataStream.FileHeader", () => [{
  no: 1,
  name: "file_name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}], {
  localName: "DataStream_FileHeader"
}), kU = /* @__PURE__ */ fe.makeMessageType("livekit.DataStream.Header", () => [{
  no: 1,
  name: "stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "topic",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "total_length",
  kind: "scalar",
  T: 4,
  opt: !0
}, {
  no: 7,
  name: "encryption_type",
  kind: "enum",
  T: fe.getEnumType(Ja)
}, {
  no: 8,
  name: "extensions",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 9,
  name: "text_header",
  kind: "message",
  T: SU,
  oneof: "content_header"
}, {
  no: 10,
  name: "file_header",
  kind: "message",
  T: CU,
  oneof: "content_header"
}], {
  localName: "DataStream_Header"
}), TU = /* @__PURE__ */ fe.makeMessageType("livekit.DataStream.Chunk", () => [{
  no: 1,
  name: "stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "chunk_index",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 3,
  name: "content",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 4,
  name: "complete",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "version",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 6,
  name: "iv",
  kind: "scalar",
  T: 12,
  opt: !0
}], {
  localName: "DataStream_Chunk"
}), ss = /* @__PURE__ */ fe.makeEnum("livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]), PT = /* @__PURE__ */ fe.makeEnum("livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]), EU = /* @__PURE__ */ fe.makeEnum("livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]), wU = /* @__PURE__ */ fe.makeMessageType("livekit.SignalRequest", () => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: Id,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: Id,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: yE,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: OT,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: bE,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: fb,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: KP,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: pb,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: JP,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: tD,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: nD,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: Xs,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: XP,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: iD,
  oneof: "message"
}, {
  no: 17,
  name: "update_audio_track",
  kind: "message",
  T: QP,
  oneof: "message"
}, {
  no: 18,
  name: "update_video_track",
  kind: "message",
  T: DU,
  oneof: "message"
}]), X_ = /* @__PURE__ */ fe.makeMessageType("livekit.SignalResponse", () => [{
  no: 1,
  name: "join",
  kind: "message",
  T: RU,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: Id,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: Id,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: yE,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: PU,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: SE,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: pb,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: bE,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: OU,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: MU,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: LU,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: IU,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: FU,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: jU,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: xU,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: _U,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: zU,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: HU,
  oneof: "message"
}, {
  no: 22,
  name: "request_response",
  kind: "message",
  T: $U,
  oneof: "message"
}, {
  no: 23,
  name: "track_subscribed",
  kind: "message",
  T: qU,
  oneof: "message"
}]), DT = /* @__PURE__ */ fe.makeMessageType("livekit.SimulcastCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), OT = /* @__PURE__ */ fe.makeMessageType("livekit.AddTrackRequest", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: fe.getEnumType(os)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: fe.getEnumType(Hi)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: Md,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: DT,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: fe.getEnumType(Ja)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), yE = /* @__PURE__ */ fe.makeMessageType("livekit.TrickleRequest", () => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: fe.getEnumType(ss)
}, {
  no: 3,
  name: "final",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), bE = /* @__PURE__ */ fe.makeMessageType("livekit.MuteTrackRequest", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), RU = /* @__PURE__ */ fe.makeMessageType("livekit.JoinResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: gE
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: wv
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: wv,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ZP,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: GP
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: vU
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 14,
  name: "enabled_publish_codecs",
  kind: "message",
  T: X0,
  repeated: !0
}, {
  no: 15,
  name: "fast_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), _U = /* @__PURE__ */ fe.makeMessageType("livekit.ReconnectResponse", () => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ZP,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: GP
}]), SE = /* @__PURE__ */ fe.makeMessageType("livekit.TrackPublishedResponse", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: Up
}]), xU = /* @__PURE__ */ fe.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), Id = /* @__PURE__ */ fe.makeMessageType("livekit.SessionDescription", () => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), PU = /* @__PURE__ */ fe.makeMessageType("livekit.ParticipantUpdate", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: wv,
  repeated: !0
}]), fb = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateSubscription", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: $P,
  repeated: !0
}]), KP = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateTrackSettings", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: fe.getEnumType(vE)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), QP = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateLocalAudioTrack", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "features",
  kind: "enum",
  T: fe.getEnumType(el),
  repeated: !0
}]), DU = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateLocalVideoTrack", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), pb = /* @__PURE__ */ fe.makeMessageType("livekit.LeaveRequest", () => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: fe.getEnumType(ls)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: fe.getEnumType(jp)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: VU
}]), jp = /* @__PURE__ */ fe.makeEnum("livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]), JP = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateVideoLayers", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: Md,
  repeated: !0
}]), XP = /* @__PURE__ */ fe.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 4,
  name: "request_id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]), ZP = /* @__PURE__ */ fe.makeMessageType("livekit.ICEServer", () => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), OU = /* @__PURE__ */ fe.makeMessageType("livekit.SpeakersChanged", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: UP,
  repeated: !0
}]), MU = /* @__PURE__ */ fe.makeMessageType("livekit.RoomUpdate", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: gE
}]), NU = /* @__PURE__ */ fe.makeMessageType("livekit.ConnectionQualityInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: fe.getEnumType(gv)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]), LU = /* @__PURE__ */ fe.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: NU,
  repeated: !0
}]), AU = /* @__PURE__ */ fe.makeMessageType("livekit.StreamStateInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: fe.getEnumType(PT)
}]), IU = /* @__PURE__ */ fe.makeMessageType("livekit.StreamStateUpdate", () => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: AU,
  repeated: !0
}]), CE = /* @__PURE__ */ fe.makeMessageType("livekit.SubscribedQuality", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: fe.getEnumType(vE)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), UU = /* @__PURE__ */ fe.makeMessageType("livekit.SubscribedCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: CE,
  repeated: !0
}]), FU = /* @__PURE__ */ fe.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: CE,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: UU,
  repeated: !0
}]), eD = /* @__PURE__ */ fe.makeMessageType("livekit.TrackPermission", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), tD = /* @__PURE__ */ fe.makeMessageType("livekit.SubscriptionPermission", () => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: eD,
  repeated: !0
}]), jU = /* @__PURE__ */ fe.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]), nD = /* @__PURE__ */ fe.makeMessageType("livekit.SyncState", () => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: Id
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: fb
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: SE,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: rD,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: Id
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]), rD = /* @__PURE__ */ fe.makeMessageType("livekit.DataChannelInfo", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: fe.getEnumType(ss)
}]), Xs = /* @__PURE__ */ fe.makeMessageType("livekit.SimulateScenario", () => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: fe.getEnumType(EU),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 9,
  name: "leave_request_full_reconnect",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]), iD = /* @__PURE__ */ fe.makeMessageType("livekit.Ping", () => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), zU = /* @__PURE__ */ fe.makeMessageType("livekit.Pong", () => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), VU = /* @__PURE__ */ fe.makeMessageType("livekit.RegionSettings", () => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: BU,
  repeated: !0
}]), BU = /* @__PURE__ */ fe.makeMessageType("livekit.RegionInfo", () => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]), HU = /* @__PURE__ */ fe.makeMessageType("livekit.SubscriptionResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: fe.getEnumType(cU)
}]), $U = /* @__PURE__ */ fe.makeMessageType("livekit.RequestResponse", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: fe.getEnumType(aD)
}, {
  no: 3,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]), aD = /* @__PURE__ */ fe.makeEnum("livekit.RequestResponse.Reason", [{
  no: 0,
  name: "OK"
}, {
  no: 1,
  name: "NOT_FOUND"
}, {
  no: 2,
  name: "NOT_ALLOWED"
}, {
  no: 3,
  name: "LIMIT_EXCEEDED"
}]), qU = /* @__PURE__ */ fe.makeMessageType("livekit.TrackSubscribed", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
function WU(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var j0 = { exports: {} }, GU = j0.exports, Z_;
function YU() {
  return Z_ || (Z_ = 1, function(r) {
    (function(t, i) {
      r.exports ? r.exports = i() : t.log = i();
    })(GU, function() {
      var t = function() {
      }, i = "undefined", o = typeof window !== i && typeof window.navigator !== i && /Trident\/|MSIE /.test(window.navigator.userAgent), u = ["trace", "debug", "info", "warn", "error"], d = {}, c = null;
      function m(M, I) {
        var U = M[I];
        if (typeof U.bind == "function")
          return U.bind(M);
        try {
          return Function.prototype.bind.call(U, M);
        } catch {
          return function() {
            return Function.prototype.apply.apply(U, [M, arguments]);
          };
        }
      }
      function g() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function b(M) {
        return M === "debug" && (M = "log"), typeof console === i ? !1 : M === "trace" && o ? g : console[M] !== void 0 ? m(console, M) : console.log !== void 0 ? m(console, "log") : t;
      }
      function C() {
        for (var M = this.getLevel(), I = 0; I < u.length; I++) {
          var U = u[I];
          this[U] = I < M ? t : this.methodFactory(U, M, this.name);
        }
        if (this.log = this.debug, typeof console === i && M < this.levels.SILENT)
          return "No console available for logging";
      }
      function E(M) {
        return function() {
          typeof console !== i && (C.call(this), this[M].apply(this, arguments));
        };
      }
      function x(M, I, U) {
        return b(M) || E.apply(this, arguments);
      }
      function O(M, I) {
        var U = this, ae, Z, B, F = "loglevel";
        typeof M == "string" ? F += ":" + M : typeof M == "symbol" && (F = void 0);
        function K(se) {
          var Ee = (u[se] || "silent").toUpperCase();
          if (!(typeof window === i || !F)) {
            try {
              window.localStorage[F] = Ee;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(F) + "=" + Ee + ";";
            } catch {
            }
          }
        }
        function te() {
          var se;
          if (!(typeof window === i || !F)) {
            try {
              se = window.localStorage[F];
            } catch {
            }
            if (typeof se === i)
              try {
                var Ee = window.document.cookie, Ne = encodeURIComponent(F), Je = Ee.indexOf(Ne + "=");
                Je !== -1 && (se = /^([^;]+)/.exec(Ee.slice(Je + Ne.length + 1))[1]);
              } catch {
              }
            return U.levels[se] === void 0 && (se = void 0), se;
          }
        }
        function he() {
          if (!(typeof window === i || !F)) {
            try {
              window.localStorage.removeItem(F);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(F) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function pe(se) {
          var Ee = se;
          if (typeof Ee == "string" && U.levels[Ee.toUpperCase()] !== void 0 && (Ee = U.levels[Ee.toUpperCase()]), typeof Ee == "number" && Ee >= 0 && Ee <= U.levels.SILENT)
            return Ee;
          throw new TypeError("log.setLevel() called with invalid level: " + se);
        }
        U.name = M, U.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, U.methodFactory = I || x, U.getLevel = function() {
          return B ?? Z ?? ae;
        }, U.setLevel = function(se, Ee) {
          return B = pe(se), Ee !== !1 && K(B), C.call(U);
        }, U.setDefaultLevel = function(se) {
          Z = pe(se), te() || U.setLevel(se, !1);
        }, U.resetLevel = function() {
          B = null, he(), C.call(U);
        }, U.enableAll = function(se) {
          U.setLevel(U.levels.TRACE, se);
        }, U.disableAll = function(se) {
          U.setLevel(U.levels.SILENT, se);
        }, U.rebuild = function() {
          if (c !== U && (ae = pe(c.getLevel())), C.call(U), c === U)
            for (var se in d)
              d[se].rebuild();
        }, ae = pe(c ? c.getLevel() : "WARN");
        var ye = te();
        ye != null && (B = pe(ye)), C.call(U);
      }
      c = new O(), c.getLogger = function(I) {
        if (typeof I != "symbol" && typeof I != "string" || I === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var U = d[I];
        return U || (U = d[I] = new O(I, c.methodFactory)), U;
      };
      var N = typeof window !== i ? window.log : void 0;
      return c.noConflict = function() {
        return typeof window !== i && window.log === c && (window.log = N), c;
      }, c.getLoggers = function() {
        return d;
      }, c.default = c, c;
    });
  }(j0)), j0.exports;
}
var hb = YU(), MT;
(function(r) {
  r[r.trace = 0] = "trace", r[r.debug = 1] = "debug", r[r.info = 2] = "info", r[r.warn = 3] = "warn", r[r.error = 4] = "error", r[r.silent = 5] = "silent";
})(MT || (MT = {}));
var cs;
(function(r) {
  r.Default = "livekit", r.Room = "livekit-room", r.Participant = "livekit-participant", r.Track = "livekit-track", r.Publication = "livekit-track-publication", r.Engine = "livekit-engine", r.Signal = "livekit-signal", r.PCManager = "livekit-pc-manager", r.PCTransport = "livekit-pc-transport", r.E2EE = "lk-e2ee";
})(cs || (cs = {}));
let Wt = hb.getLogger("livekit");
Object.values(cs).map((r) => hb.getLogger(r));
Wt.setDefaultLevel(MT.info);
function Yl(r) {
  const t = hb.getLogger(r);
  return t.setDefaultLevel(Wt.getLevel()), t;
}
const KU = hb.getLogger("lk-e2ee"), dv = 7e3, QU = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, dv, dv, dv, dv, dv];
class JU {
  constructor(t) {
    this._retryDelays = t !== void 0 ? [...t] : QU;
  }
  nextRetryDelayInMs(t) {
    if (t.retryCount >= this._retryDelays.length)
      return null;
    const i = this._retryDelays[t.retryCount];
    return t.retryCount <= 1 ? i : i + Math.random() * 1e3;
  }
}
function G(r, t, i, o) {
  function u(d) {
    return d instanceof i ? d : new i(function(c) {
      c(d);
    });
  }
  return new (i || (i = Promise))(function(d, c) {
    function m(C) {
      try {
        b(o.next(C));
      } catch (E) {
        c(E);
      }
    }
    function g(C) {
      try {
        b(o.throw(C));
      } catch (E) {
        c(E);
      }
    }
    function b(C) {
      C.done ? d(C.value) : u(C.value).then(m, g);
    }
    b((o = o.apply(r, t || [])).next());
  });
}
function ex(r) {
  var t = typeof Symbol == "function" && Symbol.iterator, i = t && r[t], o = 0;
  if (i)
    return i.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && o >= r.length && (r = void 0), { value: r && r[o++], done: !r };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ap(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = r[Symbol.asyncIterator], i;
  return t ? t.call(r) : (r = typeof ex == "function" ? ex(r) : r[Symbol.iterator](), i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function o(d) {
    i[d] = r[d] && function(c) {
      return new Promise(function(m, g) {
        c = r[d](c), u(m, g, c.done, c.value);
      });
    };
  }
  function u(d, c, m, g) {
    Promise.resolve(g).then(function(b) {
      d({ value: b, done: m });
    }, c);
  }
}
var P0 = { exports: {} }, tx;
function XU() {
  if (tx)
    return P0.exports;
  tx = 1;
  var r = typeof Reflect == "object" ? Reflect : null, t = r && typeof r.apply == "function" ? r.apply : function(F, K, te) {
    return Function.prototype.apply.call(F, K, te);
  }, i;
  r && typeof r.ownKeys == "function" ? i = r.ownKeys : Object.getOwnPropertySymbols ? i = function(F) {
    return Object.getOwnPropertyNames(F).concat(Object.getOwnPropertySymbols(F));
  } : i = function(F) {
    return Object.getOwnPropertyNames(F);
  };
  function o(B) {
    console && console.warn && console.warn(B);
  }
  var u = Number.isNaN || function(F) {
    return F !== F;
  };
  function d() {
    d.init.call(this);
  }
  P0.exports = d, P0.exports.once = U, d.EventEmitter = d, d.prototype._events = void 0, d.prototype._eventsCount = 0, d.prototype._maxListeners = void 0;
  var c = 10;
  function m(B) {
    if (typeof B != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof B);
  }
  Object.defineProperty(d, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return c;
    },
    set: function(B) {
      if (typeof B != "number" || B < 0 || u(B))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + B + ".");
      c = B;
    }
  }), d.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, d.prototype.setMaxListeners = function(F) {
    if (typeof F != "number" || F < 0 || u(F))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + F + ".");
    return this._maxListeners = F, this;
  };
  function g(B) {
    return B._maxListeners === void 0 ? d.defaultMaxListeners : B._maxListeners;
  }
  d.prototype.getMaxListeners = function() {
    return g(this);
  }, d.prototype.emit = function(F) {
    for (var K = [], te = 1; te < arguments.length; te++)
      K.push(arguments[te]);
    var he = F === "error", pe = this._events;
    if (pe !== void 0)
      he = he && pe.error === void 0;
    else if (!he)
      return !1;
    if (he) {
      var ye;
      if (K.length > 0 && (ye = K[0]), ye instanceof Error)
        throw ye;
      var se = new Error("Unhandled error." + (ye ? " (" + ye.message + ")" : ""));
      throw se.context = ye, se;
    }
    var Ee = pe[F];
    if (Ee === void 0)
      return !1;
    if (typeof Ee == "function")
      t(Ee, this, K);
    else
      for (var Ne = Ee.length, Je = N(Ee, Ne), te = 0; te < Ne; ++te)
        t(Je[te], this, K);
    return !0;
  };
  function b(B, F, K, te) {
    var he, pe, ye;
    if (m(K), pe = B._events, pe === void 0 ? (pe = B._events = /* @__PURE__ */ Object.create(null), B._eventsCount = 0) : (pe.newListener !== void 0 && (B.emit("newListener", F, K.listener ? K.listener : K), pe = B._events), ye = pe[F]), ye === void 0)
      ye = pe[F] = K, ++B._eventsCount;
    else if (typeof ye == "function" ? ye = pe[F] = te ? [K, ye] : [ye, K] : te ? ye.unshift(K) : ye.push(K), he = g(B), he > 0 && ye.length > he && !ye.warned) {
      ye.warned = !0;
      var se = new Error("Possible EventEmitter memory leak detected. " + ye.length + " " + String(F) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      se.name = "MaxListenersExceededWarning", se.emitter = B, se.type = F, se.count = ye.length, o(se);
    }
    return B;
  }
  d.prototype.addListener = function(F, K) {
    return b(this, F, K, !1);
  }, d.prototype.on = d.prototype.addListener, d.prototype.prependListener = function(F, K) {
    return b(this, F, K, !0);
  };
  function C() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function E(B, F, K) {
    var te = {
      fired: !1,
      wrapFn: void 0,
      target: B,
      type: F,
      listener: K
    }, he = C.bind(te);
    return he.listener = K, te.wrapFn = he, he;
  }
  d.prototype.once = function(F, K) {
    return m(K), this.on(F, E(this, F, K)), this;
  }, d.prototype.prependOnceListener = function(F, K) {
    return m(K), this.prependListener(F, E(this, F, K)), this;
  }, d.prototype.removeListener = function(F, K) {
    var te, he, pe, ye, se;
    if (m(K), he = this._events, he === void 0)
      return this;
    if (te = he[F], te === void 0)
      return this;
    if (te === K || te.listener === K)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete he[F], he.removeListener && this.emit("removeListener", F, te.listener || K));
    else if (typeof te != "function") {
      for (pe = -1, ye = te.length - 1; ye >= 0; ye--)
        if (te[ye] === K || te[ye].listener === K) {
          se = te[ye].listener, pe = ye;
          break;
        }
      if (pe < 0)
        return this;
      pe === 0 ? te.shift() : M(te, pe), te.length === 1 && (he[F] = te[0]), he.removeListener !== void 0 && this.emit("removeListener", F, se || K);
    }
    return this;
  }, d.prototype.off = d.prototype.removeListener, d.prototype.removeAllListeners = function(F) {
    var K, te, he;
    if (te = this._events, te === void 0)
      return this;
    if (te.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : te[F] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete te[F]), this;
    if (arguments.length === 0) {
      var pe = Object.keys(te), ye;
      for (he = 0; he < pe.length; ++he)
        ye = pe[he], ye !== "removeListener" && this.removeAllListeners(ye);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (K = te[F], typeof K == "function")
      this.removeListener(F, K);
    else if (K !== void 0)
      for (he = K.length - 1; he >= 0; he--)
        this.removeListener(F, K[he]);
    return this;
  };
  function x(B, F, K) {
    var te = B._events;
    if (te === void 0)
      return [];
    var he = te[F];
    return he === void 0 ? [] : typeof he == "function" ? K ? [he.listener || he] : [he] : K ? I(he) : N(he, he.length);
  }
  d.prototype.listeners = function(F) {
    return x(this, F, !0);
  }, d.prototype.rawListeners = function(F) {
    return x(this, F, !1);
  }, d.listenerCount = function(B, F) {
    return typeof B.listenerCount == "function" ? B.listenerCount(F) : O.call(B, F);
  }, d.prototype.listenerCount = O;
  function O(B) {
    var F = this._events;
    if (F !== void 0) {
      var K = F[B];
      if (typeof K == "function")
        return 1;
      if (K !== void 0)
        return K.length;
    }
    return 0;
  }
  d.prototype.eventNames = function() {
    return this._eventsCount > 0 ? i(this._events) : [];
  };
  function N(B, F) {
    for (var K = new Array(F), te = 0; te < F; ++te)
      K[te] = B[te];
    return K;
  }
  function M(B, F) {
    for (; F + 1 < B.length; F++)
      B[F] = B[F + 1];
    B.pop();
  }
  function I(B) {
    for (var F = new Array(B.length), K = 0; K < F.length; ++K)
      F[K] = B[K].listener || B[K];
    return F;
  }
  function U(B, F) {
    return new Promise(function(K, te) {
      function he(ye) {
        B.removeListener(F, pe), te(ye);
      }
      function pe() {
        typeof B.removeListener == "function" && B.removeListener("error", he), K([].slice.call(arguments));
      }
      Z(B, F, pe, {
        once: !0
      }), F !== "error" && ae(B, he, {
        once: !0
      });
    });
  }
  function ae(B, F, K) {
    typeof B.on == "function" && Z(B, "error", F, K);
  }
  function Z(B, F, K, te) {
    if (typeof B.on == "function")
      te.once ? B.once(F, K) : B.on(F, K);
    else if (typeof B.addEventListener == "function")
      B.addEventListener(F, function he(pe) {
        te.once && B.removeEventListener(F, he), K(pe);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof B);
  }
  return P0.exports;
}
var rl = XU();
let oD = !0, sD = !0;
function z0(r, t, i) {
  const o = r.match(t);
  return o && o.length >= i && parseInt(o[i], 10);
}
function jd(r, t, i) {
  if (!r.RTCPeerConnection)
    return;
  const o = r.RTCPeerConnection.prototype, u = o.addEventListener;
  o.addEventListener = function(c, m) {
    if (c !== t)
      return u.apply(this, arguments);
    const g = (b) => {
      const C = i(b);
      C && (m.handleEvent ? m.handleEvent(C) : m(C));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = /* @__PURE__ */ new Map()), this._eventMap[t].set(m, g), u.apply(this, [c, g]);
  };
  const d = o.removeEventListener;
  o.removeEventListener = function(c, m) {
    if (c !== t || !this._eventMap || !this._eventMap[t])
      return d.apply(this, arguments);
    if (!this._eventMap[t].has(m))
      return d.apply(this, arguments);
    const g = this._eventMap[t].get(m);
    return this._eventMap[t].delete(m), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, d.apply(this, [c, g]);
  }, Object.defineProperty(o, "on" + t, {
    get() {
      return this["_on" + t];
    },
    set(c) {
      this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), c && this.addEventListener(t, this["_on" + t] = c);
    },
    enumerable: !0,
    configurable: !0
  });
}
function ZU(r) {
  return typeof r != "boolean" ? new Error("Argument type: " + typeof r + ". Please use a boolean.") : (oD = r, r ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function e3(r) {
  return typeof r != "boolean" ? new Error("Argument type: " + typeof r + ". Please use a boolean.") : (sD = !r, "adapter.js deprecation warnings " + (r ? "disabled" : "enabled"));
}
function lD() {
  if (typeof window == "object") {
    if (oD)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function kE(r, t) {
  sD && console.warn(r + " is deprecated, please use " + t + " instead.");
}
function t3(r) {
  const t = {
    browser: null,
    version: null
  };
  if (typeof r > "u" || !r.navigator || !r.navigator.userAgent)
    return t.browser = "Not a browser.", t;
  const {
    navigator: i
  } = r;
  if (i.userAgentData && i.userAgentData.brands) {
    const o = i.userAgentData.brands.find((u) => u.brand === "Chromium");
    if (o)
      return {
        browser: "chrome",
        version: parseInt(o.version, 10)
      };
  }
  if (i.mozGetUserMedia)
    t.browser = "firefox", t.version = z0(i.userAgent, /Firefox\/(\d+)\./, 1);
  else if (i.webkitGetUserMedia || r.isSecureContext === !1 && r.webkitRTCPeerConnection)
    t.browser = "chrome", t.version = z0(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (r.RTCPeerConnection && i.userAgent.match(/AppleWebKit\/(\d+)\./))
    t.browser = "safari", t.version = z0(i.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = r.RTCRtpTransceiver && "currentDirection" in r.RTCRtpTransceiver.prototype;
  else
    return t.browser = "Not a supported browser.", t;
  return t;
}
function nx(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function uD(r) {
  return nx(r) ? Object.keys(r).reduce(function(t, i) {
    const o = nx(r[i]), u = o ? uD(r[i]) : r[i], d = o && !Object.keys(u).length;
    return u === void 0 || d ? t : Object.assign(t, {
      [i]: u
    });
  }, {}) : r;
}
function NT(r, t, i) {
  !t || i.has(t.id) || (i.set(t.id, t), Object.keys(t).forEach((o) => {
    o.endsWith("Id") ? NT(r, r.get(t[o]), i) : o.endsWith("Ids") && t[o].forEach((u) => {
      NT(r, r.get(u), i);
    });
  }));
}
function rx(r, t, i) {
  const o = i ? "outbound-rtp" : "inbound-rtp", u = /* @__PURE__ */ new Map();
  if (t === null)
    return u;
  const d = [];
  return r.forEach((c) => {
    c.type === "track" && c.trackIdentifier === t.id && d.push(c);
  }), d.forEach((c) => {
    r.forEach((m) => {
      m.type === o && m.trackId === c.id && NT(r, m, u);
    });
  }), u;
}
const ix = lD;
function cD(r, t) {
  const i = r && r.navigator;
  if (!i.mediaDevices)
    return;
  const o = function(m) {
    if (typeof m != "object" || m.mandatory || m.optional)
      return m;
    const g = {};
    return Object.keys(m).forEach((b) => {
      if (b === "require" || b === "advanced" || b === "mediaSource")
        return;
      const C = typeof m[b] == "object" ? m[b] : {
        ideal: m[b]
      };
      C.exact !== void 0 && typeof C.exact == "number" && (C.min = C.max = C.exact);
      const E = function(x, O) {
        return x ? x + O.charAt(0).toUpperCase() + O.slice(1) : O === "deviceId" ? "sourceId" : O;
      };
      if (C.ideal !== void 0) {
        g.optional = g.optional || [];
        let x = {};
        typeof C.ideal == "number" ? (x[E("min", b)] = C.ideal, g.optional.push(x), x = {}, x[E("max", b)] = C.ideal, g.optional.push(x)) : (x[E("", b)] = C.ideal, g.optional.push(x));
      }
      C.exact !== void 0 && typeof C.exact != "number" ? (g.mandatory = g.mandatory || {}, g.mandatory[E("", b)] = C.exact) : ["min", "max"].forEach((x) => {
        C[x] !== void 0 && (g.mandatory = g.mandatory || {}, g.mandatory[E(x, b)] = C[x]);
      });
    }), m.advanced && (g.optional = (g.optional || []).concat(m.advanced)), g;
  }, u = function(m, g) {
    if (t.version >= 61)
      return g(m);
    if (m = JSON.parse(JSON.stringify(m)), m && typeof m.audio == "object") {
      const b = function(C, E, x) {
        E in C && !(x in C) && (C[x] = C[E], delete C[E]);
      };
      m = JSON.parse(JSON.stringify(m)), b(m.audio, "autoGainControl", "googAutoGainControl"), b(m.audio, "noiseSuppression", "googNoiseSuppression"), m.audio = o(m.audio);
    }
    if (m && typeof m.video == "object") {
      let b = m.video.facingMode;
      b = b && (typeof b == "object" ? b : {
        ideal: b
      });
      const C = t.version < 66;
      if (b && (b.exact === "user" || b.exact === "environment" || b.ideal === "user" || b.ideal === "environment") && !(i.mediaDevices.getSupportedConstraints && i.mediaDevices.getSupportedConstraints().facingMode && !C)) {
        delete m.video.facingMode;
        let E;
        if (b.exact === "environment" || b.ideal === "environment" ? E = ["back", "rear"] : (b.exact === "user" || b.ideal === "user") && (E = ["front"]), E)
          return i.mediaDevices.enumerateDevices().then((x) => {
            x = x.filter((N) => N.kind === "videoinput");
            let O = x.find((N) => E.some((M) => N.label.toLowerCase().includes(M)));
            return !O && x.length && E.includes("back") && (O = x[x.length - 1]), O && (m.video.deviceId = b.exact ? {
              exact: O.deviceId
            } : {
              ideal: O.deviceId
            }), m.video = o(m.video), ix("chrome: " + JSON.stringify(m)), g(m);
          });
      }
      m.video = o(m.video);
    }
    return ix("chrome: " + JSON.stringify(m)), g(m);
  }, d = function(m) {
    return t.version >= 64 ? m : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[m.name] || m.name,
      message: m.message,
      constraint: m.constraint || m.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, c = function(m, g, b) {
    u(m, (C) => {
      i.webkitGetUserMedia(C, g, (E) => {
        b && b(d(E));
      });
    });
  };
  if (i.getUserMedia = c.bind(i), i.mediaDevices.getUserMedia) {
    const m = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
    i.mediaDevices.getUserMedia = function(g) {
      return u(g, (b) => m(b).then((C) => {
        if (b.audio && !C.getAudioTracks().length || b.video && !C.getVideoTracks().length)
          throw C.getTracks().forEach((E) => {
            E.stop();
          }), new DOMException("", "NotFoundError");
        return C;
      }, (C) => Promise.reject(d(C))));
    };
  }
}
function dD(r) {
  r.MediaStream = r.MediaStream || r.webkitMediaStream;
}
function fD(r) {
  if (typeof r == "object" && r.RTCPeerConnection && !("ontrack" in r.RTCPeerConnection.prototype)) {
    Object.defineProperty(r.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(i) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = i);
      },
      enumerable: !0,
      configurable: !0
    });
    const t = r.RTCPeerConnection.prototype.setRemoteDescription;
    r.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (o) => {
        o.stream.addEventListener("addtrack", (u) => {
          let d;
          r.RTCPeerConnection.prototype.getReceivers ? d = this.getReceivers().find((m) => m.track && m.track.id === u.track.id) : d = {
            track: u.track
          };
          const c = new Event("track");
          c.track = u.track, c.receiver = d, c.transceiver = {
            receiver: d
          }, c.streams = [o.stream], this.dispatchEvent(c);
        }), o.stream.getTracks().forEach((u) => {
          let d;
          r.RTCPeerConnection.prototype.getReceivers ? d = this.getReceivers().find((m) => m.track && m.track.id === u.id) : d = {
            track: u
          };
          const c = new Event("track");
          c.track = u, c.receiver = d, c.transceiver = {
            receiver: d
          }, c.streams = [o.stream], this.dispatchEvent(c);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments);
    };
  } else
    jd(r, "track", (t) => (t.transceiver || Object.defineProperty(t, "transceiver", {
      value: {
        receiver: t.receiver
      }
    }), t));
}
function pD(r) {
  if (typeof r == "object" && r.RTCPeerConnection && !("getSenders" in r.RTCPeerConnection.prototype) && "createDTMFSender" in r.RTCPeerConnection.prototype) {
    const t = function(u, d) {
      return {
        track: d,
        get dtmf() {
          return this._dtmf === void 0 && (d.kind === "audio" ? this._dtmf = u.createDTMFSender(d) : this._dtmf = null), this._dtmf;
        },
        _pc: u
      };
    };
    if (!r.RTCPeerConnection.prototype.getSenders) {
      r.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const u = r.RTCPeerConnection.prototype.addTrack;
      r.RTCPeerConnection.prototype.addTrack = function(m, g) {
        let b = u.apply(this, arguments);
        return b || (b = t(this, m), this._senders.push(b)), b;
      };
      const d = r.RTCPeerConnection.prototype.removeTrack;
      r.RTCPeerConnection.prototype.removeTrack = function(m) {
        d.apply(this, arguments);
        const g = this._senders.indexOf(m);
        g !== -1 && this._senders.splice(g, 1);
      };
    }
    const i = r.RTCPeerConnection.prototype.addStream;
    r.RTCPeerConnection.prototype.addStream = function(d) {
      this._senders = this._senders || [], i.apply(this, [d]), d.getTracks().forEach((c) => {
        this._senders.push(t(this, c));
      });
    };
    const o = r.RTCPeerConnection.prototype.removeStream;
    r.RTCPeerConnection.prototype.removeStream = function(d) {
      this._senders = this._senders || [], o.apply(this, [d]), d.getTracks().forEach((c) => {
        const m = this._senders.find((g) => g.track === c);
        m && this._senders.splice(this._senders.indexOf(m), 1);
      });
    };
  } else if (typeof r == "object" && r.RTCPeerConnection && "getSenders" in r.RTCPeerConnection.prototype && "createDTMFSender" in r.RTCPeerConnection.prototype && r.RTCRtpSender && !("dtmf" in r.RTCRtpSender.prototype)) {
    const t = r.RTCPeerConnection.prototype.getSenders;
    r.RTCPeerConnection.prototype.getSenders = function() {
      const o = t.apply(this, []);
      return o.forEach((u) => u._pc = this), o;
    }, Object.defineProperty(r.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function hD(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection && r.RTCRtpSender && r.RTCRtpReceiver))
    return;
  if (!("getStats" in r.RTCRtpSender.prototype)) {
    const i = r.RTCPeerConnection.prototype.getSenders;
    i && (r.RTCPeerConnection.prototype.getSenders = function() {
      const d = i.apply(this, []);
      return d.forEach((c) => c._pc = this), d;
    });
    const o = r.RTCPeerConnection.prototype.addTrack;
    o && (r.RTCPeerConnection.prototype.addTrack = function() {
      const d = o.apply(this, arguments);
      return d._pc = this, d;
    }), r.RTCRtpSender.prototype.getStats = function() {
      const d = this;
      return this._pc.getStats().then((c) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        rx(c, d.track, !0)
      ));
    };
  }
  if (!("getStats" in r.RTCRtpReceiver.prototype)) {
    const i = r.RTCPeerConnection.prototype.getReceivers;
    i && (r.RTCPeerConnection.prototype.getReceivers = function() {
      const u = i.apply(this, []);
      return u.forEach((d) => d._pc = this), u;
    }), jd(r, "track", (o) => (o.receiver._pc = o.srcElement, o)), r.RTCRtpReceiver.prototype.getStats = function() {
      const u = this;
      return this._pc.getStats().then((d) => rx(d, u.track, !1));
    };
  }
  if (!("getStats" in r.RTCRtpSender.prototype && "getStats" in r.RTCRtpReceiver.prototype))
    return;
  const t = r.RTCPeerConnection.prototype.getStats;
  r.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof r.MediaStreamTrack) {
      const o = arguments[0];
      let u, d, c;
      return this.getSenders().forEach((m) => {
        m.track === o && (u ? c = !0 : u = m);
      }), this.getReceivers().forEach((m) => (m.track === o && (d ? c = !0 : d = m), m.track === o)), c || u && d ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : u ? u.getStats() : d ? d.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return t.apply(this, arguments);
  };
}
function mD(r) {
  r.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((c) => this._shimmedLocalStreams[c][0]);
  };
  const t = r.RTCPeerConnection.prototype.addTrack;
  r.RTCPeerConnection.prototype.addTrack = function(c, m) {
    if (!m)
      return t.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const g = t.apply(this, arguments);
    return this._shimmedLocalStreams[m.id] ? this._shimmedLocalStreams[m.id].indexOf(g) === -1 && this._shimmedLocalStreams[m.id].push(g) : this._shimmedLocalStreams[m.id] = [m, g], g;
  };
  const i = r.RTCPeerConnection.prototype.addStream;
  r.RTCPeerConnection.prototype.addStream = function(c) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, c.getTracks().forEach((b) => {
      if (this.getSenders().find((E) => E.track === b))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const m = this.getSenders();
    i.apply(this, arguments);
    const g = this.getSenders().filter((b) => m.indexOf(b) === -1);
    this._shimmedLocalStreams[c.id] = [c].concat(g);
  };
  const o = r.RTCPeerConnection.prototype.removeStream;
  r.RTCPeerConnection.prototype.removeStream = function(c) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[c.id], o.apply(this, arguments);
  };
  const u = r.RTCPeerConnection.prototype.removeTrack;
  r.RTCPeerConnection.prototype.removeTrack = function(c) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, c && Object.keys(this._shimmedLocalStreams).forEach((m) => {
      const g = this._shimmedLocalStreams[m].indexOf(c);
      g !== -1 && this._shimmedLocalStreams[m].splice(g, 1), this._shimmedLocalStreams[m].length === 1 && delete this._shimmedLocalStreams[m];
    }), u.apply(this, arguments);
  };
}
function vD(r, t) {
  if (!r.RTCPeerConnection)
    return;
  if (r.RTCPeerConnection.prototype.addTrack && t.version >= 65)
    return mD(r);
  const i = r.RTCPeerConnection.prototype.getLocalStreams;
  r.RTCPeerConnection.prototype.getLocalStreams = function() {
    const C = i.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, C.map((E) => this._reverseStreams[E.id]);
  };
  const o = r.RTCPeerConnection.prototype.addStream;
  r.RTCPeerConnection.prototype.addStream = function(C) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, C.getTracks().forEach((E) => {
      if (this.getSenders().find((O) => O.track === E))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[C.id]) {
      const E = new r.MediaStream(C.getTracks());
      this._streams[C.id] = E, this._reverseStreams[E.id] = C, C = E;
    }
    o.apply(this, [C]);
  };
  const u = r.RTCPeerConnection.prototype.removeStream;
  r.RTCPeerConnection.prototype.removeStream = function(C) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, u.apply(this, [this._streams[C.id] || C]), delete this._reverseStreams[this._streams[C.id] ? this._streams[C.id].id : C.id], delete this._streams[C.id];
  }, r.RTCPeerConnection.prototype.addTrack = function(C, E) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const x = [].slice.call(arguments, 1);
    if (x.length !== 1 || !x[0].getTracks().find((M) => M === C))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((M) => M.track === C))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const N = this._streams[E.id];
    if (N)
      N.addTrack(C), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const M = new r.MediaStream([C]);
      this._streams[E.id] = M, this._reverseStreams[M.id] = E, this.addStream(M);
    }
    return this.getSenders().find((M) => M.track === C);
  };
  function d(b, C) {
    let E = C.sdp;
    return Object.keys(b._reverseStreams || []).forEach((x) => {
      const O = b._reverseStreams[x], N = b._streams[O.id];
      E = E.replace(new RegExp(N.id, "g"), O.id);
    }), new RTCSessionDescription({
      type: C.type,
      sdp: E
    });
  }
  function c(b, C) {
    let E = C.sdp;
    return Object.keys(b._reverseStreams || []).forEach((x) => {
      const O = b._reverseStreams[x], N = b._streams[O.id];
      E = E.replace(new RegExp(O.id, "g"), N.id);
    }), new RTCSessionDescription({
      type: C.type,
      sdp: E
    });
  }
  ["createOffer", "createAnswer"].forEach(function(b) {
    const C = r.RTCPeerConnection.prototype[b], E = {
      [b]() {
        const x = arguments;
        return arguments.length && typeof arguments[0] == "function" ? C.apply(this, [(N) => {
          const M = d(this, N);
          x[0].apply(null, [M]);
        }, (N) => {
          x[1] && x[1].apply(null, N);
        }, arguments[2]]) : C.apply(this, arguments).then((N) => d(this, N));
      }
    };
    r.RTCPeerConnection.prototype[b] = E[b];
  });
  const m = r.RTCPeerConnection.prototype.setLocalDescription;
  r.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? m.apply(this, arguments) : (arguments[0] = c(this, arguments[0]), m.apply(this, arguments));
  };
  const g = Object.getOwnPropertyDescriptor(r.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(r.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const b = g.get.apply(this);
      return b.type === "" ? b : d(this, b);
    }
  }), r.RTCPeerConnection.prototype.removeTrack = function(C) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!C._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(C._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let x;
    Object.keys(this._streams).forEach((O) => {
      this._streams[O].getTracks().find((M) => C.track === M) && (x = this._streams[O]);
    }), x && (x.getTracks().length === 1 ? this.removeStream(this._reverseStreams[x.id]) : x.removeTrack(C.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function LT(r, t) {
  !r.RTCPeerConnection && r.webkitRTCPeerConnection && (r.RTCPeerConnection = r.webkitRTCPeerConnection), r.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(i) {
    const o = r.RTCPeerConnection.prototype[i], u = {
      [i]() {
        return arguments[0] = new (i === "addIceCandidate" ? r.RTCIceCandidate : r.RTCSessionDescription)(arguments[0]), o.apply(this, arguments);
      }
    };
    r.RTCPeerConnection.prototype[i] = u[i];
  });
}
function gD(r, t) {
  jd(r, "negotiationneeded", (i) => {
    const o = i.target;
    if (!((t.version < 72 || o.getConfiguration && o.getConfiguration().sdpSemantics === "plan-b") && o.signalingState !== "stable"))
      return i;
  });
}
var ax = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded: gD,
  shimAddTrackRemoveTrack: vD,
  shimAddTrackRemoveTrackWithNative: mD,
  shimGetSendersWithDtmf: pD,
  shimGetUserMedia: cD,
  shimMediaStream: dD,
  shimOnTrack: fD,
  shimPeerConnection: LT,
  shimSenderReceiverGetStats: hD
});
function yD(r, t) {
  const i = r && r.navigator, o = r && r.MediaStreamTrack;
  if (i.getUserMedia = function(u, d, c) {
    kE("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i.mediaDevices.getUserMedia(u).then(d, c);
  }, !(t.version > 55 && "autoGainControl" in i.mediaDevices.getSupportedConstraints())) {
    const u = function(c, m, g) {
      m in c && !(g in c) && (c[g] = c[m], delete c[m]);
    }, d = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
    if (i.mediaDevices.getUserMedia = function(c) {
      return typeof c == "object" && typeof c.audio == "object" && (c = JSON.parse(JSON.stringify(c)), u(c.audio, "autoGainControl", "mozAutoGainControl"), u(c.audio, "noiseSuppression", "mozNoiseSuppression")), d(c);
    }, o && o.prototype.getSettings) {
      const c = o.prototype.getSettings;
      o.prototype.getSettings = function() {
        const m = c.apply(this, arguments);
        return u(m, "mozAutoGainControl", "autoGainControl"), u(m, "mozNoiseSuppression", "noiseSuppression"), m;
      };
    }
    if (o && o.prototype.applyConstraints) {
      const c = o.prototype.applyConstraints;
      o.prototype.applyConstraints = function(m) {
        return this.kind === "audio" && typeof m == "object" && (m = JSON.parse(JSON.stringify(m)), u(m, "autoGainControl", "mozAutoGainControl"), u(m, "noiseSuppression", "mozNoiseSuppression")), c.apply(this, [m]);
      };
    }
  }
}
function n3(r, t) {
  r.navigator.mediaDevices && "getDisplayMedia" in r.navigator.mediaDevices || r.navigator.mediaDevices && (r.navigator.mediaDevices.getDisplayMedia = function(o) {
    if (!(o && o.video)) {
      const u = new DOMException("getDisplayMedia without video constraints is undefined");
      return u.name = "NotFoundError", u.code = 8, Promise.reject(u);
    }
    return o.video === !0 ? o.video = {
      mediaSource: t
    } : o.video.mediaSource = t, r.navigator.mediaDevices.getUserMedia(o);
  });
}
function bD(r) {
  typeof r == "object" && r.RTCTrackEvent && "receiver" in r.RTCTrackEvent.prototype && !("transceiver" in r.RTCTrackEvent.prototype) && Object.defineProperty(r.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function AT(r, t) {
  if (typeof r != "object" || !(r.RTCPeerConnection || r.mozRTCPeerConnection))
    return;
  !r.RTCPeerConnection && r.mozRTCPeerConnection && (r.RTCPeerConnection = r.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(u) {
    const d = r.RTCPeerConnection.prototype[u], c = {
      [u]() {
        return arguments[0] = new (u === "addIceCandidate" ? r.RTCIceCandidate : r.RTCSessionDescription)(arguments[0]), d.apply(this, arguments);
      }
    };
    r.RTCPeerConnection.prototype[u] = c[u];
  });
  const i = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, o = r.RTCPeerConnection.prototype.getStats;
  r.RTCPeerConnection.prototype.getStats = function() {
    const [d, c, m] = arguments;
    return o.apply(this, [d || null]).then((g) => {
      if (t.version < 53 && !c)
        try {
          g.forEach((b) => {
            b.type = i[b.type] || b.type;
          });
        } catch (b) {
          if (b.name !== "TypeError")
            throw b;
          g.forEach((C, E) => {
            g.set(E, Object.assign({}, C, {
              type: i[C.type] || C.type
            }));
          });
        }
      return g;
    }).then(c, m);
  };
}
function SD(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection && r.RTCRtpSender) || r.RTCRtpSender && "getStats" in r.RTCRtpSender.prototype)
    return;
  const t = r.RTCPeerConnection.prototype.getSenders;
  t && (r.RTCPeerConnection.prototype.getSenders = function() {
    const u = t.apply(this, []);
    return u.forEach((d) => d._pc = this), u;
  });
  const i = r.RTCPeerConnection.prototype.addTrack;
  i && (r.RTCPeerConnection.prototype.addTrack = function() {
    const u = i.apply(this, arguments);
    return u._pc = this, u;
  }), r.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function CD(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection && r.RTCRtpSender) || r.RTCRtpSender && "getStats" in r.RTCRtpReceiver.prototype)
    return;
  const t = r.RTCPeerConnection.prototype.getReceivers;
  t && (r.RTCPeerConnection.prototype.getReceivers = function() {
    const o = t.apply(this, []);
    return o.forEach((u) => u._pc = this), o;
  }), jd(r, "track", (i) => (i.receiver._pc = i.srcElement, i)), r.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function kD(r) {
  !r.RTCPeerConnection || "removeStream" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.removeStream = function(i) {
    kE("removeStream", "removeTrack"), this.getSenders().forEach((o) => {
      o.track && i.getTracks().includes(o.track) && this.removeTrack(o);
    });
  });
}
function TD(r) {
  r.DataChannel && !r.RTCDataChannel && (r.RTCDataChannel = r.DataChannel);
}
function ED(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection))
    return;
  const t = r.RTCPeerConnection.prototype.addTransceiver;
  t && (r.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let o = arguments[1] && arguments[1].sendEncodings;
    o === void 0 && (o = []), o = [...o];
    const u = o.length > 0;
    u && o.forEach((c) => {
      if ("rid" in c && !/^[a-z0-9]{0,16}$/i.test(c.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in c && !(parseFloat(c.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in c && !(parseFloat(c.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const d = t.apply(this, arguments);
    if (u) {
      const {
        sender: c
      } = d, m = c.getParameters();
      (!("encodings" in m) || // Avoid being fooled by patched getParameters() below.
      m.encodings.length === 1 && Object.keys(m.encodings[0]).length === 0) && (m.encodings = o, c.sendEncodings = o, this.setParametersPromises.push(c.setParameters(m).then(() => {
        delete c.sendEncodings;
      }).catch(() => {
        delete c.sendEncodings;
      })));
    }
    return d;
  });
}
function wD(r) {
  if (!(typeof r == "object" && r.RTCRtpSender))
    return;
  const t = r.RTCRtpSender.prototype.getParameters;
  t && (r.RTCRtpSender.prototype.getParameters = function() {
    const o = t.apply(this, arguments);
    return "encodings" in o || (o.encodings = [].concat(this.sendEncodings || [{}])), o;
  });
}
function RD(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection))
    return;
  const t = r.RTCPeerConnection.prototype.createOffer;
  r.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
function _D(r) {
  if (!(typeof r == "object" && r.RTCPeerConnection))
    return;
  const t = r.RTCPeerConnection.prototype.createAnswer;
  r.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
var ox = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver: ED,
  shimCreateAnswer: _D,
  shimCreateOffer: RD,
  shimGetDisplayMedia: n3,
  shimGetParameters: wD,
  shimGetUserMedia: yD,
  shimOnTrack: bD,
  shimPeerConnection: AT,
  shimRTCDataChannel: TD,
  shimReceiverGetStats: CD,
  shimRemoveStream: kD,
  shimSenderGetStats: SD
});
function xD(r) {
  if (!(typeof r != "object" || !r.RTCPeerConnection)) {
    if ("getLocalStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in r.RTCPeerConnection.prototype)) {
      const t = r.RTCPeerConnection.prototype.addTrack;
      r.RTCPeerConnection.prototype.addStream = function(o) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(o) || this._localStreams.push(o), o.getAudioTracks().forEach((u) => t.call(this, u, o)), o.getVideoTracks().forEach((u) => t.call(this, u, o));
      }, r.RTCPeerConnection.prototype.addTrack = function(o) {
        for (var u = arguments.length, d = new Array(u > 1 ? u - 1 : 0), c = 1; c < u; c++)
          d[c - 1] = arguments[c];
        return d && d.forEach((m) => {
          this._localStreams ? this._localStreams.includes(m) || this._localStreams.push(m) : this._localStreams = [m];
        }), t.apply(this, arguments);
      };
    }
    "removeStream" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.removeStream = function(i) {
      this._localStreams || (this._localStreams = []);
      const o = this._localStreams.indexOf(i);
      if (o === -1)
        return;
      this._localStreams.splice(o, 1);
      const u = i.getTracks();
      this.getSenders().forEach((d) => {
        u.includes(d.track) && this.removeTrack(d);
      });
    });
  }
}
function PD(r) {
  if (!(typeof r != "object" || !r.RTCPeerConnection) && ("getRemoteStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in r.RTCPeerConnection.prototype))) {
    Object.defineProperty(r.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(i) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = i), this.addEventListener("track", this._onaddstreampoly = (o) => {
          o.streams.forEach((u) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(u))
              return;
            this._remoteStreams.push(u);
            const d = new Event("addstream");
            d.stream = u, this.dispatchEvent(d);
          });
        });
      }
    });
    const t = r.RTCPeerConnection.prototype.setRemoteDescription;
    r.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const o = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(u) {
        u.streams.forEach((d) => {
          if (o._remoteStreams || (o._remoteStreams = []), o._remoteStreams.indexOf(d) >= 0)
            return;
          o._remoteStreams.push(d);
          const c = new Event("addstream");
          c.stream = d, o.dispatchEvent(c);
        });
      }), t.apply(o, arguments);
    };
  }
}
function DD(r) {
  if (typeof r != "object" || !r.RTCPeerConnection)
    return;
  const t = r.RTCPeerConnection.prototype, i = t.createOffer, o = t.createAnswer, u = t.setLocalDescription, d = t.setRemoteDescription, c = t.addIceCandidate;
  t.createOffer = function(b, C) {
    const E = arguments.length >= 2 ? arguments[2] : arguments[0], x = i.apply(this, [E]);
    return C ? (x.then(b, C), Promise.resolve()) : x;
  }, t.createAnswer = function(b, C) {
    const E = arguments.length >= 2 ? arguments[2] : arguments[0], x = o.apply(this, [E]);
    return C ? (x.then(b, C), Promise.resolve()) : x;
  };
  let m = function(g, b, C) {
    const E = u.apply(this, [g]);
    return C ? (E.then(b, C), Promise.resolve()) : E;
  };
  t.setLocalDescription = m, m = function(g, b, C) {
    const E = d.apply(this, [g]);
    return C ? (E.then(b, C), Promise.resolve()) : E;
  }, t.setRemoteDescription = m, m = function(g, b, C) {
    const E = c.apply(this, [g]);
    return C ? (E.then(b, C), Promise.resolve()) : E;
  }, t.addIceCandidate = m;
}
function OD(r) {
  const t = r && r.navigator;
  if (t.mediaDevices && t.mediaDevices.getUserMedia) {
    const i = t.mediaDevices, o = i.getUserMedia.bind(i);
    t.mediaDevices.getUserMedia = (u) => o(MD(u));
  }
  !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = (function(o, u, d) {
    t.mediaDevices.getUserMedia(o).then(u, d);
  }).bind(t));
}
function MD(r) {
  return r && r.video !== void 0 ? Object.assign({}, r, {
    video: uD(r.video)
  }) : r;
}
function ND(r) {
  if (!r.RTCPeerConnection)
    return;
  const t = r.RTCPeerConnection;
  r.RTCPeerConnection = function(o, u) {
    if (o && o.iceServers) {
      const d = [];
      for (let c = 0; c < o.iceServers.length; c++) {
        let m = o.iceServers[c];
        m.urls === void 0 && m.url ? (kE("RTCIceServer.url", "RTCIceServer.urls"), m = JSON.parse(JSON.stringify(m)), m.urls = m.url, delete m.url, d.push(m)) : d.push(o.iceServers[c]);
      }
      o.iceServers = d;
    }
    return new t(o, u);
  }, r.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(r.RTCPeerConnection, "generateCertificate", {
    get() {
      return t.generateCertificate;
    }
  });
}
function LD(r) {
  typeof r == "object" && r.RTCTrackEvent && "receiver" in r.RTCTrackEvent.prototype && !("transceiver" in r.RTCTrackEvent.prototype) && Object.defineProperty(r.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function AD(r) {
  const t = r.RTCPeerConnection.prototype.createOffer;
  r.RTCPeerConnection.prototype.createOffer = function(o) {
    if (o) {
      typeof o.offerToReceiveAudio < "u" && (o.offerToReceiveAudio = !!o.offerToReceiveAudio);
      const u = this.getTransceivers().find((c) => c.receiver.track.kind === "audio");
      o.offerToReceiveAudio === !1 && u ? u.direction === "sendrecv" ? u.setDirection ? u.setDirection("sendonly") : u.direction = "sendonly" : u.direction === "recvonly" && (u.setDirection ? u.setDirection("inactive") : u.direction = "inactive") : o.offerToReceiveAudio === !0 && !u && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof o.offerToReceiveVideo < "u" && (o.offerToReceiveVideo = !!o.offerToReceiveVideo);
      const d = this.getTransceivers().find((c) => c.receiver.track.kind === "video");
      o.offerToReceiveVideo === !1 && d ? d.direction === "sendrecv" ? d.setDirection ? d.setDirection("sendonly") : d.direction = "sendonly" : d.direction === "recvonly" && (d.setDirection ? d.setDirection("inactive") : d.direction = "inactive") : o.offerToReceiveVideo === !0 && !d && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return t.apply(this, arguments);
  };
}
function ID(r) {
  typeof r != "object" || r.AudioContext || (r.AudioContext = r.webkitAudioContext);
}
var sx = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext: ID,
  shimCallbacksAPI: DD,
  shimConstraints: MD,
  shimCreateOfferLegacy: AD,
  shimGetUserMedia: OD,
  shimLocalStreamsAPI: xD,
  shimRTCIceServerUrls: ND,
  shimRemoteStreamsAPI: PD,
  shimTrackEventTransceiver: LD
}), rT = { exports: {} }, lx;
function r3() {
  return lx || (lx = 1, function(r) {
    const t = {};
    t.generateIdentifier = function() {
      return Math.random().toString(36).substring(2, 12);
    }, t.localCName = t.generateIdentifier(), t.splitLines = function(i) {
      return i.trim().split(`
`).map((o) => o.trim());
    }, t.splitSections = function(i) {
      return i.split(`
m=`).map((u, d) => (d > 0 ? "m=" + u : u).trim() + `\r
`);
    }, t.getDescription = function(i) {
      const o = t.splitSections(i);
      return o && o[0];
    }, t.getMediaSections = function(i) {
      const o = t.splitSections(i);
      return o.shift(), o;
    }, t.matchPrefix = function(i, o) {
      return t.splitLines(i).filter((u) => u.indexOf(o) === 0);
    }, t.parseCandidate = function(i) {
      let o;
      i.indexOf("a=candidate:") === 0 ? o = i.substring(12).split(" ") : o = i.substring(10).split(" ");
      const u = {
        foundation: o[0],
        component: {
          1: "rtp",
          2: "rtcp"
        }[o[1]] || o[1],
        protocol: o[2].toLowerCase(),
        priority: parseInt(o[3], 10),
        ip: o[4],
        address: o[4],
        // address is an alias for ip.
        port: parseInt(o[5], 10),
        // skip parts[6] == 'typ'
        type: o[7]
      };
      for (let d = 8; d < o.length; d += 2)
        switch (o[d]) {
          case "raddr":
            u.relatedAddress = o[d + 1];
            break;
          case "rport":
            u.relatedPort = parseInt(o[d + 1], 10);
            break;
          case "tcptype":
            u.tcpType = o[d + 1];
            break;
          case "ufrag":
            u.ufrag = o[d + 1], u.usernameFragment = o[d + 1];
            break;
          default:
            u[o[d]] === void 0 && (u[o[d]] = o[d + 1]);
            break;
        }
      return u;
    }, t.writeCandidate = function(i) {
      const o = [];
      o.push(i.foundation);
      const u = i.component;
      u === "rtp" ? o.push(1) : u === "rtcp" ? o.push(2) : o.push(u), o.push(i.protocol.toUpperCase()), o.push(i.priority), o.push(i.address || i.ip), o.push(i.port);
      const d = i.type;
      return o.push("typ"), o.push(d), d !== "host" && i.relatedAddress && i.relatedPort && (o.push("raddr"), o.push(i.relatedAddress), o.push("rport"), o.push(i.relatedPort)), i.tcpType && i.protocol.toLowerCase() === "tcp" && (o.push("tcptype"), o.push(i.tcpType)), (i.usernameFragment || i.ufrag) && (o.push("ufrag"), o.push(i.usernameFragment || i.ufrag)), "candidate:" + o.join(" ");
    }, t.parseIceOptions = function(i) {
      return i.substring(14).split(" ");
    }, t.parseRtpMap = function(i) {
      let o = i.substring(9).split(" ");
      const u = {
        payloadType: parseInt(o.shift(), 10)
        // was: id
      };
      return o = o[0].split("/"), u.name = o[0], u.clockRate = parseInt(o[1], 10), u.channels = o.length === 3 ? parseInt(o[2], 10) : 1, u.numChannels = u.channels, u;
    }, t.writeRtpMap = function(i) {
      let o = i.payloadType;
      i.preferredPayloadType !== void 0 && (o = i.preferredPayloadType);
      const u = i.channels || i.numChannels || 1;
      return "a=rtpmap:" + o + " " + i.name + "/" + i.clockRate + (u !== 1 ? "/" + u : "") + `\r
`;
    }, t.parseExtmap = function(i) {
      const o = i.substring(9).split(" ");
      return {
        id: parseInt(o[0], 10),
        direction: o[0].indexOf("/") > 0 ? o[0].split("/")[1] : "sendrecv",
        uri: o[1],
        attributes: o.slice(2).join(" ")
      };
    }, t.writeExtmap = function(i) {
      return "a=extmap:" + (i.id || i.preferredId) + (i.direction && i.direction !== "sendrecv" ? "/" + i.direction : "") + " " + i.uri + (i.attributes ? " " + i.attributes : "") + `\r
`;
    }, t.parseFmtp = function(i) {
      const o = {};
      let u;
      const d = i.substring(i.indexOf(" ") + 1).split(";");
      for (let c = 0; c < d.length; c++)
        u = d[c].trim().split("="), o[u[0].trim()] = u[1];
      return o;
    }, t.writeFmtp = function(i) {
      let o = "", u = i.payloadType;
      if (i.preferredPayloadType !== void 0 && (u = i.preferredPayloadType), i.parameters && Object.keys(i.parameters).length) {
        const d = [];
        Object.keys(i.parameters).forEach((c) => {
          i.parameters[c] !== void 0 ? d.push(c + "=" + i.parameters[c]) : d.push(c);
        }), o += "a=fmtp:" + u + " " + d.join(";") + `\r
`;
      }
      return o;
    }, t.parseRtcpFb = function(i) {
      const o = i.substring(i.indexOf(" ") + 1).split(" ");
      return {
        type: o.shift(),
        parameter: o.join(" ")
      };
    }, t.writeRtcpFb = function(i) {
      let o = "", u = i.payloadType;
      return i.preferredPayloadType !== void 0 && (u = i.preferredPayloadType), i.rtcpFeedback && i.rtcpFeedback.length && i.rtcpFeedback.forEach((d) => {
        o += "a=rtcp-fb:" + u + " " + d.type + (d.parameter && d.parameter.length ? " " + d.parameter : "") + `\r
`;
      }), o;
    }, t.parseSsrcMedia = function(i) {
      const o = i.indexOf(" "), u = {
        ssrc: parseInt(i.substring(7, o), 10)
      }, d = i.indexOf(":", o);
      return d > -1 ? (u.attribute = i.substring(o + 1, d), u.value = i.substring(d + 1)) : u.attribute = i.substring(o + 1), u;
    }, t.parseSsrcGroup = function(i) {
      const o = i.substring(13).split(" ");
      return {
        semantics: o.shift(),
        ssrcs: o.map((u) => parseInt(u, 10))
      };
    }, t.getMid = function(i) {
      const o = t.matchPrefix(i, "a=mid:")[0];
      if (o)
        return o.substring(6);
    }, t.parseFingerprint = function(i) {
      const o = i.substring(14).split(" ");
      return {
        algorithm: o[0].toLowerCase(),
        // algorithm is case-sensitive in Edge.
        value: o[1].toUpperCase()
        // the definition is upper-case in RFC 4572.
      };
    }, t.getDtlsParameters = function(i, o) {
      return {
        role: "auto",
        fingerprints: t.matchPrefix(i + o, "a=fingerprint:").map(t.parseFingerprint)
      };
    }, t.writeDtlsParameters = function(i, o) {
      let u = "a=setup:" + o + `\r
`;
      return i.fingerprints.forEach((d) => {
        u += "a=fingerprint:" + d.algorithm + " " + d.value + `\r
`;
      }), u;
    }, t.parseCryptoLine = function(i) {
      const o = i.substring(9).split(" ");
      return {
        tag: parseInt(o[0], 10),
        cryptoSuite: o[1],
        keyParams: o[2],
        sessionParams: o.slice(3)
      };
    }, t.writeCryptoLine = function(i) {
      return "a=crypto:" + i.tag + " " + i.cryptoSuite + " " + (typeof i.keyParams == "object" ? t.writeCryptoKeyParams(i.keyParams) : i.keyParams) + (i.sessionParams ? " " + i.sessionParams.join(" ") : "") + `\r
`;
    }, t.parseCryptoKeyParams = function(i) {
      if (i.indexOf("inline:") !== 0)
        return null;
      const o = i.substring(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: o[0],
        lifeTime: o[1],
        mkiValue: o[2] ? o[2].split(":")[0] : void 0,
        mkiLength: o[2] ? o[2].split(":")[1] : void 0
      };
    }, t.writeCryptoKeyParams = function(i) {
      return i.keyMethod + ":" + i.keySalt + (i.lifeTime ? "|" + i.lifeTime : "") + (i.mkiValue && i.mkiLength ? "|" + i.mkiValue + ":" + i.mkiLength : "");
    }, t.getCryptoParameters = function(i, o) {
      return t.matchPrefix(i + o, "a=crypto:").map(t.parseCryptoLine);
    }, t.getIceParameters = function(i, o) {
      const u = t.matchPrefix(i + o, "a=ice-ufrag:")[0], d = t.matchPrefix(i + o, "a=ice-pwd:")[0];
      return u && d ? {
        usernameFragment: u.substring(12),
        password: d.substring(10)
      } : null;
    }, t.writeIceParameters = function(i) {
      let o = "a=ice-ufrag:" + i.usernameFragment + `\r
a=ice-pwd:` + i.password + `\r
`;
      return i.iceLite && (o += `a=ice-lite\r
`), o;
    }, t.parseRtpParameters = function(i) {
      const o = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      }, d = t.splitLines(i)[0].split(" ");
      o.profile = d[2];
      for (let m = 3; m < d.length; m++) {
        const g = d[m], b = t.matchPrefix(i, "a=rtpmap:" + g + " ")[0];
        if (b) {
          const C = t.parseRtpMap(b), E = t.matchPrefix(i, "a=fmtp:" + g + " ");
          switch (C.parameters = E.length ? t.parseFmtp(E[0]) : {}, C.rtcpFeedback = t.matchPrefix(i, "a=rtcp-fb:" + g + " ").map(t.parseRtcpFb), o.codecs.push(C), C.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              o.fecMechanisms.push(C.name.toUpperCase());
              break;
          }
        }
      }
      t.matchPrefix(i, "a=extmap:").forEach((m) => {
        o.headerExtensions.push(t.parseExtmap(m));
      });
      const c = t.matchPrefix(i, "a=rtcp-fb:* ").map(t.parseRtcpFb);
      return o.codecs.forEach((m) => {
        c.forEach((g) => {
          m.rtcpFeedback.find((C) => C.type === g.type && C.parameter === g.parameter) || m.rtcpFeedback.push(g);
        });
      }), o;
    }, t.writeRtpDescription = function(i, o) {
      let u = "";
      u += "m=" + i + " ", u += o.codecs.length > 0 ? "9" : "0", u += " " + (o.profile || "UDP/TLS/RTP/SAVPF") + " ", u += o.codecs.map((c) => c.preferredPayloadType !== void 0 ? c.preferredPayloadType : c.payloadType).join(" ") + `\r
`, u += `c=IN IP4 0.0.0.0\r
`, u += `a=rtcp:9 IN IP4 0.0.0.0\r
`, o.codecs.forEach((c) => {
        u += t.writeRtpMap(c), u += t.writeFmtp(c), u += t.writeRtcpFb(c);
      });
      let d = 0;
      return o.codecs.forEach((c) => {
        c.maxptime > d && (d = c.maxptime);
      }), d > 0 && (u += "a=maxptime:" + d + `\r
`), o.headerExtensions && o.headerExtensions.forEach((c) => {
        u += t.writeExtmap(c);
      }), u;
    }, t.parseRtpEncodingParameters = function(i) {
      const o = [], u = t.parseRtpParameters(i), d = u.fecMechanisms.indexOf("RED") !== -1, c = u.fecMechanisms.indexOf("ULPFEC") !== -1, m = t.matchPrefix(i, "a=ssrc:").map((x) => t.parseSsrcMedia(x)).filter((x) => x.attribute === "cname"), g = m.length > 0 && m[0].ssrc;
      let b;
      const C = t.matchPrefix(i, "a=ssrc-group:FID").map((x) => x.substring(17).split(" ").map((N) => parseInt(N, 10)));
      C.length > 0 && C[0].length > 1 && C[0][0] === g && (b = C[0][1]), u.codecs.forEach((x) => {
        if (x.name.toUpperCase() === "RTX" && x.parameters.apt) {
          let O = {
            ssrc: g,
            codecPayloadType: parseInt(x.parameters.apt, 10)
          };
          g && b && (O.rtx = {
            ssrc: b
          }), o.push(O), d && (O = JSON.parse(JSON.stringify(O)), O.fec = {
            ssrc: g,
            mechanism: c ? "red+ulpfec" : "red"
          }, o.push(O));
        }
      }), o.length === 0 && g && o.push({
        ssrc: g
      });
      let E = t.matchPrefix(i, "b=");
      return E.length && (E[0].indexOf("b=TIAS:") === 0 ? E = parseInt(E[0].substring(7), 10) : E[0].indexOf("b=AS:") === 0 ? E = parseInt(E[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : E = void 0, o.forEach((x) => {
        x.maxBitrate = E;
      })), o;
    }, t.parseRtcpParameters = function(i) {
      const o = {}, u = t.matchPrefix(i, "a=ssrc:").map((m) => t.parseSsrcMedia(m)).filter((m) => m.attribute === "cname")[0];
      u && (o.cname = u.value, o.ssrc = u.ssrc);
      const d = t.matchPrefix(i, "a=rtcp-rsize");
      o.reducedSize = d.length > 0, o.compound = d.length === 0;
      const c = t.matchPrefix(i, "a=rtcp-mux");
      return o.mux = c.length > 0, o;
    }, t.writeRtcpParameters = function(i) {
      let o = "";
      return i.reducedSize && (o += `a=rtcp-rsize\r
`), i.mux && (o += `a=rtcp-mux\r
`), i.ssrc !== void 0 && i.cname && (o += "a=ssrc:" + i.ssrc + " cname:" + i.cname + `\r
`), o;
    }, t.parseMsid = function(i) {
      let o;
      const u = t.matchPrefix(i, "a=msid:");
      if (u.length === 1)
        return o = u[0].substring(7).split(" "), {
          stream: o[0],
          track: o[1]
        };
      const d = t.matchPrefix(i, "a=ssrc:").map((c) => t.parseSsrcMedia(c)).filter((c) => c.attribute === "msid");
      if (d.length > 0)
        return o = d[0].value.split(" "), {
          stream: o[0],
          track: o[1]
        };
    }, t.parseSctpDescription = function(i) {
      const o = t.parseMLine(i), u = t.matchPrefix(i, "a=max-message-size:");
      let d;
      u.length > 0 && (d = parseInt(u[0].substring(19), 10)), isNaN(d) && (d = 65536);
      const c = t.matchPrefix(i, "a=sctp-port:");
      if (c.length > 0)
        return {
          port: parseInt(c[0].substring(12), 10),
          protocol: o.fmt,
          maxMessageSize: d
        };
      const m = t.matchPrefix(i, "a=sctpmap:");
      if (m.length > 0) {
        const g = m[0].substring(10).split(" ");
        return {
          port: parseInt(g[0], 10),
          protocol: g[1],
          maxMessageSize: d
        };
      }
    }, t.writeSctpDescription = function(i, o) {
      let u = [];
      return i.protocol !== "DTLS/SCTP" ? u = ["m=" + i.kind + " 9 " + i.protocol + " " + o.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + o.port + `\r
`] : u = ["m=" + i.kind + " 9 " + i.protocol + " " + o.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + o.port + " " + o.protocol + ` 65535\r
`], o.maxMessageSize !== void 0 && u.push("a=max-message-size:" + o.maxMessageSize + `\r
`), u.join("");
    }, t.generateSessionId = function() {
      return Math.random().toString().substr(2, 22);
    }, t.writeSessionBoilerplate = function(i, o, u) {
      let d;
      const c = o !== void 0 ? o : 2;
      return i ? d = i : d = t.generateSessionId(), `v=0\r
o=` + (u || "thisisadapterortc") + " " + d + " " + c + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
    }, t.getDirection = function(i, o) {
      const u = t.splitLines(i);
      for (let d = 0; d < u.length; d++)
        switch (u[d]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return u[d].substring(2);
        }
      return o ? t.getDirection(o) : "sendrecv";
    }, t.getKind = function(i) {
      return t.splitLines(i)[0].split(" ")[0].substring(2);
    }, t.isRejected = function(i) {
      return i.split(" ", 2)[1] === "0";
    }, t.parseMLine = function(i) {
      const u = t.splitLines(i)[0].substring(2).split(" ");
      return {
        kind: u[0],
        port: parseInt(u[1], 10),
        protocol: u[2],
        fmt: u.slice(3).join(" ")
      };
    }, t.parseOLine = function(i) {
      const u = t.matchPrefix(i, "o=")[0].substring(2).split(" ");
      return {
        username: u[0],
        sessionId: u[1],
        sessionVersion: parseInt(u[2], 10),
        netType: u[3],
        addressType: u[4],
        address: u[5]
      };
    }, t.isValidSDP = function(i) {
      if (typeof i != "string" || i.length === 0)
        return !1;
      const o = t.splitLines(i);
      for (let u = 0; u < o.length; u++)
        if (o[u].length < 2 || o[u].charAt(1) !== "=")
          return !1;
      return !0;
    }, r.exports = t;
  }(rT)), rT.exports;
}
var UD = r3(), zp = /* @__PURE__ */ WU(UD), i3 = /* @__PURE__ */ h5({
  __proto__: null,
  default: zp
}, [UD]);
function V0(r) {
  if (!r.RTCIceCandidate || r.RTCIceCandidate && "foundation" in r.RTCIceCandidate.prototype)
    return;
  const t = r.RTCIceCandidate;
  r.RTCIceCandidate = function(o) {
    if (typeof o == "object" && o.candidate && o.candidate.indexOf("a=") === 0 && (o = JSON.parse(JSON.stringify(o)), o.candidate = o.candidate.substring(2)), o.candidate && o.candidate.length) {
      const u = new t(o), d = zp.parseCandidate(o.candidate);
      for (const c in d)
        c in u || Object.defineProperty(u, c, {
          value: d[c]
        });
      return u.toJSON = function() {
        return {
          candidate: u.candidate,
          sdpMid: u.sdpMid,
          sdpMLineIndex: u.sdpMLineIndex,
          usernameFragment: u.usernameFragment
        };
      }, u;
    }
    return new t(o);
  }, r.RTCIceCandidate.prototype = t.prototype, jd(r, "icecandidate", (i) => (i.candidate && Object.defineProperty(i, "candidate", {
    value: new r.RTCIceCandidate(i.candidate),
    writable: "false"
  }), i));
}
function IT(r) {
  !r.RTCIceCandidate || r.RTCIceCandidate && "relayProtocol" in r.RTCIceCandidate.prototype || jd(r, "icecandidate", (t) => {
    if (t.candidate) {
      const i = zp.parseCandidate(t.candidate.candidate);
      i.type === "relay" && (t.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[i.priority >> 24]);
    }
    return t;
  });
}
function B0(r, t) {
  if (!r.RTCPeerConnection)
    return;
  "sctp" in r.RTCPeerConnection.prototype || Object.defineProperty(r.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const i = function(m) {
    if (!m || !m.sdp)
      return !1;
    const g = zp.splitSections(m.sdp);
    return g.shift(), g.some((b) => {
      const C = zp.parseMLine(b);
      return C && C.kind === "application" && C.protocol.indexOf("SCTP") !== -1;
    });
  }, o = function(m) {
    const g = m.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (g === null || g.length < 2)
      return -1;
    const b = parseInt(g[1], 10);
    return b !== b ? -1 : b;
  }, u = function(m) {
    let g = 65536;
    return t.browser === "firefox" && (t.version < 57 ? m === -1 ? g = 16384 : g = 2147483637 : t.version < 60 ? g = t.version === 57 ? 65535 : 65536 : g = 2147483637), g;
  }, d = function(m, g) {
    let b = 65536;
    t.browser === "firefox" && t.version === 57 && (b = 65535);
    const C = zp.matchPrefix(m.sdp, "a=max-message-size:");
    return C.length > 0 ? b = parseInt(C[0].substring(19), 10) : t.browser === "firefox" && g !== -1 && (b = 2147483637), b;
  }, c = r.RTCPeerConnection.prototype.setRemoteDescription;
  r.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, t.browser === "chrome" && t.version >= 76) {
      const {
        sdpSemantics: g
      } = this.getConfiguration();
      g === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (i(arguments[0])) {
      const g = o(arguments[0]), b = u(g), C = d(arguments[0], g);
      let E;
      b === 0 && C === 0 ? E = Number.POSITIVE_INFINITY : b === 0 || C === 0 ? E = Math.max(b, C) : E = Math.min(b, C);
      const x = {};
      Object.defineProperty(x, "maxMessageSize", {
        get() {
          return E;
        }
      }), this._sctp = x;
    }
    return c.apply(this, arguments);
  };
}
function H0(r) {
  if (!(r.RTCPeerConnection && "createDataChannel" in r.RTCPeerConnection.prototype))
    return;
  function t(o, u) {
    const d = o.send;
    o.send = function() {
      const m = arguments[0], g = m.length || m.size || m.byteLength;
      if (o.readyState === "open" && u.sctp && g > u.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + u.sctp.maxMessageSize + " bytes)");
      return d.apply(o, arguments);
    };
  }
  const i = r.RTCPeerConnection.prototype.createDataChannel;
  r.RTCPeerConnection.prototype.createDataChannel = function() {
    const u = i.apply(this, arguments);
    return t(u, this), u;
  }, jd(r, "datachannel", (o) => (t(o.channel, o.target), o));
}
function UT(r) {
  if (!r.RTCPeerConnection || "connectionState" in r.RTCPeerConnection.prototype)
    return;
  const t = r.RTCPeerConnection.prototype;
  Object.defineProperty(t, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(i) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), i && this.addEventListener("connectionstatechange", this._onconnectionstatechange = i);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((i) => {
    const o = t[i];
    t[i] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (u) => {
        const d = u.target;
        if (d._lastConnectionState !== d.connectionState) {
          d._lastConnectionState = d.connectionState;
          const c = new Event("connectionstatechange", u);
          d.dispatchEvent(c);
        }
        return u;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), o.apply(this, arguments);
    };
  });
}
function FT(r, t) {
  if (!r.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605)
    return;
  const i = r.RTCPeerConnection.prototype.setRemoteDescription;
  r.RTCPeerConnection.prototype.setRemoteDescription = function(u) {
    if (u && u.sdp && u.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const d = u.sdp.split(`
`).filter((c) => c.trim() !== "a=extmap-allow-mixed").join(`
`);
      r.RTCSessionDescription && u instanceof r.RTCSessionDescription ? arguments[0] = new r.RTCSessionDescription({
        type: u.type,
        sdp: d
      }) : u.sdp = d;
    }
    return i.apply(this, arguments);
  };
}
function $0(r, t) {
  if (!(r.RTCPeerConnection && r.RTCPeerConnection.prototype))
    return;
  const i = r.RTCPeerConnection.prototype.addIceCandidate;
  !i || i.length === 0 || (r.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function q0(r, t) {
  if (!(r.RTCPeerConnection && r.RTCPeerConnection.prototype))
    return;
  const i = r.RTCPeerConnection.prototype.setLocalDescription;
  !i || i.length === 0 || (r.RTCPeerConnection.prototype.setLocalDescription = function() {
    let u = arguments[0] || {};
    if (typeof u != "object" || u.type && u.sdp)
      return i.apply(this, arguments);
    if (u = {
      type: u.type,
      sdp: u.sdp
    }, !u.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          u.type = "offer";
          break;
        default:
          u.type = "answer";
          break;
      }
    return u.sdp || u.type !== "offer" && u.type !== "answer" ? i.apply(this, [u]) : (u.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((c) => i.apply(this, [c]));
  });
}
var a3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed: FT,
  shimAddIceCandidateNullOrEmpty: $0,
  shimConnectionState: UT,
  shimMaxMessageSize: B0,
  shimParameterlessSetLocalDescription: q0,
  shimRTCIceCandidate: V0,
  shimRTCIceCandidateRelayProtocol: IT,
  shimSendThrowTypeError: H0
});
function o3() {
  let {
    window: r
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const i = lD, o = t3(r), u = {
    browserDetails: o,
    commonShim: a3,
    extractVersion: z0,
    disableLog: ZU,
    disableWarnings: e3,
    // Expose sdp as a convenience. For production apps include directly.
    sdp: i3
  };
  switch (o.browser) {
    case "chrome":
      if (!ax || !LT || !t.shimChrome)
        return i("Chrome shim is not included in this adapter release."), u;
      if (o.version === null)
        return i("Chrome shim can not determine version, not shimming."), u;
      i("adapter.js shimming chrome."), u.browserShim = ax, $0(r, o), q0(r), cD(r, o), dD(r), LT(r, o), fD(r), vD(r, o), pD(r), hD(r), gD(r, o), V0(r), IT(r), UT(r), B0(r, o), H0(r), FT(r, o);
      break;
    case "firefox":
      if (!ox || !AT || !t.shimFirefox)
        return i("Firefox shim is not included in this adapter release."), u;
      i("adapter.js shimming firefox."), u.browserShim = ox, $0(r, o), q0(r), yD(r, o), AT(r, o), bD(r), kD(r), SD(r), CD(r), TD(r), ED(r), wD(r), RD(r), _D(r), V0(r), UT(r), B0(r, o), H0(r);
      break;
    case "safari":
      if (!sx || !t.shimSafari)
        return i("Safari shim is not included in this adapter release."), u;
      i("adapter.js shimming safari."), u.browserShim = sx, $0(r, o), q0(r), ND(r), AD(r), DD(r), xD(r), PD(r), LD(r), OD(r), ID(r), V0(r), IT(r), B0(r, o), H0(r), FT(r, o);
      break;
    default:
      i("Unsupported browser!");
      break;
  }
  return u;
}
o3({
  window: typeof window > "u" ? void 0 : window
});
const s3 = 10, D0 = "lk_e2ee", l3 = "LKFrameEncryptionKey", u3 = {
  sharedKey: !1,
  ratchetSalt: l3,
  ratchetWindowSize: 8,
  failureTolerance: s3,
  keyringSize: 16
};
var yc;
(function(r) {
  r.SetKey = "setKey", r.RatchetRequest = "ratchetRequest", r.KeyRatcheted = "keyRatcheted";
})(yc || (yc = {}));
var ux;
(function(r) {
  r.KeyRatcheted = "keyRatcheted";
})(ux || (ux = {}));
var vc;
(function(r) {
  r.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", r.EncryptionError = "encryptionError";
})(vc || (vc = {}));
var cx;
(function(r) {
  r.Error = "cryptorError";
})(cx || (cx = {}));
function c3() {
  return d3() || jT();
}
function jT() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function d3() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
function f3(r) {
  return G(this, void 0, void 0, function* () {
    let t = new TextEncoder();
    return yield crypto.subtle.importKey("raw", t.encode(r), {
      name: "PBKDF2"
    }, !1, ["deriveBits", "deriveKey"]);
  });
}
function p3(r) {
  return G(this, void 0, void 0, function* () {
    return yield crypto.subtle.importKey("raw", r, "HKDF", !1, ["deriveBits", "deriveKey"]);
  });
}
class h3 extends rl.EventEmitter {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (i, o) => {
      Wt.debug("key ratcheted event received", {
        material: i,
        keyIndex: o
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, u3), t), this.on(yc.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(t, i, o) {
    const u = {
      key: t,
      participantIdentity: i,
      keyIndex: o
    };
    if (!this.options.sharedKey && !i)
      throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
    this.keyInfoMap.set("".concat(i ?? "shared", "-").concat(o ?? 0), u), this.emit(yc.SetKey, u);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(t, i) {
    this.emit(yc.RatchetRequest, t, i);
  }
}
class m3 extends h3 {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const i = Object.assign(Object.assign({}, t), {
      sharedKey: !0,
      // for a shared key provider failing to decrypt for a specific participant
      // should not mark the key as invalid, so we accept wrong keys forever
      // and won't try to auto-ratchet
      ratchetWindowSize: 0,
      failureTolerance: -1
    });
    super(i);
  }
  /**
   * Accepts a passphrase that's used to create the crypto keys.
   * When passing in a string, PBKDF2 is used.
   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)
   * @param key
   */
  setKey(t) {
    return G(this, void 0, void 0, function* () {
      const i = typeof t == "string" ? yield f3(t) : yield p3(t);
      this.onSetEncryptionKey(i);
    });
  }
}
class zd extends Error {
  constructor(t, i) {
    super(i || "an error has occured"), this.code = t;
  }
}
var nn;
(function(r) {
  r[r.NotAllowed = 0] = "NotAllowed", r[r.ServerUnreachable = 1] = "ServerUnreachable", r[r.InternalError = 2] = "InternalError", r[r.Cancelled = 3] = "Cancelled", r[r.LeaveRequest = 4] = "LeaveRequest";
})(nn || (nn = {}));
class xn extends zd {
  constructor(t, i, o, u) {
    super(1, t), this.status = o, this.reason = i, this.context = u;
  }
}
class mb extends zd {
  constructor(t) {
    super(21, t ?? "device is unsupported");
  }
}
class Gl extends zd {
  constructor(t) {
    super(20, t ?? "track is invalid");
  }
}
class v3 extends zd {
  constructor(t) {
    super(10, t ?? "unsupported server");
  }
}
class zr extends zd {
  constructor(t) {
    super(12, t ?? "unexpected connection state");
  }
}
class zT extends zd {
  constructor(t) {
    super(13, t ?? "unable to negotiate");
  }
}
class dx extends zd {
  constructor(t, i) {
    super(15, t), this.reason = i;
  }
}
var Rv;
(function(r) {
  r.PermissionDenied = "PermissionDenied", r.NotFound = "NotFound", r.DeviceInUse = "DeviceInUse", r.Other = "Other";
})(Rv || (Rv = {}));
(function(r) {
  function t(i) {
    if (i && "name" in i)
      return i.name === "NotFoundError" || i.name === "DevicesNotFoundError" ? r.NotFound : i.name === "NotAllowedError" || i.name === "PermissionDeniedError" ? r.PermissionDenied : i.name === "NotReadableError" || i.name === "TrackStartError" ? r.DeviceInUse : r.Other;
  }
  r.getFailure = t;
})(Rv || (Rv = {}));
var fx;
(function(r) {
  r[r.InvalidKey = 0] = "InvalidKey", r[r.MissingKey = 1] = "MissingKey", r[r.InternalError = 2] = "InternalError";
})(fx || (fx = {}));
var ne;
(function(r) {
  r.Connected = "connected", r.Reconnecting = "reconnecting", r.SignalReconnecting = "signalReconnecting", r.Reconnected = "reconnected", r.Disconnected = "disconnected", r.ConnectionStateChanged = "connectionStateChanged", r.MediaDevicesChanged = "mediaDevicesChanged", r.ParticipantConnected = "participantConnected", r.ParticipantDisconnected = "participantDisconnected", r.TrackPublished = "trackPublished", r.TrackSubscribed = "trackSubscribed", r.TrackSubscriptionFailed = "trackSubscriptionFailed", r.TrackUnpublished = "trackUnpublished", r.TrackUnsubscribed = "trackUnsubscribed", r.TrackMuted = "trackMuted", r.TrackUnmuted = "trackUnmuted", r.LocalTrackPublished = "localTrackPublished", r.LocalTrackUnpublished = "localTrackUnpublished", r.LocalAudioSilenceDetected = "localAudioSilenceDetected", r.ActiveSpeakersChanged = "activeSpeakersChanged", r.ParticipantMetadataChanged = "participantMetadataChanged", r.ParticipantNameChanged = "participantNameChanged", r.ParticipantAttributesChanged = "participantAttributesChanged", r.RoomMetadataChanged = "roomMetadataChanged", r.DataReceived = "dataReceived", r.SipDTMFReceived = "sipDTMFReceived", r.TranscriptionReceived = "transcriptionReceived", r.ConnectionQualityChanged = "connectionQualityChanged", r.TrackStreamStateChanged = "trackStreamStateChanged", r.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", r.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", r.AudioPlaybackStatusChanged = "audioPlaybackChanged", r.VideoPlaybackStatusChanged = "videoPlaybackChanged", r.MediaDevicesError = "mediaDevicesError", r.ParticipantPermissionsChanged = "participantPermissionsChanged", r.SignalConnected = "signalConnected", r.RecordingStatusChanged = "recordingStatusChanged", r.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", r.EncryptionError = "encryptionError", r.DCBufferStatusChanged = "dcBufferStatusChanged", r.ActiveDeviceChanged = "activeDeviceChanged", r.ChatMessage = "chatMessage", r.LocalTrackSubscribed = "localTrackSubscribed", r.MetricsReceived = "metricsReceived";
})(ne || (ne = {}));
var ce;
(function(r) {
  r.TrackPublished = "trackPublished", r.TrackSubscribed = "trackSubscribed", r.TrackSubscriptionFailed = "trackSubscriptionFailed", r.TrackUnpublished = "trackUnpublished", r.TrackUnsubscribed = "trackUnsubscribed", r.TrackMuted = "trackMuted", r.TrackUnmuted = "trackUnmuted", r.LocalTrackPublished = "localTrackPublished", r.LocalTrackUnpublished = "localTrackUnpublished", r.ParticipantMetadataChanged = "participantMetadataChanged", r.ParticipantNameChanged = "participantNameChanged", r.DataReceived = "dataReceived", r.SipDTMFReceived = "sipDTMFReceived", r.TranscriptionReceived = "transcriptionReceived", r.IsSpeakingChanged = "isSpeakingChanged", r.ConnectionQualityChanged = "connectionQualityChanged", r.TrackStreamStateChanged = "trackStreamStateChanged", r.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", r.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", r.MediaDevicesError = "mediaDevicesError", r.AudioStreamAcquired = "audioStreamAcquired", r.ParticipantPermissionsChanged = "participantPermissionsChanged", r.PCTrackAdded = "pcTrackAdded", r.AttributesChanged = "attributesChanged", r.LocalTrackSubscribed = "localTrackSubscribed", r.ChatMessage = "chatMessage";
})(ce || (ce = {}));
var qe;
(function(r) {
  r.TransportsCreated = "transportsCreated", r.Connected = "connected", r.Disconnected = "disconnected", r.Resuming = "resuming", r.Resumed = "resumed", r.Restarting = "restarting", r.Restarted = "restarted", r.SignalResumed = "signalResumed", r.SignalRestarted = "signalRestarted", r.Closing = "closing", r.MediaTrackAdded = "mediaTrackAdded", r.ActiveSpeakersUpdate = "activeSpeakersUpdate", r.DataPacketReceived = "dataPacketReceived", r.RTPVideoMapUpdate = "rtpVideoMapUpdate", r.DCBufferStatusChanged = "dcBufferStatusChanged", r.ParticipantUpdate = "participantUpdate", r.RoomUpdate = "roomUpdate", r.SpeakersChanged = "speakersChanged", r.StreamStateChanged = "streamStateChanged", r.ConnectionQualityUpdate = "connectionQualityUpdate", r.SubscriptionError = "subscriptionError", r.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", r.RemoteMute = "remoteMute", r.SubscribedQualityUpdate = "subscribedQualityUpdate", r.LocalTrackUnpublished = "localTrackUnpublished", r.LocalTrackSubscribed = "localTrackSubscribed", r.Offline = "offline", r.SignalRequestResponse = "signalRequestResponse";
})(qe || (qe = {}));
var Le;
(function(r) {
  r.Message = "message", r.Muted = "muted", r.Unmuted = "unmuted", r.Restarted = "restarted", r.Ended = "ended", r.Subscribed = "subscribed", r.Unsubscribed = "unsubscribed", r.UpdateSettings = "updateSettings", r.UpdateSubscription = "updateSubscription", r.AudioPlaybackStarted = "audioPlaybackStarted", r.AudioPlaybackFailed = "audioPlaybackFailed", r.AudioSilenceDetected = "audioSilenceDetected", r.VisibilityChanged = "visibilityChanged", r.VideoDimensionsChanged = "videoDimensionsChanged", r.VideoPlaybackStarted = "videoPlaybackStarted", r.VideoPlaybackFailed = "videoPlaybackFailed", r.ElementAttached = "elementAttached", r.ElementDetached = "elementDetached", r.UpstreamPaused = "upstreamPaused", r.UpstreamResumed = "upstreamResumed", r.SubscriptionPermissionChanged = "subscriptionPermissionChanged", r.SubscriptionStatusChanged = "subscriptionStatusChanged", r.SubscriptionFailed = "subscriptionFailed", r.TrackProcessorUpdate = "trackProcessorUpdate", r.AudioTrackFeatureUpdate = "audioTrackFeatureUpdate", r.TranscriptionReceived = "transcriptionReceived", r.TimeSyncUpdate = "timeSyncUpdate";
})(Le || (Le = {}));
function TE(r, t, i) {
  var o, u, d;
  t === void 0 && (t = 50), i === void 0 && (i = {});
  var c = (o = i.isImmediate) != null && o, m = (u = i.callback) != null && u, g = i.maxWait, b = Date.now(), C = [];
  function E() {
    if (g !== void 0) {
      var O = Date.now() - b;
      if (O + t >= g)
        return g - O;
    }
    return t;
  }
  var x = function() {
    var O = [].slice.call(arguments), N = this;
    return new Promise(function(M, I) {
      var U = c && d === void 0;
      if (d !== void 0 && clearTimeout(d), d = setTimeout(function() {
        if (d = void 0, b = Date.now(), !c) {
          var Z = r.apply(N, O);
          m && m(Z), C.forEach(function(B) {
            return (0, B.resolve)(Z);
          }), C = [];
        }
      }, E()), U) {
        var ae = r.apply(N, O);
        return m && m(ae), M(ae);
      }
      C.push({
        resolve: M,
        reject: I
      });
    });
  };
  return x.cancel = function(O) {
    d !== void 0 && clearTimeout(d), C.forEach(function(N) {
      return (0, N.reject)(O);
    }), C = [];
  }, x;
}
const g3 = /version\/(\d+(\.?_?\d+)+)/i;
let iT;
function tl(r) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof r > "u" && typeof navigator > "u")
    return;
  const i = (r ?? navigator.userAgent).toLowerCase();
  if (iT === void 0 || t) {
    const o = y3.find((u) => {
      let {
        test: d
      } = u;
      return d.test(i);
    });
    iT = o == null ? void 0 : o.describe(i);
  }
  return iT;
}
const y3 = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(r) {
      return {
        name: "Firefox",
        version: W0(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, r),
        os: r.toLowerCase().includes("fxios") ? "iOS" : void 0,
        osVersion: aT(r)
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(r) {
      return {
        name: "Chrome",
        version: W0(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, r),
        os: r.toLowerCase().includes("crios") ? "iOS" : void 0,
        osVersion: aT(r)
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(r) {
      return {
        name: "Safari",
        version: W0(g3, r),
        os: r.includes("mobile/") ? "iOS" : "macOS",
        osVersion: aT(r)
      };
    }
  }
];
function W0(r, t) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const o = t.match(r);
  return o && o.length >= i && o[i] || "";
}
function aT(r) {
  return r.includes("mac os") ? W0(/\(.+?(\d+_\d+(:?_\d+)?)/, r, 1).replace(/_/g, ".") : void 0;
}
var b3 = "2.8.0";
const S3 = b3, C3 = 15;
class gi {
}
gi.setTimeout = function() {
  return setTimeout(...arguments);
};
gi.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
function() {
  return setInterval(...arguments);
};
gi.clearTimeout = function() {
  return clearTimeout(...arguments);
};
gi.clearInterval = function() {
  return clearInterval(...arguments);
};
class Cn {
  constructor(t, i, o, u, d) {
    if (typeof t == "object")
      this.width = t.width, this.height = t.height, this.aspectRatio = t.aspectRatio, this.encoding = {
        maxBitrate: t.maxBitrate,
        maxFramerate: t.maxFramerate,
        priority: t.priority
      };
    else if (i !== void 0 && o !== void 0)
      this.width = t, this.height = i, this.aspectRatio = t / i, this.encoding = {
        maxBitrate: o,
        maxFramerate: u,
        priority: d
      };
    else
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio
    };
  }
}
const k3 = ["vp8", "h264"], FD = ["vp8", "h264", "vp9", "av1"];
function T3(r) {
  return !!k3.find((t) => t === r);
}
var VT;
(function(r) {
  r.telephone = {
    maxBitrate: 12e3
  }, r.speech = {
    maxBitrate: 24e3
  }, r.music = {
    maxBitrate: 48e3
  }, r.musicStereo = {
    maxBitrate: 64e3
  }, r.musicHighQuality = {
    maxBitrate: 96e3
  }, r.musicHighQualityStereo = {
    maxBitrate: 128e3
  };
})(VT || (VT = {}));
const as = {
  h90: new Cn(160, 90, 9e4, 20),
  h180: new Cn(320, 180, 16e4, 20),
  h216: new Cn(384, 216, 18e4, 20),
  h360: new Cn(640, 360, 45e4, 20),
  h540: new Cn(960, 540, 8e5, 25),
  h720: new Cn(1280, 720, 17e5, 30),
  h1080: new Cn(1920, 1080, 3e6, 30),
  h1440: new Cn(2560, 1440, 5e6, 30),
  h2160: new Cn(3840, 2160, 8e6, 30)
}, BT = {
  h120: new Cn(160, 120, 7e4, 20),
  h180: new Cn(240, 180, 125e3, 20),
  h240: new Cn(320, 240, 14e4, 20),
  h360: new Cn(480, 360, 33e4, 20),
  h480: new Cn(640, 480, 5e5, 20),
  h540: new Cn(720, 540, 6e5, 25),
  h720: new Cn(960, 720, 13e5, 30),
  h1080: new Cn(1440, 1080, 23e5, 30),
  h1440: new Cn(1920, 1440, 38e5, 30)
}, EE = {
  h360fps3: new Cn(640, 360, 2e5, 3, "medium"),
  h360fps15: new Cn(640, 360, 4e5, 15, "medium"),
  h720fps5: new Cn(1280, 720, 8e5, 5, "medium"),
  h720fps15: new Cn(1280, 720, 15e5, 15, "medium"),
  h720fps30: new Cn(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new Cn(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new Cn(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new Cn(0, 0, 7e6, 30, "medium")
};
function E3(r) {
  if (!(typeof r > "u"))
    return typeof structuredClone == "function" ? structuredClone(r) : JSON.parse(JSON.stringify(r));
}
const w3 = 5e3, fv = [];
var To;
(function(r) {
  r[r.LOW = 0] = "LOW", r[r.MEDIUM = 1] = "MEDIUM", r[r.HIGH = 2] = "HIGH";
})(To || (To = {}));
class ue extends rl.EventEmitter {
  constructor(t, i) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var u;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = ue.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = Wt, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), w3) : this.handleAppVisibilityChanged();
    }, this.log = Yl((u = o.loggerName) !== null && u !== void 0 ? u : cs.Track), this.loggerContextCb = o.loggerContextCb, this.setMaxListeners(100), this.kind = i, this._mediaStreamTrack = t, this._mediaStreamID = t.id, this.source = ue.Source.Unknown;
  }
  get logContext() {
    var t;
    return Object.assign(Object.assign({}, (t = this.loggerContextCb) === null || t === void 0 ? void 0 : t.call(this)), _n(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(t) {
    let i = "audio";
    this.kind === ue.Kind.Video && (i = "video"), this.attachedElements.length === 0 && this.kind === ue.Kind.Video && this.addAppVisibilityListener(), t || (i === "audio" && (fv.forEach((d) => {
      d.parentElement === null && !t && (t = d);
    }), t && fv.splice(fv.indexOf(t), 1)), t || (t = document.createElement(i))), this.attachedElements.includes(t) || this.attachedElements.push(t), Fp(this.mediaStreamTrack, t);
    const o = t.srcObject.getTracks(), u = o.some((d) => d.kind === "audio");
    return t.play().then(() => {
      this.emit(u ? Le.AudioPlaybackStarted : Le.VideoPlaybackStarted);
    }).catch((d) => {
      d.name === "NotAllowedError" ? this.emit(u ? Le.AudioPlaybackFailed : Le.VideoPlaybackFailed, d) : d.name === "AbortError" ? Wt.debug("".concat(u ? "audio" : "video", " playback aborted, likely due to new play request")) : Wt.warn("could not playback ".concat(u ? "audio" : "video"), d), u && t && o.some((c) => c.kind === "video") && d.name === "NotAllowedError" && (t.muted = !0, t.play().catch(() => {
      }));
    }), this.emit(Le.ElementAttached, t), t;
  }
  detach(t) {
    try {
      if (t) {
        Vp(this.mediaStreamTrack, t);
        const o = this.attachedElements.indexOf(t);
        return o >= 0 && (this.attachedElements.splice(o, 1), this.recycleElement(t), this.emit(Le.ElementDetached, t)), t;
      }
      const i = [];
      return this.attachedElements.forEach((o) => {
        Vp(this.mediaStreamTrack, o), i.push(o), this.recycleElement(o), this.emit(Le.ElementDetached, o);
      }), this.attachedElements = [], i;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval), this.timeSyncHandle && cancelAnimationFrame(this.timeSyncHandle);
  }
  /** @internal */
  updateLoggerOptions(t) {
    t.loggerName && (this.log = Yl(t.loggerName)), t.loggerContextCb && (this.loggerContextCb = t.loggerContextCb);
  }
  recycleElement(t) {
    if (t instanceof HTMLAudioElement) {
      let i = !0;
      t.pause(), fv.forEach((o) => {
        o.parentElement || (i = !1);
      }), i && fv.push(t);
    }
  }
  handleAppVisibilityChanged() {
    return G(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden", !this.isInBackground && this.kind === ue.Kind.Video && setTimeout(() => this.attachedElements.forEach((t) => t.play().catch(() => {
      })), 0);
    });
  }
  addAppVisibilityListener() {
    Ia() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    Ia() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function Fp(r, t) {
  let i;
  t.srcObject instanceof MediaStream ? i = t.srcObject : i = new MediaStream();
  let o;
  r.kind === "audio" ? o = i.getAudioTracks() : o = i.getVideoTracks(), o.includes(r) || (o.forEach((u) => {
    i.removeTrack(u);
  }), i.addTrack(r)), (!Cc() || !(t instanceof HTMLVideoElement)) && (t.autoplay = !0), t.muted = i.getAudioTracks().length === 0, t instanceof HTMLVideoElement && (t.playsInline = !0), t.srcObject !== i && (t.srcObject = i, (Cc() || Kp()) && t instanceof HTMLVideoElement && setTimeout(() => {
    t.srcObject = i, t.play().catch(() => {
    });
  }, 0));
}
function Vp(r, t) {
  if (t.srcObject instanceof MediaStream) {
    const i = t.srcObject;
    i.removeTrack(r), i.getTracks().length > 0 ? t.srcObject = i : t.srcObject = null;
  }
}
(function(r) {
  let t;
  (function(b) {
    b.Audio = "audio", b.Video = "video", b.Unknown = "unknown";
  })(t = r.Kind || (r.Kind = {}));
  let i;
  (function(b) {
    b.Camera = "camera", b.Microphone = "microphone", b.ScreenShare = "screen_share", b.ScreenShareAudio = "screen_share_audio", b.Unknown = "unknown";
  })(i = r.Source || (r.Source = {}));
  let o;
  (function(b) {
    b.Active = "active", b.Paused = "paused", b.Unknown = "unknown";
  })(o = r.StreamState || (r.StreamState = {}));
  function u(b) {
    switch (b) {
      case t.Audio:
        return os.AUDIO;
      case t.Video:
        return os.VIDEO;
      default:
        return os.DATA;
    }
  }
  r.kindToProto = u;
  function d(b) {
    switch (b) {
      case os.AUDIO:
        return t.Audio;
      case os.VIDEO:
        return t.Video;
      default:
        return t.Unknown;
    }
  }
  r.kindFromProto = d;
  function c(b) {
    switch (b) {
      case i.Camera:
        return Hi.CAMERA;
      case i.Microphone:
        return Hi.MICROPHONE;
      case i.ScreenShare:
        return Hi.SCREEN_SHARE;
      case i.ScreenShareAudio:
        return Hi.SCREEN_SHARE_AUDIO;
      default:
        return Hi.UNKNOWN;
    }
  }
  r.sourceToProto = c;
  function m(b) {
    switch (b) {
      case Hi.CAMERA:
        return i.Camera;
      case Hi.MICROPHONE:
        return i.Microphone;
      case Hi.SCREEN_SHARE:
        return i.ScreenShare;
      case Hi.SCREEN_SHARE_AUDIO:
        return i.ScreenShareAudio;
      default:
        return i.Unknown;
    }
  }
  r.sourceFromProto = m;
  function g(b) {
    switch (b) {
      case PT.ACTIVE:
        return o.Active;
      case PT.PAUSED:
        return o.Paused;
      default:
        return o.Unknown;
    }
  }
  r.streamStateFromProto = g;
})(ue);
function jD(r, t, i) {
  var o, u, d, c, m;
  const {
    optionsWithoutProcessor: g,
    audioProcessor: b,
    videoProcessor: C
  } = wE(r ?? {}), E = (o = E3(g)) !== null && o !== void 0 ? o : {};
  return E.audio === !0 && (E.audio = {}), E.video === !0 && (E.video = {}), E.audio && (HT(E.audio, t), (u = (c = E.audio).deviceId) !== null && u !== void 0 || (c.deviceId = "default"), b && (E.audio.processor = b)), E.video && (HT(E.video, i), (d = (m = E.video).deviceId) !== null && d !== void 0 || (m.deviceId = "default"), C && (E.video.processor = C)), E;
}
function HT(r, t) {
  return Object.keys(t).forEach((i) => {
    r[i] === void 0 && (r[i] = t[i]);
  }), r;
}
function vb(r) {
  var t, i, o, u;
  const d = {};
  if (r.video)
    if (typeof r.video == "object") {
      const c = {}, m = c, g = r.video;
      Object.keys(g).forEach((b) => {
        switch (b) {
          case "resolution":
            HT(m, g.resolution);
            break;
          default:
            m[b] = g[b];
        }
      }), d.video = c, (t = (o = d.video).deviceId) !== null && t !== void 0 || (o.deviceId = "default");
    } else
      d.video = r.video ? {
        deviceId: "default"
      } : !1;
  else
    d.video = !1;
  return r.audio ? typeof r.audio == "object" ? (d.audio = r.audio, (i = (u = d.audio).deviceId) !== null && i !== void 0 || (u.deviceId = "default")) : d.audio = {
    deviceId: "default"
  } : d.audio = !1, d;
}
function R3(r) {
  return G(this, arguments, void 0, function(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
    return function* () {
      const o = zD();
      if (o) {
        const u = o.createAnalyser();
        u.fftSize = 2048;
        const d = u.frequencyBinCount, c = new Uint8Array(d);
        o.createMediaStreamSource(new MediaStream([t.mediaStreamTrack])).connect(u), yield us(i), u.getByteTimeDomainData(c);
        const g = c.some((b) => b !== 128 && b !== 0);
        return o.close(), !g;
      }
      return !1;
    }();
  });
}
function zD() {
  const r = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (r)
    return new r({
      latencyHint: "interactive"
    });
}
function px(r) {
  return r === ue.Source.Microphone ? "audioinput" : r === ue.Source.Camera ? "videoinput" : void 0;
}
function _3(r) {
  var t, i;
  let o = (t = r.video) !== null && t !== void 0 ? t : !0;
  return r.resolution && r.resolution.width > 0 && r.resolution.height > 0 && (o = typeof o == "boolean" ? {} : o, Cc() ? o = Object.assign(Object.assign({}, o), {
    width: {
      max: r.resolution.width
    },
    height: {
      max: r.resolution.height
    },
    frameRate: r.resolution.frameRate
  }) : o = Object.assign(Object.assign({}, o), {
    width: {
      ideal: r.resolution.width
    },
    height: {
      ideal: r.resolution.height
    },
    frameRate: r.resolution.frameRate
  })), {
    audio: (i = r.audio) !== null && i !== void 0 ? i : !1,
    video: o,
    // @ts-expect-error support for experimental display media features
    controller: r.controller,
    selfBrowserSurface: r.selfBrowserSurface,
    surfaceSwitching: r.surfaceSwitching,
    systemAudio: r.systemAudio,
    preferCurrentTab: r.preferCurrentTab
  };
}
function G0(r) {
  return r.split("/")[1].toLowerCase();
}
function x3(r) {
  const t = [];
  return r.forEach((i) => {
    i.track !== void 0 && t.push(new SE({
      cid: i.track.mediaStreamID,
      track: i.trackInfo
    }));
  }), t;
}
function _n(r) {
  return r instanceof ue ? {
    trackID: r.sid,
    source: r.source,
    muted: r.isMuted,
    enabled: r.mediaStreamTrack.enabled,
    kind: r.kind,
    streamID: r.mediaStreamID,
    streamTrackID: r.mediaStreamTrack.id
  } : {
    trackID: r.trackSid,
    enabled: r.isEnabled,
    muted: r.isMuted,
    trackInfo: Object.assign({
      mimeType: r.mimeType,
      name: r.trackName,
      encrypted: r.isEncrypted,
      kind: r.kind,
      source: r.source
    }, r.track ? _n(r.track) : {})
  };
}
function P3() {
  return typeof RTCRtpReceiver < "u" && "getSynchronizationSources" in RTCRtpReceiver;
}
function D3(r, t) {
  var i;
  r === void 0 && (r = {}), t === void 0 && (t = {});
  const o = [...Object.keys(t), ...Object.keys(r)], u = {};
  for (const d of o)
    r[d] !== t[d] && (u[d] = (i = t[d]) !== null && i !== void 0 ? i : "");
  return u;
}
function wE(r) {
  const t = Object.assign({}, r);
  let i, o;
  return typeof t.audio == "object" && t.audio.processor && (i = t.audio.processor, t.audio = Object.assign(Object.assign({}, t.audio), {
    processor: void 0
  })), typeof t.video == "object" && t.video.processor && (o = t.video.processor, t.video = Object.assign(Object.assign({}, t.video), {
    processor: void 0
  })), {
    audioProcessor: i,
    videoProcessor: o,
    optionsWithoutProcessor: t
  };
}
const O3 = "|", hx = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function M3(r) {
  const t = r.split(O3);
  return t.length > 1 ? [t[0], r.substr(t[0].length + 1)] : [r, ""];
}
function us(r) {
  return G(this, void 0, void 0, function* () {
    return new Promise((t) => gi.setTimeout(t, r));
  });
}
function $T() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function qT() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function N3() {
  if (!("getCapabilities" in RTCRtpSender) || Cc())
    return !1;
  const r = RTCRtpSender.getCapabilities("video");
  let t = !1;
  if (r) {
    for (const i of r.codecs)
      if (i.mimeType === "video/AV1") {
        t = !0;
        break;
      }
  }
  return t;
}
function L3() {
  if (!("getCapabilities" in RTCRtpSender) || Kp())
    return !1;
  if (Cc()) {
    const i = tl();
    if (i != null && i.version && Ud(i.version, "16") < 0)
      return !1;
  }
  const r = RTCRtpSender.getCapabilities("video");
  let t = !1;
  if (r) {
    for (const i of r.codecs)
      if (i.mimeType === "video/VP9") {
        t = !0;
        break;
      }
  }
  return t;
}
function Cv(r) {
  return r === "av1" || r === "vp9";
}
function WT(r) {
  return document ? (r || (r = document.createElement("audio")), "setSinkId" in r) : !1;
}
function A3() {
  return typeof RTCPeerConnection > "u" ? !1 : $T() || qT();
}
function Kp() {
  var r;
  return ((r = tl()) === null || r === void 0 ? void 0 : r.name) === "Firefox";
}
function Cc() {
  var r;
  return ((r = tl()) === null || r === void 0 ? void 0 : r.name) === "Safari";
}
function I3() {
  const r = tl();
  return (r == null ? void 0 : r.name) === "Safari" && r.version.startsWith("17.");
}
function VD() {
  var r, t;
  return Ia() ? (
    // @ts-expect-error `userAgentData` is not yet part of typescript
    (t = (r = navigator.userAgentData) === null || r === void 0 ? void 0 : r.mobile) !== null && t !== void 0 ? t : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
  ) : !1;
}
function U3() {
  const r = tl(), t = "17.2";
  if (r)
    return r.name !== "Safari" && r.os !== "iOS" || r.os === "iOS" && r.osVersion && Ud(t, r.osVersion) >= 0 ? !0 : r.name === "Safari" && Ud(t, r.version) >= 0;
}
function Ia() {
  return typeof document < "u";
}
function Kl() {
  return navigator.product == "ReactNative";
}
function GT(r) {
  return r.hostname.endsWith(".livekit.cloud") || r.hostname.endsWith(".livekit.run");
}
function BD() {
  if (global && global.LiveKitReactNativeGlobal)
    return global.LiveKitReactNativeGlobal;
}
function HD() {
  if (!Kl())
    return;
  let r = BD();
  if (r)
    return r.platform;
}
function mx() {
  if (Ia())
    return window.devicePixelRatio;
  if (Kl()) {
    let r = BD();
    if (r)
      return r.devicePixelRatio;
  }
  return 1;
}
function Ud(r, t) {
  const i = r.split("."), o = t.split("."), u = Math.min(i.length, o.length);
  for (let d = 0; d < u; ++d) {
    const c = parseInt(i[d], 10), m = parseInt(o[d], 10);
    if (c > m)
      return 1;
    if (c < m)
      return -1;
    if (d === u - 1 && c === m)
      return 0;
  }
  return r === "" && t !== "" ? -1 : t === "" ? 1 : i.length == o.length ? 0 : i.length < o.length ? -1 : 1;
}
function F3(r) {
  for (const t of r)
    t.target.handleResize(t);
}
function j3(r) {
  for (const t of r)
    t.target.handleVisibilityChanged(t);
}
let oT = null;
const vx = () => (oT || (oT = new ResizeObserver(F3)), oT);
let sT = null;
const gx = () => (sT || (sT = new IntersectionObserver(j3, {
  root: null,
  rootMargin: "0px"
})), sT);
function z3() {
  var r;
  const t = new gU({
    sdk: WP.JS,
    protocol: C3,
    version: S3
  });
  return Kl() && (t.os = (r = HD()) !== null && r !== void 0 ? r : ""), t;
}
function yx() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const u = document.createElement("canvas");
  u.width = r, u.height = t;
  const d = u.getContext("2d");
  d == null || d.fillRect(0, 0, u.width, u.height), o && d && (d.beginPath(), d.arc(r / 2, t / 2, 50, 0, Math.PI * 2, !0), d.closePath(), d.fillStyle = "grey", d.fill());
  const c = u.captureStream(), [m] = c.getTracks();
  if (!m)
    throw Error("Could not get empty media stream video track");
  return m.enabled = i, m;
}
let pv;
function lT() {
  if (!pv) {
    const r = new AudioContext(), t = r.createOscillator(), i = r.createGain();
    i.gain.setValueAtTime(0, 0);
    const o = r.createMediaStreamDestination();
    if (t.connect(i), i.connect(o), t.start(), [pv] = o.stream.getAudioTracks(), !pv)
      throw Error("Could not get empty media stream audio track");
    pv.enabled = !1;
  }
  return pv.clone();
}
class $D {
  constructor(t, i) {
    this.onFinally = i, this.promise = new Promise((o, u) => G(this, void 0, void 0, function* () {
      this.resolve = o, this.reject = u, t && (yield t(o, u));
    })).finally(() => {
      var o;
      return (o = this.onFinally) === null || o === void 0 ? void 0 : o.call(this);
    });
  }
}
function V3(r) {
  return FD.includes(r);
}
function Nd(r) {
  if (typeof r == "string" || typeof r == "number")
    return r;
  if (Array.isArray(r))
    return r[0];
  if (r.exact)
    return Array.isArray(r.exact) ? r.exact[0] : r.exact;
  if (r.ideal)
    return Array.isArray(r.ideal) ? r.ideal[0] : r.ideal;
  throw Error("could not unwrap constraint");
}
function B3(r) {
  return r.startsWith("http") ? r.replace(/^(http)/, "ws") : r;
}
function bx(r) {
  return r.startsWith("ws") ? r.replace(/^(ws)/, "http") : r;
}
function H3(r, t) {
  return r.segments.map((i) => {
    let {
      id: o,
      text: u,
      language: d,
      startTime: c,
      endTime: m,
      final: g
    } = i;
    var b;
    const C = (b = t.get(o)) !== null && b !== void 0 ? b : Date.now(), E = Date.now();
    return g ? t.delete(o) : t.set(o, C), {
      id: o,
      text: u,
      startTime: Number.parseInt(c.toString()),
      endTime: Number.parseInt(m.toString()),
      final: g,
      language: d,
      firstReceivedTime: C,
      lastReceivedTime: E
    };
  });
}
function $3(r) {
  const {
    id: t,
    timestamp: i,
    message: o,
    editTimestamp: u
  } = r;
  return {
    id: t,
    timestamp: Number.parseInt(i.toString()),
    editTimestamp: u ? Number.parseInt(u.toString()) : void 0,
    message: o
  };
}
function Sx(r) {
  switch (r.reason) {
    case nn.LeaveRequest:
      return r.context;
    case nn.Cancelled:
      return ls.CLIENT_INITIATED;
    case nn.NotAllowed:
      return ls.USER_REJECTED;
    case nn.ServerUnreachable:
      return ls.JOIN_FAILURE;
    default:
      return ls.UNKNOWN_REASON;
  }
}
const uT = "default";
class Jr {
  constructor() {
    this._previousDevices = [];
  }
  static getInstance() {
    return this.instance === void 0 && (this.instance = new Jr()), this.instance;
  }
  get previousDevices() {
    return this._previousDevices;
  }
  getDevices(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return function* () {
        var d;
        if (((d = Jr.userMediaPromiseMap) === null || d === void 0 ? void 0 : d.size) > 0) {
          Wt.debug("awaiting getUserMedia promise");
          try {
            i ? yield Jr.userMediaPromiseMap.get(i) : yield Promise.all(Jr.userMediaPromiseMap.values());
          } catch {
            Wt.warn("error waiting for media permissons");
          }
        }
        let c = yield navigator.mediaDevices.enumerateDevices();
        if (u && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
        !(Cc() && o.hasDeviceInUse(i)) && (c.filter((g) => g.kind === i).length === 0 || c.some((g) => {
          const b = g.label === "", C = i ? g.kind === i : !0;
          return b && C;
        }))) {
          const g = {
            video: i !== "audioinput" && i !== "audiooutput",
            audio: i !== "videoinput" && {
              deviceId: "default"
            }
          }, b = yield navigator.mediaDevices.getUserMedia(g);
          c = yield navigator.mediaDevices.enumerateDevices(), b.getTracks().forEach((C) => {
            C.stop();
          });
        }
        return o._previousDevices = c, i && (c = c.filter((m) => m.kind === i)), c;
      }();
    });
  }
  normalizeDeviceId(t, i, o) {
    return G(this, void 0, void 0, function* () {
      if (i !== uT)
        return i;
      const u = yield this.getDevices(t), d = u.find((m) => m.deviceId === uT);
      if (!d) {
        Wt.warn("could not reliably determine default device");
        return;
      }
      const c = u.find((m) => m.deviceId !== uT && m.groupId === (o ?? d.groupId));
      if (!c) {
        Wt.warn("could not reliably determine default device");
        return;
      }
      return c == null ? void 0 : c.deviceId;
    });
  }
  hasDeviceInUse(t) {
    return t ? Jr.userMediaPromiseMap.has(t) : Jr.userMediaPromiseMap.size > 0;
  }
}
Jr.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
Jr.userMediaPromiseMap = /* @__PURE__ */ new Map();
const q3 = 1e3;
class Ld extends ue {
  /** @internal */
  get sender() {
    return this._sender;
  }
  /** @internal */
  set sender(t) {
    this._sender = t;
  }
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(t, i, o) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, d = arguments.length > 4 ? arguments[4] : void 0;
    super(t, i, d), this.manuallyStopped = !1, this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = TE(() => G(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => G(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(Le.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = u, this.muteLock = new Aa(), this.pauseUpstreamLock = new Aa(), this.processorLock = new Aa(), this.restartLock = new Aa(), this.setMediaStreamTrack(t, !0), this._constraints = t.getConstraints(), o && (this._constraints = o);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== ue.Kind.Video)
      return;
    const {
      width: t,
      height: i
    } = this._mediaStreamTrack.getSettings();
    if (t && i)
      return {
        width: t,
        height: i
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var t, i;
    return (i = (t = this.processor) === null || t === void 0 ? void 0 : t.processedTrack) !== null && i !== void 0 ? i : this._mediaStreamTrack;
  }
  /**
   * @internal
   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
   */
  getSourceTrackSettings() {
    return this._mediaStreamTrack.getSettings();
  }
  setMediaStreamTrack(t, i) {
    return G(this, void 0, void 0, function* () {
      if (t === this._mediaStreamTrack && !i)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((u) => {
        Vp(this._mediaStreamTrack, u);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([t]), t && (t.addEventListener("ended", this.handleEnded), t.addEventListener("mute", this.handleTrackMuteEvent), t.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = t.getConstraints());
      let o;
      if (this.processor && t) {
        const u = yield this.processorLock.lock();
        try {
          if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
            throw TypeError("cannot set processor on track of unknown kind");
          this.processorElement && (Fp(t, this.processorElement), this.processorElement.muted = !0), yield this.processor.restart({
            track: t,
            kind: this.kind,
            element: this.processorElement
          }), o = this.processor.processedTrack;
        } finally {
          u();
        }
      }
      this.sender && (yield this.sender.replaceTrack(o ?? t)), !this.providedByUser && this._mediaStreamTrack !== t && this._mediaStreamTrack.stop(), this._mediaStreamTrack = t, t && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((u) => {
        Fp(o ?? t, u);
      }));
    });
  }
  waitForDimensions() {
    return G(this, arguments, void 0, function() {
      var t = this;
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q3;
      return function* () {
        var o;
        if (t.kind === ue.Kind.Audio)
          throw new Error("cannot get dimensions for audio tracks");
        ((o = tl()) === null || o === void 0 ? void 0 : o.os) === "iOS" && (yield us(10));
        const u = Date.now();
        for (; Date.now() - u < i; ) {
          const d = t.dimensions;
          if (d)
            return d;
          yield us(50);
        }
        throw new Gl("unable to get track dimensions after timeout");
      }();
    });
  }
  setDeviceId(t) {
    return G(this, void 0, void 0, function* () {
      return this._constraints.deviceId === t && this._mediaStreamTrack.getSettings().deviceId === Nd(t) || (this._constraints.deviceId = t, this.isMuted) ? !0 : (yield this.restartTrack(), Nd(t) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return G(this, arguments, void 0, function() {
      var t = this;
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return function* () {
        if (t.source === ue.Source.ScreenShare)
          return;
        const {
          deviceId: o,
          groupId: u
        } = t._mediaStreamTrack.getSettings(), d = t.kind === ue.Kind.Audio ? "audioinput" : "videoinput";
        return i ? Jr.getInstance().normalizeDeviceId(d, o, u) : o;
      }();
    });
  }
  mute() {
    return G(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return G(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(t, i) {
    return G(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new Gl("unable to replace an unpublished track");
      let o, u;
      return typeof i == "boolean" ? o = i : i !== void 0 && (o = i.userProvidedTrack, u = i.stopProcessor), this.providedByUser = o ?? !0, this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(t), u && this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(t) {
    return G(this, void 0, void 0, function* () {
      this.manuallyStopped = !1;
      const i = yield this.restartLock.lock();
      try {
        t || (t = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
          constraints: t
        }));
        const o = {
          audio: !1,
          video: !1
        };
        this.kind === ue.Kind.Video ? o.video = t : o.audio = t, this.attachedElements.forEach((c) => {
          Vp(this.mediaStreamTrack, c);
        }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
        const d = (yield navigator.mediaDevices.getUserMedia(o)).getTracks()[0];
        return d.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(d), this._constraints = t, this.emit(Le.Restarted, this), this.manuallyStopped && (this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext), this.stop()), this;
      } finally {
        i();
      }
    });
  }
  setTrackMuted(t) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(t ? "muted" : "unmuted"), this.logContext), !(this.isMuted === t && this._mediaStreamTrack.enabled !== t) && (this.isMuted = t, this._mediaStreamTrack.enabled = !t, this.emit(t ? Le.Muted : Le.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const t = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return G(this, void 0, void 0, function* () {
      yield t.handleAppVisibilityChanged.call(this), VD() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var t;
    this.manuallyStopped = !0, super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (t = this.processor) === null || t === void 0 || t.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return G(this, void 0, void 0, function* () {
      const t = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(Le.UpstreamPaused, this);
        const i = tl();
        if ((i == null ? void 0 : i.name) === "Safari" && Ud(i.version, "12.0") < 0)
          throw new mb("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        t();
      }
    });
  }
  resumeUpstream() {
    return G(this, void 0, void 0, function* () {
      const t = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(Le.UpstreamResumed, this), yield this.sender.replaceTrack(this.mediaStreamTrack);
      } finally {
        t();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    return G(this, void 0, void 0, function* () {
      var t;
      return !((t = this.sender) === null || t === void 0) && t.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return function* () {
        var d;
        const c = yield o.processorLock.lock();
        try {
          o.log.debug("setting up processor", o.logContext);
          const m = document.createElement(o.kind), g = {
            kind: o.kind,
            track: o._mediaStreamTrack,
            element: m,
            audioContext: o.audioContext
          };
          if (yield i.init(g), o.log.debug("processor initialized", o.logContext), o.processor && (yield o.stopProcessor()), o.kind === "unknown")
            throw TypeError("cannot set processor on track of unknown kind");
          if (Fp(o._mediaStreamTrack, m), m.muted = !0, m.play().catch((b) => o.log.error("failed to play processor element", Object.assign(Object.assign({}, o.logContext), {
            error: b
          }))), o.processor = i, o.processorElement = m, o.processor.processedTrack) {
            for (const b of o.attachedElements)
              b !== o.processorElement && u && (Vp(o._mediaStreamTrack, b), Fp(o.processor.processedTrack, b));
            yield (d = o.sender) === null || d === void 0 ? void 0 : d.replaceTrack(o.processor.processedTrack);
          }
          o.emit(Le.TrackProcessorUpdate, o.processor);
        } finally {
          c();
        }
      }();
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    return G(this, arguments, void 0, function() {
      var t = this;
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return function* () {
        var o, u;
        t.processor && (t.log.debug("stopping processor", t.logContext), (o = t.processor.processedTrack) === null || o === void 0 || o.stop(), yield t.processor.destroy(), t.processor = void 0, i || ((u = t.processorElement) === null || u === void 0 || u.remove(), t.processorElement = void 0), yield t._mediaStreamTrack.applyConstraints(t._constraints), yield t.setMediaStreamTrack(t._mediaStreamTrack, !0), t.emit(Le.TrackProcessorUpdate));
      }();
    });
  }
}
class W3 extends rl.EventEmitter {
  constructor(t) {
    super(), this.onWorkerMessage = (i) => {
      var o, u;
      const {
        kind: d,
        data: c
      } = i.data;
      switch (d) {
        case "error":
          Wt.error(c.error.message), this.emit(vc.EncryptionError, c.error);
          break;
        case "initAck":
          c.enabled && this.keyProvider.getKeys().forEach((m) => {
            this.postKey(m);
          });
          break;
        case "enable":
          if (c.enabled && this.keyProvider.getKeys().forEach((m) => {
            this.postKey(m);
          }), this.encryptionEnabled !== c.enabled && c.participantIdentity === ((o = this.room) === null || o === void 0 ? void 0 : o.localParticipant.identity))
            this.emit(vc.ParticipantEncryptionStatusChanged, c.enabled, this.room.localParticipant), this.encryptionEnabled = c.enabled;
          else if (c.participantIdentity) {
            const m = (u = this.room) === null || u === void 0 ? void 0 : u.getParticipantByIdentity(c.participantIdentity);
            if (!m)
              throw TypeError("couldn't set encryption status, participant not found".concat(c.participantIdentity));
            this.emit(vc.ParticipantEncryptionStatusChanged, c.enabled, m);
          }
          break;
        case "ratchetKey":
          this.keyProvider.emit(yc.KeyRatcheted, c.material, c.keyIndex);
          break;
      }
    }, this.onWorkerError = (i) => {
      Wt.error("e2ee worker encountered an error:", {
        error: i.error
      }), this.emit(vc.EncryptionError, i.error);
    }, this.keyProvider = t.keyProvider, this.worker = t.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(t) {
    if (!c3())
      throw new mb("tried to setup end-to-end encryption on an unsupported browser");
    if (Wt.info("setting up e2ee"), t !== this.room) {
      this.room = t, this.setupEventListeners(t, this.keyProvider);
      const i = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: KU.getLevel()
        }
      };
      this.worker && (Wt.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(i));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(t, i) {
    Wt.debug("set e2ee to ".concat(t, " for participant ").concat(i)), this.postEnable(t, i);
  }
  /**
   * @internal
   */
  setSifTrailer(t) {
    !t || t.length === 0 ? Wt.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(t);
  }
  setupEngine(t) {
    t.on(qe.RTPVideoMapUpdate, (i) => {
      this.postRTPMap(i);
    });
  }
  setupEventListeners(t, i) {
    t.on(ne.TrackPublished, (o, u) => this.setParticipantCryptorEnabled(o.trackInfo.encryption !== Ja.NONE, u.identity)), t.on(ne.ConnectionStateChanged, (o) => {
      o === Yt.Connected && t.remoteParticipants.forEach((u) => {
        u.trackPublications.forEach((d) => {
          this.setParticipantCryptorEnabled(d.trackInfo.encryption !== Ja.NONE, u.identity);
        });
      });
    }).on(ne.TrackUnsubscribed, (o, u, d) => {
      var c;
      const m = {
        kind: "removeTransform",
        data: {
          participantIdentity: d.identity,
          trackId: o.mediaStreamID
        }
      };
      (c = this.worker) === null || c === void 0 || c.postMessage(m);
    }).on(ne.TrackSubscribed, (o, u, d) => {
      this.setupE2EEReceiver(o, d.identity, u.trackInfo);
    }).on(ne.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      i.getKeys().forEach((o) => {
        this.postKey(o);
      }), this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
    }), t.localParticipant.on(ce.LocalTrackPublished, (o) => G(this, void 0, void 0, function* () {
      this.setupE2EESender(o.track, o.track.sender);
    })), i.on(yc.SetKey, (o) => this.postKey(o)).on(yc.RatchetRequest, (o, u) => this.postRatchetRequest(o, u));
  }
  postRatchetRequest(t, i) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const o = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: t,
        keyIndex: i
      }
    };
    this.worker.postMessage(o);
  }
  postKey(t) {
    let {
      key: i,
      participantIdentity: o,
      keyIndex: u
    } = t;
    var d;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const c = {
      kind: "setKey",
      data: {
        participantIdentity: o,
        isPublisher: o === ((d = this.room) === null || d === void 0 ? void 0 : d.localParticipant.identity),
        key: i,
        keyIndex: u
      }
    };
    this.worker.postMessage(c);
  }
  postEnable(t, i) {
    if (this.worker) {
      const o = {
        kind: "enable",
        data: {
          enabled: t,
          participantIdentity: i
        }
      };
      this.worker.postMessage(o);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(t) {
    var i;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((i = this.room) === null || i === void 0) && i.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const o = {
      kind: "setRTPMap",
      data: {
        map: t,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(o);
  }
  postSifTrailer(t) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const i = {
      kind: "setSifTrailer",
      data: {
        trailer: t
      }
    };
    this.worker.postMessage(i);
  }
  setupE2EEReceiver(t, i, o) {
    if (t.receiver) {
      if (!(o != null && o.mimeType) || o.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(t.receiver, t.mediaStreamID, i, t.kind === "video" ? G0(o.mimeType) : void 0);
    }
  }
  setupE2EESender(t, i) {
    if (!(t instanceof Ld) || !i) {
      i || Wt.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(i, t.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      if (this.worker) {
        if (jT()) {
          const d = {
            kind: "decode",
            participantIdentity: o,
            trackId: i,
            codec: u
          };
          t.transform = new RTCRtpScriptTransform(this.worker, d);
        } else {
          if (D0 in t && u) {
            const g = {
              kind: "updateCodec",
              data: {
                trackId: i,
                codec: u,
                participantIdentity: o
              }
            };
            this.worker.postMessage(g);
            return;
          }
          let d = t.writableStream, c = t.readableStream;
          if (!d || !c) {
            const g = t.createEncodedStreams();
            t.writableStream = g.writable, d = g.writable, t.readableStream = g.readable, c = g.readable;
          }
          const m = {
            kind: "decode",
            data: {
              readableStream: c,
              writableStream: d,
              trackId: i,
              codec: u,
              participantIdentity: o
            }
          };
          this.worker.postMessage(m, [c, d]);
        }
        t[D0] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(t, i, o) {
    var u;
    if (!(D0 in t || !this.worker)) {
      if (!(!((u = this.room) === null || u === void 0) && u.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (jT()) {
        Wt.info("initialize script transform");
        const d = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: i,
          codec: o
        };
        t.transform = new RTCRtpScriptTransform(this.worker, d);
      } else {
        Wt.info("initialize encoded streams");
        const d = t.createEncodedStreams(), c = {
          kind: "encode",
          data: {
            readableStream: d.readable,
            writableStream: d.writable,
            codec: o,
            trackId: i,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(c, [d.readable, d.writable]);
      }
      t[D0] = !0;
    }
  }
}
var kv;
(function(r) {
  r[r.WAITING = 0] = "WAITING", r[r.RUNNING = 1] = "RUNNING", r[r.COMPLETED = 2] = "COMPLETED";
})(kv || (kv = {}));
class G3 {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Aa(), this.nextTaskIndex = 0;
  }
  run(t) {
    return G(this, void 0, void 0, function* () {
      const i = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: kv.WAITING
      };
      this.pendingTasks.set(i.id, i);
      const o = yield this.taskMutex.lock();
      try {
        return i.executedAt = Date.now(), i.status = kv.RUNNING, yield t();
      } finally {
        i.status = kv.COMPLETED, this.pendingTasks.delete(i.id), o();
      }
    });
  }
  flush() {
    return G(this, void 0, void 0, function* () {
      return this.run(() => G(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const Y3 = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function K3(r) {
  const t = Y3.indexOf(r.case) >= 0;
  return Wt.trace("request allowed to bypass queue:", {
    canPass: t,
    req: r
  }), t;
}
var Wn;
(function(r) {
  r[r.CONNECTING = 0] = "CONNECTING", r[r.CONNECTED = 1] = "CONNECTED", r[r.RECONNECTING = 2] = "RECONNECTING", r[r.DISCONNECTING = 3] = "DISCONNECTING", r[r.DISCONNECTED = 4] = "DISCONNECTED";
})(Wn || (Wn = {}));
class RE {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === Wn.DISCONNECTING || this.state === Wn.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === Wn.CONNECTING || this.state === Wn.RECONNECTING;
  }
  getNextRequestId() {
    return this._requestId += 1, this._requestId;
  }
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var o;
    this.rtt = 0, this.state = Wn.DISCONNECTED, this.log = Wt, this._requestId = 0, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = Yl((o = i.loggerName) !== null && o !== void 0 ? o : cs.Signal), this.loggerContextCb = i.loggerContextCb, this.useJSON = t, this.requestQueue = new G3(), this.queuedRequests = [], this.closingLock = new Aa(), this.connectionLock = new Aa(), this.state = Wn.DISCONNECTED;
  }
  get logContext() {
    var t, i;
    return (i = (t = this.loggerContextCb) === null || t === void 0 ? void 0 : t.call(this)) !== null && i !== void 0 ? i : {};
  }
  join(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      return this.state = Wn.CONNECTING, this.options = o, yield this.connect(t, i, o, u);
    });
  }
  reconnect(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = Wn.RECONNECTING, this.clearPingInterval(), yield this.connect(t, i, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: o,
        reconnectReason: u
      }));
    });
  }
  connect(t, i, o, u) {
    this.connectOptions = o, t = B3(t), t = t.replace(/\/$/, ""), t += "/rtc";
    const d = z3(), c = Q3(i, d, o);
    return new Promise((m, g) => G(this, void 0, void 0, function* () {
      const b = yield this.connectionLock.lock();
      try {
        const C = () => G(this, void 0, void 0, function* () {
          this.close(), clearTimeout(E), g(new xn("room connection has been cancelled (signal)", nn.Cancelled));
        }), E = setTimeout(() => {
          this.close(), g(new xn("room connection has timed out (signal)", nn.ServerUnreachable));
        }, o.websocketTimeout);
        u != null && u.aborted && C(), u == null || u.addEventListener("abort", C), this.log.debug("connecting to ".concat(t + c), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(t + c), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(E);
        }, this.ws.onerror = (x) => G(this, void 0, void 0, function* () {
          if (this.state !== Wn.CONNECTED) {
            this.state = Wn.DISCONNECTED, clearTimeout(E);
            try {
              const O = yield fetch("http".concat(t.substring(2), "/validate").concat(c));
              if (O.status.toFixed(0).startsWith("4")) {
                const N = yield O.text();
                g(new xn(N, nn.NotAllowed, O.status));
              } else
                g(new xn("Internal error", nn.InternalError, O.status));
            } catch {
              g(new xn("server was not reachable", nn.ServerUnreachable));
            }
            return;
          }
          this.handleWSError(x);
        }), this.ws.onmessage = (x) => G(this, void 0, void 0, function* () {
          var O, N, M;
          let I;
          if (typeof x.data == "string") {
            const U = JSON.parse(x.data);
            I = X_.fromJson(U, {
              ignoreUnknownFields: !0
            });
          } else if (x.data instanceof ArrayBuffer)
            I = X_.fromBinary(new Uint8Array(x.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof x.data), this.logContext);
            return;
          }
          if (this.state !== Wn.CONNECTED) {
            let U = !1;
            if (((O = I.message) === null || O === void 0 ? void 0 : O.case) === "join" ? (this.state = Wn.CONNECTED, u == null || u.removeEventListener("abort", C), this.pingTimeoutDuration = I.message.value.pingTimeout, this.pingIntervalDuration = I.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), m(I.message.value)) : this.state === Wn.RECONNECTING && I.message.case !== "leave" ? (this.state = Wn.CONNECTED, u == null || u.removeEventListener("abort", C), this.startPingInterval(), ((N = I.message) === null || N === void 0 ? void 0 : N.case) === "reconnect" ? m(I.message.value) : (this.log.debug("declaring signal reconnected without reconnect response received", this.logContext), m(void 0), U = !0)) : this.isEstablishingConnection && I.message.case === "leave" ? g(new xn("Received leave request while trying to (re)connect", nn.LeaveRequest, void 0, I.message.value.reason)) : o.reconnect || g(new xn("did not receive join response, got ".concat((M = I.message) === null || M === void 0 ? void 0 : M.case, " instead"), nn.InternalError)), !U)
              return;
          }
          this.signalLatency && (yield us(this.signalLatency)), this.handleSignalResponse(I);
        }), this.ws.onclose = (x) => {
          this.isEstablishingConnection && g(new xn("Websocket got closed during a (re)connection attempt", nn.InternalError)), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: x.reason,
            code: x.code,
            wasClean: x.wasClean,
            state: this.state
          })), this.handleOnClose(x.reason);
        };
      } finally {
        b();
      }
    }));
  }
  close() {
    return G(this, arguments, void 0, function() {
      var t = this;
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return function* () {
        const o = yield t.closingLock.lock();
        try {
          if (t.clearPingInterval(), i && (t.state = Wn.DISCONNECTING), t.ws) {
            t.ws.onmessage = null, t.ws.onopen = null, t.ws.onclose = null;
            const u = new Promise((d) => {
              t.ws ? t.ws.onclose = () => {
                d();
              } : d();
            });
            t.ws.readyState < t.ws.CLOSING && (t.ws.close(), yield Promise.race([u, us(250)])), t.ws = void 0;
          }
        } finally {
          i && (t.state = Wn.DISCONNECTED), o();
        }
      }();
    });
  }
  // initial offer after joining
  sendOffer(t) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: t.sdp
    })), this.sendRequest({
      case: "offer",
      value: eb(t)
    });
  }
  // answer a server-initiated offer
  sendAnswer(t) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: t.sdp
    })), this.sendRequest({
      case: "answer",
      value: eb(t)
    });
  }
  sendIceCandidate(t, i) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: t
    })), this.sendRequest({
      case: "trickle",
      value: new yE({
        candidateInit: JSON.stringify(t),
        target: i
      })
    });
  }
  sendMuteTrack(t, i) {
    return this.sendRequest({
      case: "mute",
      value: new bE({
        sid: t,
        muted: i
      })
    });
  }
  sendAddTrack(t) {
    return this.sendRequest({
      case: "addTrack",
      value: t
    });
  }
  sendUpdateLocalMetadata(t, i) {
    return G(this, arguments, void 0, function(o, u) {
      var d = this;
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return function* () {
        const m = d.getNextRequestId();
        return yield d.sendRequest({
          case: "updateMetadata",
          value: new XP({
            requestId: m,
            metadata: o,
            name: u,
            attributes: c
          })
        }), m;
      }();
    });
  }
  sendUpdateTrackSettings(t) {
    this.sendRequest({
      case: "trackSetting",
      value: t
    });
  }
  sendUpdateSubscription(t) {
    return this.sendRequest({
      case: "subscription",
      value: t
    });
  }
  sendSyncState(t) {
    return this.sendRequest({
      case: "syncState",
      value: t
    });
  }
  sendUpdateVideoLayers(t, i) {
    return this.sendRequest({
      case: "updateLayers",
      value: new JP({
        trackSid: t,
        layers: i
      })
    });
  }
  sendUpdateSubscriptionPermissions(t, i) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new tD({
        allParticipants: t,
        trackPermissions: i
      })
    });
  }
  sendSimulateScenario(t) {
    return this.sendRequest({
      case: "simulate",
      value: t
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: Gn.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new iD({
        timestamp: Gn.parse(Date.now()),
        rtt: Gn.parse(this.rtt)
      })
    })]);
  }
  sendUpdateLocalAudioTrack(t, i) {
    return this.sendRequest({
      case: "updateAudioTrack",
      value: new QP({
        trackSid: t,
        features: i
      })
    });
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new pb({
        reason: ls.CLIENT_INITIATED,
        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
        action: jp.DISCONNECT
      })
    });
  }
  sendRequest(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      return function* () {
        if (!u && !K3(i) && o.state === Wn.RECONNECTING) {
          o.queuedRequests.push(() => G(o, void 0, void 0, function* () {
            yield this.sendRequest(i, !0);
          }));
          return;
        }
        if (u || (yield o.requestQueue.flush()), o.signalLatency && (yield us(o.signalLatency)), !o.ws || o.ws.readyState !== o.ws.OPEN) {
          o.log.error("cannot send signal request before connected, type: ".concat(i == null ? void 0 : i.case), o.logContext);
          return;
        }
        const c = new wU({
          message: i
        });
        try {
          o.useJSON ? o.ws.send(c.toJsonString()) : o.ws.send(c.toBinary());
        } catch (m) {
          o.log.error("error sending signal message", Object.assign(Object.assign({}, o.logContext), {
            error: m
          }));
        }
      }();
    });
  }
  handleSignalResponse(t) {
    var i, o;
    const u = t.message;
    if (u == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let d = !1;
    if (u.case === "answer") {
      const c = Cx(u.value);
      this.onAnswer && this.onAnswer(c);
    } else if (u.case === "offer") {
      const c = Cx(u.value);
      this.onOffer && this.onOffer(c);
    } else if (u.case === "trickle") {
      const c = JSON.parse(u.value.candidateInit);
      this.onTrickle && this.onTrickle(c, u.value.target);
    } else
      u.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((i = u.value.participants) !== null && i !== void 0 ? i : []) : u.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(u.value) : u.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((o = u.value.speakers) !== null && o !== void 0 ? o : []) : u.case === "leave" ? this.onLeave && this.onLeave(u.value) : u.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(u.value.sid, u.value.muted) : u.case === "roomUpdate" ? this.onRoomUpdate && u.value.room && this.onRoomUpdate(u.value.room) : u.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(u.value) : u.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(u.value) : u.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(u.value) : u.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(u.value) : u.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(u.value) : u.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(u.value) : u.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(u.value) : u.case === "pong" || (u.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(u.value.lastPingTimestamp.toString()), this.resetPingTimeout(), d = !0) : u.case === "requestResponse" ? this.onRequestResponse && this.onRequestResponse(u.value) : u.case === "trackSubscribed" ? this.onLocalTrackSubscribed && this.onLocalTrackSubscribed(u.value.trackSid) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: u.case
      })));
    d || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const t = this.queuedRequests.shift();
      t && this.requestQueue.run(t);
    }
  }
  handleOnClose(t) {
    return G(this, void 0, void 0, function* () {
      if (this.state === Wn.DISCONNECTED)
        return;
      const i = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(t), Object.assign(Object.assign({}, this.logContext), {
        reason: t
      })), i && i(t);
    });
  }
  handleWSError(t) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: t
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = gi.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && gi.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = gi.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && gi.clearInterval(this.pingInterval);
  }
}
function Cx(r) {
  const t = {
    type: "offer",
    sdp: r.sdp
  };
  switch (r.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      t.type = r.type;
      break;
  }
  return t;
}
function eb(r) {
  return new Id({
    sdp: r.sdp,
    type: r.type
  });
}
function Q3(r, t, i) {
  var o;
  const u = new URLSearchParams();
  return u.set("access_token", r), i.reconnect && (u.set("reconnect", "1"), i.sid && u.set("sid", i.sid)), u.set("auto_subscribe", i.autoSubscribe ? "1" : "0"), u.set("sdk", Kl() ? "reactnative" : "js"), u.set("version", t.version), u.set("protocol", t.protocol.toString()), t.deviceModel && u.set("device_model", t.deviceModel), t.os && u.set("os", t.os), t.osVersion && u.set("os_version", t.osVersion), t.browser && u.set("browser", t.browser), t.browserVersion && u.set("browser_version", t.browserVersion), i.adaptiveStream && u.set("adaptive_stream", "1"), i.reconnectReason && u.set("reconnect_reason", i.reconnectReason.toString()), !((o = navigator.connection) === null || o === void 0) && o.type && u.set("network", navigator.connection.type), "?".concat(u.toString());
}
var ns = {}, cT = {}, dT = { exports: {} }, kx;
function _E() {
  if (kx)
    return dT.exports;
  kx = 1;
  var r = dT.exports = {
    v: [{
      name: "version",
      reg: /^(\d*)$/
    }],
    o: [{
      // o=- 20518 0 IN IP4 203.0.113.1
      // NB: sessionId will be a String in most cases because it is huge
      name: "origin",
      reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
      names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
      format: "%s %s %d %s IP%d %s"
    }],
    // default parsing of these only (though some of these feel outdated)
    s: [{
      name: "name"
    }],
    i: [{
      name: "description"
    }],
    u: [{
      name: "uri"
    }],
    e: [{
      name: "email"
    }],
    p: [{
      name: "phone"
    }],
    z: [{
      name: "timezones"
    }],
    // TODO: this one can actually be parsed properly...
    r: [{
      name: "repeats"
    }],
    // TODO: this one can also be parsed properly
    // k: [{}], // outdated thing ignored
    t: [{
      // t=0 0
      name: "timing",
      reg: /^(\d*) (\d*)/,
      names: ["start", "stop"],
      format: "%d %d"
    }],
    c: [{
      // c=IN IP4 10.47.197.26
      name: "connection",
      reg: /^IN IP(\d) (\S*)/,
      names: ["version", "ip"],
      format: "IN IP%d %s"
    }],
    b: [{
      // b=AS:4000
      push: "bandwidth",
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ["type", "limit"],
      format: "%s:%s"
    }],
    m: [{
      // m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
      names: ["type", "port", "protocol", "payloads"],
      format: "%s %d %s %s"
    }],
    a: [
      {
        // a=rtpmap:110 opus/48000/2
        push: "rtp",
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: ["payload", "codec", "rate", "encoding"],
        format: function(t) {
          return t.encoding ? "rtpmap:%d %s/%s/%s" : t.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        }
      },
      {
        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
        // a=fmtp:111 minptime=10; useinbandfec=1
        push: "fmtp",
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: ["payload", "config"],
        format: "fmtp:%d %s"
      },
      {
        // a=control:streamid=0
        name: "control",
        reg: /^control:(.*)/,
        format: "control:%s"
      },
      {
        // a=rtcp:65179 IN IP4 193.84.77.194
        name: "rtcp",
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: ["port", "netType", "ipVer", "address"],
        format: function(t) {
          return t.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        }
      },
      {
        // a=rtcp-fb:98 trr-int 100
        push: "rtcpFbTrrInt",
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: ["payload", "value"],
        format: "rtcp-fb:%s trr-int %d"
      },
      {
        // a=rtcp-fb:98 nack rpsi
        push: "rtcpFb",
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: ["payload", "type", "subtype"],
        format: function(t) {
          return t.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        }
      },
      {
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:1/recvonly URI-gps-string
        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
        push: "ext",
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: ["value", "direction", "encrypt-uri", "uri", "config"],
        format: function(t) {
          return "extmap:%d" + (t.direction ? "/%s" : "%v") + (t["encrypt-uri"] ? " %s" : "%v") + " %s" + (t.config ? " %s" : "");
        }
      },
      {
        // a=extmap-allow-mixed
        name: "extmapAllowMixed",
        reg: /^(extmap-allow-mixed)/
      },
      {
        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
        push: "crypto",
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: ["id", "suite", "config", "sessionConfig"],
        format: function(t) {
          return t.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        }
      },
      {
        // a=setup:actpass
        name: "setup",
        reg: /^setup:(\w*)/,
        format: "setup:%s"
      },
      {
        // a=connection:new
        name: "connectionType",
        reg: /^connection:(new|existing)/,
        format: "connection:%s"
      },
      {
        // a=mid:1
        name: "mid",
        reg: /^mid:([^\s]*)/,
        format: "mid:%s"
      },
      {
        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
        name: "msid",
        reg: /^msid:(.*)/,
        format: "msid:%s"
      },
      {
        // a=ptime:20
        name: "ptime",
        reg: /^ptime:(\d*(?:\.\d*)*)/,
        format: "ptime:%d"
      },
      {
        // a=maxptime:60
        name: "maxptime",
        reg: /^maxptime:(\d*(?:\.\d*)*)/,
        format: "maxptime:%d"
      },
      {
        // a=sendrecv
        name: "direction",
        reg: /^(sendrecv|recvonly|sendonly|inactive)/
      },
      {
        // a=ice-lite
        name: "icelite",
        reg: /^(ice-lite)/
      },
      {
        // a=ice-ufrag:F7gI
        name: "iceUfrag",
        reg: /^ice-ufrag:(\S*)/,
        format: "ice-ufrag:%s"
      },
      {
        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
        name: "icePwd",
        reg: /^ice-pwd:(\S*)/,
        format: "ice-pwd:%s"
      },
      {
        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
        name: "fingerprint",
        reg: /^fingerprint:(\S*) (\S*)/,
        names: ["type", "hash"],
        format: "fingerprint:%s %s"
      },
      {
        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
        push: "candidates",
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
        format: function(t) {
          var i = "candidate:%s %d %s %d %s %d typ %s";
          return i += t.raddr != null ? " raddr %s rport %d" : "%v%v", i += t.tcptype != null ? " tcptype %s" : "%v", t.generation != null && (i += " generation %d"), i += t["network-id"] != null ? " network-id %d" : "%v", i += t["network-cost"] != null ? " network-cost %d" : "%v", i;
        }
      },
      {
        // a=end-of-candidates (keep after the candidates line for readability)
        name: "endOfCandidates",
        reg: /^(end-of-candidates)/
      },
      {
        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
        name: "remoteCandidates",
        reg: /^remote-candidates:(.*)/,
        format: "remote-candidates:%s"
      },
      {
        // a=ice-options:google-ice
        name: "iceOptions",
        reg: /^ice-options:(\S*)/,
        format: "ice-options:%s"
      },
      {
        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
        push: "ssrcs",
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: ["id", "attribute", "value"],
        format: function(t) {
          var i = "ssrc:%d";
          return t.attribute != null && (i += " %s", t.value != null && (i += ":%s")), i;
        }
      },
      {
        // a=ssrc-group:FEC 1 2
        // a=ssrc-group:FEC-FR 3004364195 1080772241
        push: "ssrcGroups",
        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: ["semantics", "ssrcs"],
        format: "ssrc-group:%s %s"
      },
      {
        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
        name: "msidSemantic",
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: ["semantic", "token"],
        format: "msid-semantic: %s %s"
        // space after ':' is not accidental
      },
      {
        // a=group:BUNDLE audio video
        push: "groups",
        reg: /^group:(\w*) (.*)/,
        names: ["type", "mids"],
        format: "group:%s %s"
      },
      {
        // a=rtcp-mux
        name: "rtcpMux",
        reg: /^(rtcp-mux)/
      },
      {
        // a=rtcp-rsize
        name: "rtcpRsize",
        reg: /^(rtcp-rsize)/
      },
      {
        // a=sctpmap:5000 webrtc-datachannel 1024
        name: "sctpmap",
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: ["sctpmapNumber", "app", "maxMessageSize"],
        format: function(t) {
          return t.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        }
      },
      {
        // a=x-google-flag:conference
        name: "xGoogleFlag",
        reg: /^x-google-flag:([^\s]*)/,
        format: "x-google-flag:%s"
      },
      {
        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
        push: "rids",
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: ["id", "direction", "params"],
        format: function(t) {
          return t.params ? "rid:%s %s %s" : "rid:%s %s";
        }
      },
      {
        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
        // a=imageattr:* send [x=800,y=640] recv *
        // a=imageattr:100 recv [x=320,y=240]
        push: "imageattrs",
        reg: new RegExp(
          // a=imageattr:97
          "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
        ),
        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
        format: function(t) {
          return "imageattr:%s %s %s" + (t.dir2 ? " %s %s" : "");
        }
      },
      {
        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
        // a=simulcast:recv 1;4,5 send 6;7
        name: "simulcast",
        reg: new RegExp(
          // a=simulcast:
          "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
        ),
        names: ["dir1", "list1", "dir2", "list2"],
        format: function(t) {
          return "simulcast:%s %s" + (t.dir2 ? " %s %s" : "");
        }
      },
      {
        // old simulcast draft 03 (implemented by Firefox)
        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
        // a=simulcast: recv pt=97;98 send pt=97
        // a=simulcast: send rid=5;6;7 paused=6,7
        name: "simulcast_03",
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: ["value"],
        format: "simulcast: %s"
      },
      {
        // a=framerate:25
        // a=framerate:29.97
        name: "framerate",
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: "framerate:%s"
      },
      {
        // RFC4570
        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
        name: "sourceFilter",
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
        format: "source-filter: %s %s %s %s %s"
      },
      {
        // a=bundle-only
        name: "bundleOnly",
        reg: /^(bundle-only)/
      },
      {
        // a=label:1
        name: "label",
        reg: /^label:(.+)/,
        format: "label:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
        name: "sctpPort",
        reg: /^sctp-port:(\d+)$/,
        format: "sctp-port:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
        name: "maxMessageSize",
        reg: /^max-message-size:(\d+)$/,
        format: "max-message-size:%s"
      },
      {
        // RFC7273
        // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
        push: "tsRefClocks",
        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
        names: ["clksrc", "clksrcExt"],
        format: function(t) {
          return "ts-refclk:%s" + (t.clksrcExt != null ? "=%s" : "");
        }
      },
      {
        // RFC7273
        // a=mediaclk:direct=963214424
        name: "mediaClk",
        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
        names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
        format: function(t) {
          var i = "mediaclk:";
          return i += t.id != null ? "id=%s %s" : "%v%s", i += t.mediaClockValue != null ? "=%s" : "", i += t.rateNumerator != null ? " rate=%s" : "", i += t.rateDenominator != null ? "/%s" : "", i;
        }
      },
      {
        // a=keywds:keywords
        name: "keywords",
        reg: /^keywds:(.+)$/,
        format: "keywds:%s"
      },
      {
        // a=content:main
        name: "content",
        reg: /^content:(.+)/,
        format: "content:%s"
      },
      // BFCP https://tools.ietf.org/html/rfc4583
      {
        // a=floorctrl:c-s
        name: "bfcpFloorCtrl",
        reg: /^floorctrl:(c-only|s-only|c-s)/,
        format: "floorctrl:%s"
      },
      {
        // a=confid:1
        name: "bfcpConfId",
        reg: /^confid:(\d+)/,
        format: "confid:%s"
      },
      {
        // a=userid:1
        name: "bfcpUserId",
        reg: /^userid:(\d+)/,
        format: "userid:%s"
      },
      {
        // a=floorid:1
        name: "bfcpFloorId",
        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
        names: ["id", "mStream"],
        format: "floorid:%s mstrm:%s"
      },
      {
        // any a= that we don't understand is kept verbatim on media.invalid
        push: "invalid",
        names: ["value"]
      }
    ]
  };
  return Object.keys(r).forEach(function(t) {
    var i = r[t];
    i.forEach(function(o) {
      o.reg || (o.reg = /(.*)/), o.format || (o.format = "%s");
    });
  }), dT.exports;
}
var Tx;
function J3() {
  return Tx || (Tx = 1, function(r) {
    var t = function(m) {
      return String(Number(m)) === m ? Number(m) : m;
    }, i = function(m, g, b, C) {
      if (C && !b)
        g[C] = t(m[1]);
      else
        for (var E = 0; E < b.length; E += 1)
          m[E + 1] != null && (g[b[E]] = t(m[E + 1]));
    }, o = function(m, g, b) {
      var C = m.name && m.names;
      m.push && !g[m.push] ? g[m.push] = [] : C && !g[m.name] && (g[m.name] = {});
      var E = m.push ? {} : (
        // blank object that will be pushed
        C ? g[m.name] : g
      );
      i(b.match(m.reg), E, m.names, m.name), m.push && g[m.push].push(E);
    }, u = _E(), d = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    r.parse = function(m) {
      var g = {}, b = [], C = g;
      return m.split(/(\r\n|\r|\n)/).filter(d).forEach(function(E) {
        var x = E[0], O = E.slice(2);
        x === "m" && (b.push({
          rtp: [],
          fmtp: []
        }), C = b[b.length - 1]);
        for (var N = 0; N < (u[x] || []).length; N += 1) {
          var M = u[x][N];
          if (M.reg.test(O))
            return o(M, C, O);
        }
      }), g.media = b, g;
    };
    var c = function(m, g) {
      var b = g.split(/=(.+)/, 2);
      return b.length === 2 ? m[b[0]] = t(b[1]) : b.length === 1 && g.length > 1 && (m[b[0]] = void 0), m;
    };
    r.parseParams = function(m) {
      return m.split(/;\s?/).reduce(c, {});
    }, r.parseFmtpConfig = r.parseParams, r.parsePayloads = function(m) {
      return m.toString().split(" ").map(Number);
    }, r.parseRemoteCandidates = function(m) {
      for (var g = [], b = m.split(" ").map(t), C = 0; C < b.length; C += 3)
        g.push({
          component: b[C],
          ip: b[C + 1],
          port: b[C + 2]
        });
      return g;
    }, r.parseImageAttributes = function(m) {
      return m.split(" ").map(function(g) {
        return g.substring(1, g.length - 1).split(",").reduce(c, {});
      });
    }, r.parseSimulcastStreamList = function(m) {
      return m.split(";").map(function(g) {
        return g.split(",").map(function(b) {
          var C, E = !1;
          return b[0] !== "~" ? C = t(b) : (C = t(b.substring(1, b.length)), E = !0), {
            scid: C,
            paused: E
          };
        });
      });
    };
  }(cT)), cT;
}
var fT, Ex;
function X3() {
  if (Ex)
    return fT;
  Ex = 1;
  var r = _E(), t = /%[sdv%]/g, i = function(c) {
    var m = 1, g = arguments, b = g.length;
    return c.replace(t, function(C) {
      if (m >= b)
        return C;
      var E = g[m];
      switch (m += 1, C) {
        case "%%":
          return "%";
        case "%s":
          return String(E);
        case "%d":
          return Number(E);
        case "%v":
          return "";
      }
    });
  }, o = function(c, m, g) {
    var b = m.format instanceof Function ? m.format(m.push ? g : g[m.name]) : m.format, C = [c + "=" + b];
    if (m.names)
      for (var E = 0; E < m.names.length; E += 1) {
        var x = m.names[E];
        m.name ? C.push(g[m.name][x]) : C.push(g[m.names[E]]);
      }
    else
      C.push(g[m.name]);
    return i.apply(null, C);
  }, u = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], d = ["i", "c", "b", "a"];
  return fT = function(c, m) {
    m = m || {}, c.version == null && (c.version = 0), c.name == null && (c.name = " "), c.media.forEach(function(E) {
      E.payloads == null && (E.payloads = "");
    });
    var g = m.outerOrder || u, b = m.innerOrder || d, C = [];
    return g.forEach(function(E) {
      r[E].forEach(function(x) {
        x.name in c && c[x.name] != null ? C.push(o(E, x, c)) : x.push in c && c[x.push] != null && c[x.push].forEach(function(O) {
          C.push(o(E, x, O));
        });
      });
    }), c.media.forEach(function(E) {
      C.push(o("m", r.m[0], E)), b.forEach(function(x) {
        r[x].forEach(function(O) {
          O.name in E && E[O.name] != null ? C.push(o(x, O, E)) : O.push in E && E[O.push] != null && E[O.push].forEach(function(N) {
            C.push(o(x, O, N));
          });
        });
      });
    }), C.join(`\r
`) + `\r
`;
  }, fT;
}
var wx;
function Z3() {
  if (wx)
    return ns;
  wx = 1;
  var r = J3(), t = X3(), i = _E();
  return ns.grammar = i, ns.write = t, ns.parse = r.parse, ns.parseParams = r.parseParams, ns.parseFmtpConfig = r.parseFmtpConfig, ns.parsePayloads = r.parsePayloads, ns.parseRemoteCandidates = r.parseRemoteCandidates, ns.parseImageAttributes = r.parseImageAttributes, ns.parseSimulcastStreamList = r.parseSimulcastStreamList, ns;
}
var hc = Z3();
const eF = 0.7, tF = 20, Bp = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class Rx extends rl.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var o;
    super(), this.log = Wt, this.ddExtID = 0, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = TE((u) => G(this, void 0, void 0, function* () {
      this.emit(Bp.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (d) {
        if (u)
          u(d);
        else
          throw d;
      }
    }), tF), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = Yl((o = i.loggerName) !== null && o !== void 0 ? o : cs.PCTransport), this.loggerOptions = i, this.config = t, this._pc = this.createPC();
  }
  createPC() {
    const t = new RTCPeerConnection(this.config);
    return t.onicecandidate = (i) => {
      var o;
      i.candidate && ((o = this.onIceCandidate) === null || o === void 0 || o.call(this, i.candidate));
    }, t.onicecandidateerror = (i) => {
      var o;
      (o = this.onIceCandidateError) === null || o === void 0 || o.call(this, i);
    }, t.oniceconnectionstatechange = () => {
      var i;
      (i = this.onIceConnectionStateChange) === null || i === void 0 || i.call(this, t.iceConnectionState);
    }, t.onsignalingstatechange = () => {
      var i;
      (i = this.onSignalingStatechange) === null || i === void 0 || i.call(this, t.signalingState);
    }, t.onconnectionstatechange = () => {
      var i;
      (i = this.onConnectionStateChange) === null || i === void 0 || i.call(this, t.connectionState);
    }, t.ondatachannel = (i) => {
      var o;
      (o = this.onDataChannel) === null || o === void 0 || o.call(this, i);
    }, t.ontrack = (i) => {
      var o;
      (o = this.onTrack) === null || o === void 0 || o.call(this, i);
    }, t;
  }
  get logContext() {
    var t, i;
    return Object.assign({}, (i = (t = this.loggerOptions).loggerContextCb) === null || i === void 0 ? void 0 : i.call(t));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(t) {
    return G(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(t);
      this.pendingCandidates.push(t);
    });
  }
  setRemoteDescription(t) {
    return G(this, void 0, void 0, function* () {
      var i;
      let o;
      if (t.type === "offer") {
        let {
          stereoMids: u,
          nackMids: d
        } = nF(t);
        this.remoteStereoMids = u, this.remoteNackMids = d;
      } else if (t.type === "answer") {
        const u = hc.parse((i = t.sdp) !== null && i !== void 0 ? i : "");
        u.media.forEach((d) => {
          d.type === "audio" && this.trackBitrates.some((c) => {
            if (!c.transceiver || d.mid != c.transceiver.mid)
              return !1;
            let m = 0;
            if (d.rtp.some((b) => b.codec.toUpperCase() === c.codec.toUpperCase() ? (m = b.payload, !0) : !1), m === 0)
              return !0;
            let g = !1;
            for (const b of d.fmtp)
              if (b.payload === m) {
                b.config = b.config.split(";").filter((C) => !C.includes("maxaveragebitrate")).join(";"), c.maxbr > 0 && (b.config += ";maxaveragebitrate=".concat(c.maxbr * 1e3)), g = !0;
                break;
              }
            return g || c.maxbr > 0 && d.fmtp.push({
              payload: m,
              config: "maxaveragebitrate=".concat(c.maxbr * 1e3)
            }), !0;
          });
        }), o = hc.write(u);
      }
      yield this.setMungedSDP(t, o, !0), this.pendingCandidates.forEach((u) => {
        this.pc.addIceCandidate(u);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : t.type === "answer" && (this.emit(Bp.NegotiationComplete), t.sdp && hc.parse(t.sdp).media.forEach((d) => {
        d.type === "video" && this.emit(Bp.RTPVideoPayloadTypes, d.rtp);
      }));
    });
  }
  createAndSendOffer(t) {
    return G(this, void 0, void 0, function* () {
      var i;
      if (this.onOffer === void 0)
        return;
      if (t != null && t.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const d = this._pc.remoteDescription;
        if (t != null && t.iceRestart && d)
          yield this._pc.setRemoteDescription(d);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const o = yield this.pc.createOffer(t);
      this.log.debug("original offer", Object.assign({
        sdp: o.sdp
      }, this.logContext));
      const u = hc.parse((i = o.sdp) !== null && i !== void 0 ? i : "");
      u.media.forEach((d) => {
        xx(d), d.type === "audio" ? _x(d, [], []) : d.type === "video" && this.trackBitrates.some((c) => {
          if (!d.msid || !c.cid || !d.msid.includes(c.cid))
            return !1;
          let m = 0;
          if (d.rtp.some((b) => b.codec.toUpperCase() === c.codec.toUpperCase() ? (m = b.payload, !0) : !1), m === 0 || (Cv(c.codec) && this.ensureVideoDDExtensionForSVC(d, u), c.codec !== "av1"))
            return !0;
          const g = Math.round(c.maxbr * eF);
          for (const b of d.fmtp)
            if (b.payload === m) {
              b.config.includes("x-google-start-bitrate") || (b.config += ";x-google-start-bitrate=".concat(g));
              break;
            }
          return !0;
        });
      }), yield this.setMungedSDP(o, hc.write(u)), this.onOffer(o);
    });
  }
  createAndSetAnswer() {
    return G(this, void 0, void 0, function* () {
      var t;
      const i = yield this.pc.createAnswer(), o = hc.parse((t = i.sdp) !== null && t !== void 0 ? t : "");
      return o.media.forEach((u) => {
        xx(u), u.type === "audio" && _x(u, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(i, hc.write(o)), i;
    });
  }
  createDataChannel(t, i) {
    return this.pc.createDataChannel(t, i);
  }
  addTransceiver(t, i) {
    return this.pc.addTransceiver(t, i);
  }
  addTrack(t) {
    if (!this._pc)
      throw new zr("PC closed, cannot add track");
    return this._pc.addTrack(t);
  }
  setTrackCodecBitrate(t) {
    this.trackBitrates.push(t);
  }
  setConfiguration(t) {
    var i;
    if (!this._pc)
      throw new zr("PC closed, cannot configure");
    return (i = this._pc) === null || i === void 0 ? void 0 : i.setConfiguration(t);
  }
  canRemoveTrack() {
    var t;
    return !!(!((t = this._pc) === null || t === void 0) && t.removeTrack);
  }
  removeTrack(t) {
    var i;
    return (i = this._pc) === null || i === void 0 ? void 0 : i.removeTrack(t);
  }
  getConnectionState() {
    var t, i;
    return (i = (t = this._pc) === null || t === void 0 ? void 0 : t.connectionState) !== null && i !== void 0 ? i : "closed";
  }
  getICEConnectionState() {
    var t, i;
    return (i = (t = this._pc) === null || t === void 0 ? void 0 : t.iceConnectionState) !== null && i !== void 0 ? i : "closed";
  }
  getSignallingState() {
    var t, i;
    return (i = (t = this._pc) === null || t === void 0 ? void 0 : t.signalingState) !== null && i !== void 0 ? i : "closed";
  }
  getTransceivers() {
    var t, i;
    return (i = (t = this._pc) === null || t === void 0 ? void 0 : t.getTransceivers()) !== null && i !== void 0 ? i : [];
  }
  getSenders() {
    var t, i;
    return (i = (t = this._pc) === null || t === void 0 ? void 0 : t.getSenders()) !== null && i !== void 0 ? i : [];
  }
  getLocalDescription() {
    var t;
    return (t = this._pc) === null || t === void 0 ? void 0 : t.localDescription;
  }
  getRemoteDescription() {
    var t;
    return (t = this.pc) === null || t === void 0 ? void 0 : t.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    return G(this, void 0, void 0, function* () {
      var t;
      if (!this._pc)
        return;
      let i = "";
      const o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((m) => {
        switch (m.type) {
          case "transport":
            i = m.selectedCandidatePairId;
            break;
          case "candidate-pair":
            i === "" && m.selected && (i = m.id), o.set(m.id, m);
            break;
          case "remote-candidate":
            u.set(m.id, "".concat(m.address, ":").concat(m.port));
            break;
        }
      }), i === "")
        return;
      const c = (t = o.get(i)) === null || t === void 0 ? void 0 : t.remoteCandidateId;
      if (c !== void 0)
        return u.get(c);
    });
  }
  setMungedSDP(t, i, o) {
    return G(this, void 0, void 0, function* () {
      if (i) {
        const u = t.sdp;
        t.sdp = i;
        try {
          this.log.debug("setting munged ".concat(o ? "remote" : "local", " description"), this.logContext), o ? yield this.pc.setRemoteDescription(t) : yield this.pc.setLocalDescription(t);
          return;
        } catch (d) {
          this.log.warn("not able to set ".concat(t.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: d,
            sdp: i
          })), t.sdp = u;
        }
      }
      try {
        o ? yield this.pc.setRemoteDescription(t) : yield this.pc.setLocalDescription(t);
      } catch (u) {
        let d = "unknown error";
        u instanceof Error ? d = u.message : typeof u == "string" && (d = u);
        const c = {
          error: d,
          sdp: t.sdp
        };
        throw !o && this.pc.remoteDescription && (c.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(t.type), Object.assign(Object.assign({}, this.logContext), {
          fields: c
        })), new zT(d);
      }
    });
  }
  ensureVideoDDExtensionForSVC(t, i) {
    var o, u;
    if (!((o = t.ext) === null || o === void 0 ? void 0 : o.some((c) => c.uri === hx))) {
      if (this.ddExtID === 0) {
        let c = 0;
        i.media.forEach((m) => {
          var g;
          m.type === "video" && ((g = m.ext) === null || g === void 0 || g.forEach((b) => {
            b.value > c && (c = b.value);
          }));
        }), this.ddExtID = c + 1;
      }
      (u = t.ext) === null || u === void 0 || u.push({
        value: this.ddExtID,
        uri: hx
      });
    }
  }
}
function _x(r, t, i) {
  let o = 0;
  r.rtp.some((u) => u.codec === "opus" ? (o = u.payload, !0) : !1), o > 0 && (r.rtcpFb || (r.rtcpFb = []), i.includes(r.mid) && !r.rtcpFb.some((u) => u.payload === o && u.type === "nack") && r.rtcpFb.push({
    payload: o,
    type: "nack"
  }), t.includes(r.mid) && r.fmtp.some((u) => u.payload === o ? (u.config.includes("stereo=1") || (u.config += ";stereo=1"), !0) : !1));
}
function nF(r) {
  var t;
  const i = [], o = [], u = hc.parse((t = r.sdp) !== null && t !== void 0 ? t : "");
  let d = 0;
  return u.media.forEach((c) => {
    var m;
    c.type === "audio" && (c.rtp.some((g) => g.codec === "opus" ? (d = g.payload, !0) : !1), !((m = c.rtcpFb) === null || m === void 0) && m.some((g) => g.payload === d && g.type === "nack") && o.push(c.mid), c.fmtp.some((g) => g.payload === d ? (g.config.includes("sprop-stereo=1") && i.push(c.mid), !0) : !1));
  }), {
    stereoMids: i,
    nackMids: o
  };
}
function xx(r) {
  if (r.connection) {
    const t = r.connection.ip.indexOf(":") >= 0;
    (r.connection.version === 4 && t || r.connection.version === 6 && !t) && (r.connection.ip = "0.0.0.0", r.connection.version = 4);
  }
}
const YT = "vp8", rF = {
  audioPreset: VT.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: EE.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: YT,
  backupCodec: !0
}, qD = {
  deviceId: "default",
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0,
  voiceIsolation: !0
}, WD = {
  deviceId: "default",
  resolution: as.h720.resolution
}, iF = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new JU(),
  disconnectOnPageLeave: !0,
  webAudioMix: !1
}, xE = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var sr;
(function(r) {
  r[r.NEW = 0] = "NEW", r[r.CONNECTING = 1] = "CONNECTING", r[r.CONNECTED = 2] = "CONNECTED", r[r.FAILED = 3] = "FAILED", r[r.CLOSING = 4] = "CLOSING", r[r.CLOSED = 5] = "CLOSED";
})(sr || (sr = {}));
class aF {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(t, i, o) {
    var u;
    this.peerConnectionTimeout = xE.peerConnectionTimeout, this.log = Wt, this.updateState = () => {
      var d;
      const c = this.state, m = this.requiredTransports.map((g) => g.getConnectionState());
      m.every((g) => g === "connected") ? this.state = sr.CONNECTED : m.some((g) => g === "failed") ? this.state = sr.FAILED : m.some((g) => g === "connecting") ? this.state = sr.CONNECTING : m.every((g) => g === "closed") ? this.state = sr.CLOSED : m.some((g) => g === "closed") ? this.state = sr.CLOSING : m.every((g) => g === "new") && (this.state = sr.NEW), c !== this.state && (this.log.debug("pc state change: from ".concat(sr[c], " to ").concat(sr[this.state]), this.logContext), (d = this.onStateChange) === null || d === void 0 || d.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = Yl((u = o.loggerName) !== null && u !== void 0 ? u : cs.PCManager), this.loggerOptions = o, this.isPublisherConnectionRequired = !i, this.isSubscriberConnectionRequired = i, this.publisher = new Rx(t, o), this.subscriber = new Rx(t, o), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (d) => {
      var c;
      (c = this.onIceCandidate) === null || c === void 0 || c.call(this, d, ss.PUBLISHER);
    }, this.subscriber.onIceCandidate = (d) => {
      var c;
      (c = this.onIceCandidate) === null || c === void 0 || c.call(this, d, ss.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (d) => {
      var c;
      (c = this.onDataChannel) === null || c === void 0 || c.call(this, d);
    }, this.subscriber.onTrack = (d) => {
      var c;
      (c = this.onTrack) === null || c === void 0 || c.call(this, d);
    }, this.publisher.onOffer = (d) => {
      var c;
      (c = this.onPublisherOffer) === null || c === void 0 || c.call(this, d);
    }, this.state = sr.NEW, this.connectionLock = new Aa(), this.remoteOfferLock = new Aa();
  }
  get logContext() {
    var t, i;
    return Object.assign({}, (i = (t = this.loggerOptions).loggerContextCb) === null || i === void 0 ? void 0 : i.call(t));
  }
  requirePublisher() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = t, this.updateState();
  }
  requireSubscriber() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = t, this.updateState();
  }
  createAndSendPublisherOffer(t) {
    return this.publisher.createAndSendOffer(t);
  }
  setPublisherAnswer(t) {
    return this.publisher.setRemoteDescription(t);
  }
  removeTrack(t) {
    return this.publisher.removeTrack(t);
  }
  close() {
    return G(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const t = this.publisher;
        for (const i of t.getSenders())
          try {
            t.canRemoveTrack() && t.removeTrack(i);
          } catch (o) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: o
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return G(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(t, i) {
    return G(this, void 0, void 0, function* () {
      i === ss.PUBLISHER ? yield this.publisher.addIceCandidate(t) : yield this.subscriber.addIceCandidate(t);
    });
  }
  createSubscriberAnswerFromOffer(t) {
    return G(this, void 0, void 0, function* () {
      this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: t.type,
        sdp: t.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      }));
      const i = yield this.remoteOfferLock.lock();
      try {
        return yield this.subscriber.setRemoteDescription(t), yield this.subscriber.createAndSetAnswer();
      } finally {
        i();
      }
    });
  }
  updateConfiguration(t, i) {
    this.publisher.setConfiguration(t), this.subscriber.setConfiguration(t), i && this.triggerIceRestart();
  }
  ensurePCTransportConnection(t, i) {
    return G(this, void 0, void 0, function* () {
      var o;
      const u = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((o = this.requiredTransports) === null || o === void 0 ? void 0 : o.map((d) => this.ensureTransportConnected(d, t, i)));
      } finally {
        u();
      }
    });
  }
  negotiate(t) {
    return G(this, void 0, void 0, function* () {
      return new Promise((i, o) => G(this, void 0, void 0, function* () {
        const u = setTimeout(() => {
          o("negotiation timed out");
        }, this.peerConnectionTimeout), d = () => {
          clearTimeout(u), o("negotiation aborted");
        };
        t.signal.addEventListener("abort", d), this.publisher.once(Bp.NegotiationStarted, () => {
          t.signal.aborted || this.publisher.once(Bp.NegotiationComplete, () => {
            clearTimeout(u), i();
          });
        }), yield this.publisher.negotiate((c) => {
          clearTimeout(u), o(c);
        });
      }));
    });
  }
  addPublisherTransceiver(t, i) {
    return this.publisher.addTransceiver(t, i);
  }
  addPublisherTrack(t) {
    return this.publisher.addTrack(t);
  }
  createPublisherDataChannel(t, i) {
    return this.publisher.createDataChannel(t, i);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(t) {
    return t === ss.PUBLISHER ? this.publisher.getConnectedAddress() : t === ss.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const t = [];
    return this.isPublisherConnectionRequired && t.push(this.publisher), this.isSubscriberConnectionRequired && t.push(this.subscriber), t;
  }
  ensureTransportConnected(t, i) {
    return G(this, arguments, void 0, function(o, u) {
      var d = this;
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
      return function* () {
        if (o.getConnectionState() !== "connected")
          return new Promise((g, b) => G(d, void 0, void 0, function* () {
            const C = () => {
              this.log.warn("abort transport connection", this.logContext), gi.clearTimeout(E), b(new xn("room connection has been cancelled", nn.Cancelled));
            };
            u != null && u.signal.aborted && C(), u == null || u.signal.addEventListener("abort", C);
            const E = gi.setTimeout(() => {
              u == null || u.signal.removeEventListener("abort", C), b(new xn("could not establish pc connection", nn.InternalError));
            }, c);
            for (; this.state !== sr.CONNECTED; )
              if (yield us(50), u != null && u.signal.aborted) {
                b(new xn("room connection has been cancelled", nn.Cancelled));
                return;
              }
            gi.clearTimeout(E), u == null || u.signal.removeEventListener("abort", C), g();
          }));
      }();
    });
  }
}
const PE = 2e3;
function gb(r, t) {
  if (!t)
    return 0;
  let i, o;
  return "bytesReceived" in r ? (i = r.bytesReceived, o = t.bytesReceived) : "bytesSent" in r && (i = r.bytesSent, o = t.bytesSent), i === void 0 || o === void 0 || r.timestamp === void 0 || t.timestamp === void 0 ? 0 : (i - o) * 8 * 1e3 / (r.timestamp - t.timestamp);
}
class vi extends Ld {
  /**
   * boolean indicating whether enhanced noise cancellation is currently being used on this track
   */
  get enhancedNoiseCancellation() {
    return this.isKrispNoiseFilterEnabled;
  }
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(t, i) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, u = arguments.length > 3 ? arguments[3] : void 0, d = arguments.length > 4 ? arguments[4] : void 0;
    super(t, ue.Kind.Audio, i, o, d), this.stopOnMute = !1, this.isKrispNoiseFilterEnabled = !1, this.monitorSender = () => G(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let c;
      try {
        c = yield this.getSenderStats();
      } catch (m) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: m
        }));
        return;
      }
      c && this.prevStats && (this._currentBitrate = gb(c, this.prevStats)), this.prevStats = c;
    }), this.handleKrispNoiseFilterEnable = () => {
      this.isKrispNoiseFilterEnabled = !0, this.log.debug("Krisp noise filter enabled", this.logContext), this.emit(Le.AudioTrackFeatureUpdate, this, el.TF_ENHANCED_NOISE_CANCELLATION, !0);
    }, this.handleKrispNoiseFilterDisable = () => {
      this.isKrispNoiseFilterEnabled = !1, this.log.debug("Krisp noise filter disabled", this.logContext), this.emit(Le.AudioTrackFeatureUpdate, this, el.TF_ENHANCED_NOISE_CANCELLATION, !1);
    }, this.audioContext = u, this.checkForSilence();
  }
  mute() {
    const t = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return G(this, void 0, void 0, function* () {
      const i = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === ue.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield t.mute.call(this), this);
      } finally {
        i();
      }
    });
  }
  unmute() {
    const t = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return G(this, void 0, void 0, function* () {
      const i = yield this.muteLock.lock();
      try {
        if (!this.isMuted)
          return this.log.debug("Track already unmuted", this.logContext), this;
        const o = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== Nd(this._constraints.deviceId);
        return this.source === ue.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || o) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield t.unmute.call(this), this;
      } finally {
        i();
      }
    });
  }
  restartTrack(t) {
    return G(this, void 0, void 0, function* () {
      let i;
      if (t) {
        const o = vb({
          audio: t
        });
        typeof o.audio != "boolean" && (i = o.audio);
      }
      yield this.restart(i);
    });
  }
  restart(t) {
    const i = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return G(this, void 0, void 0, function* () {
      const o = yield i.restart.call(this, t);
      return this.checkForSilence(), o;
    });
  }
  /* @internal */
  startMonitor() {
    Ia() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, PE)));
  }
  setProcessor(t) {
    return G(this, void 0, void 0, function* () {
      var i;
      const o = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        this.processor && (yield this.stopProcessor());
        const u = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(t.name), this.logContext), yield t.init(u), this.processor = t, this.processor.processedTrack && (yield (i = this.sender) === null || i === void 0 ? void 0 : i.replaceTrack(this.processor.processedTrack), this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable), this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable)), this.emit(Le.TrackProcessorUpdate, this.processor);
      } finally {
        o();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(t) {
    this.audioContext = t;
  }
  getSenderStats() {
    return G(this, void 0, void 0, function* () {
      var t;
      if (!(!((t = this.sender) === null || t === void 0) && t.getStats))
        return;
      const i = yield this.sender.getStats();
      let o;
      return i.forEach((u) => {
        u.type === "outbound-rtp" && (o = {
          type: "audio",
          streamId: u.id,
          packetsSent: u.packetsSent,
          packetsLost: u.packetsLost,
          bytesSent: u.bytesSent,
          timestamp: u.timestamp,
          roundTripTime: u.roundTripTime,
          jitter: u.jitter
        });
      }), o;
    });
  }
  checkForSilence() {
    return G(this, void 0, void 0, function* () {
      const t = yield R3(this);
      return t && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(Le.AudioSilenceDetected)), t;
    });
  }
}
function GD(r, t, i) {
  switch (r.kind) {
    case "audio":
      return new vi(r, t, !1, void 0, i);
    case "video":
      return new Bi(r, t, !1, i);
    default:
      throw new Gl("unsupported track type: ".concat(r.kind));
  }
}
const oF = Object.values(as), sF = Object.values(BT), lF = Object.values(EE), uF = [as.h180, as.h360], cF = [BT.h180, BT.h360], dF = (r) => [{
  scaleResolutionDownBy: 2,
  fps: r.encoding.maxFramerate
}].map((i) => {
  var o, u;
  return new Cn(Math.floor(r.width / i.scaleResolutionDownBy), Math.floor(r.height / i.scaleResolutionDownBy), Math.max(15e4, Math.floor(r.encoding.maxBitrate / (Math.pow(i.scaleResolutionDownBy, 2) * (((o = r.encoding.maxFramerate) !== null && o !== void 0 ? o : 30) / ((u = i.fps) !== null && u !== void 0 ? u : 30))))), i.fps, r.encoding.priority);
}), KT = ["q", "h", "f"];
function QT(r, t, i, o) {
  var u, d;
  let c = o == null ? void 0 : o.videoEncoding;
  r && (c = o == null ? void 0 : o.screenShareEncoding);
  const m = o == null ? void 0 : o.simulcast, g = o == null ? void 0 : o.scalabilityMode, b = o == null ? void 0 : o.videoCodec;
  if (!c && !m && !g || !t || !i)
    return [{}];
  c || (c = pF(r, t, i, b), Wt.debug("using video encoding", c));
  const C = c.maxFramerate, E = new Cn(t, i, c.maxBitrate, c.maxFramerate, c.priority);
  if (g && Cv(b)) {
    const N = new YD(g), M = [];
    if (N.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(g));
    const I = tl();
    if (Cc() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
    // is provided. So we'll use the legacy SVC specification for now.
    // TODO: when we upstream libwebrtc, this will need additional verification
    Kl() || (I == null ? void 0 : I.name) === "Chrome" && Ud(I == null ? void 0 : I.version, "113") < 0) {
      const U = N.suffix == "h" ? 2 : 3;
      for (let ae = 0; ae < N.spatial; ae += 1)
        M.push({
          rid: KT[2 - ae],
          maxBitrate: c.maxBitrate / Math.pow(U, ae),
          maxFramerate: E.encoding.maxFramerate
        });
      M[0].scalabilityMode = g;
    } else
      M.push({
        maxBitrate: c.maxBitrate,
        maxFramerate: E.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode: g
      });
    return E.encoding.priority && (M[0].priority = E.encoding.priority, M[0].networkPriority = E.encoding.priority), Wt.debug("using svc encoding", {
      encodings: M
    }), M;
  }
  if (!m)
    return [c];
  let x = [];
  r ? x = (u = Dx(o == null ? void 0 : o.screenShareSimulcastLayers)) !== null && u !== void 0 ? u : Px(r, E) : x = (d = Dx(o == null ? void 0 : o.videoSimulcastLayers)) !== null && d !== void 0 ? d : Px(r, E);
  let O;
  if (x.length > 0) {
    const N = x[0];
    x.length > 1 && ([, O] = x);
    const M = Math.max(t, i);
    if (M >= 960 && O)
      return pT(t, i, [N, O, E], C);
    if (M >= 480)
      return pT(t, i, [N, E], C);
  }
  return pT(t, i, [E]);
}
function fF(r, t, i) {
  var o, u, d, c;
  if (!i.backupCodec || i.backupCodec === !0 || i.backupCodec.codec === i.videoCodec)
    return;
  t !== i.backupCodec.codec && Wt.warn("requested a different codec than specified as backup", {
    serverRequested: t,
    backup: i.backupCodec.codec
  }), i.videoCodec = t, i.videoEncoding = i.backupCodec.encoding;
  const m = r.mediaStreamTrack.getSettings(), g = (o = m.width) !== null && o !== void 0 ? o : (u = r.dimensions) === null || u === void 0 ? void 0 : u.width, b = (d = m.height) !== null && d !== void 0 ? d : (c = r.dimensions) === null || c === void 0 ? void 0 : c.height;
  return QT(r.source === ue.Source.ScreenShare, g, b, i);
}
function pF(r, t, i, o) {
  const u = hF(r, t, i);
  let {
    encoding: d
  } = u[0];
  const c = Math.max(t, i);
  for (let m = 0; m < u.length; m += 1) {
    const g = u[m];
    if (d = g.encoding, g.width >= c)
      break;
  }
  if (o)
    switch (o) {
      case "av1":
        d = Object.assign({}, d), d.maxBitrate = d.maxBitrate * 0.7;
        break;
      case "vp9":
        d = Object.assign({}, d), d.maxBitrate = d.maxBitrate * 0.85;
        break;
    }
  return d;
}
function hF(r, t, i) {
  if (r)
    return lF;
  const o = t > i ? t / i : i / t;
  return Math.abs(o - 16 / 9) < Math.abs(o - 4 / 3) ? oF : sF;
}
function Px(r, t) {
  if (r)
    return dF(t);
  const {
    width: i,
    height: o
  } = t, u = i > o ? i / o : o / i;
  return Math.abs(u - 16 / 9) < Math.abs(u - 4 / 3) ? uF : cF;
}
function pT(r, t, i, o) {
  const u = [];
  if (i.forEach((d, c) => {
    if (c >= KT.length)
      return;
    const m = Math.min(r, t), b = {
      rid: KT[c],
      scaleResolutionDownBy: Math.max(1, m / Math.min(d.width, d.height)),
      maxBitrate: d.encoding.maxBitrate
    }, C = o && d.encoding.maxFramerate ? Math.min(o, d.encoding.maxFramerate) : d.encoding.maxFramerate;
    C && (b.maxFramerate = C);
    const E = Kp() || c === 0;
    d.encoding.priority && E && (b.priority = d.encoding.priority, b.networkPriority = d.encoding.priority), u.push(b);
  }), Kl() && HD() === "ios") {
    let d;
    u.forEach((m) => {
      d ? m.maxFramerate && m.maxFramerate > d && (d = m.maxFramerate) : d = m.maxFramerate;
    });
    let c = !0;
    u.forEach((m) => {
      var g;
      m.maxFramerate != d && (c && (c = !1, Wt.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), Wt.info('Setting framerate of encoding "'.concat((g = m.rid) !== null && g !== void 0 ? g : "", '" to ').concat(d)), m.maxFramerate = d);
    });
  }
  return u;
}
function Dx(r) {
  if (r)
    return r.sort((t, i) => {
      const {
        encoding: o
      } = t, {
        encoding: u
      } = i;
      return o.maxBitrate > u.maxBitrate ? 1 : o.maxBitrate < u.maxBitrate ? -1 : o.maxBitrate === u.maxBitrate && o.maxFramerate && u.maxFramerate ? o.maxFramerate > u.maxFramerate ? 1 : -1 : 0;
    });
}
class YD {
  constructor(t) {
    const i = t.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!i)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(i[1]), this.temporal = parseInt(i[2]), i.length > 3)
      switch (i[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = i[3];
      }
  }
  toString() {
    var t;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((t = this.suffix) !== null && t !== void 0 ? t : "");
  }
}
function mF(r) {
  return r.source === ue.Source.ScreenShare || r.constraints.height && Nd(r.constraints.height) >= 1080 ? "maintain-resolution" : "balanced";
}
const vF = 5e3;
class Bi extends Ld {
  get sender() {
    return this._sender;
  }
  set sender(t) {
    this._sender = t, this.degradationPreference && this.setDegradationPreference(this.degradationPreference);
  }
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(t, i) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, u = arguments.length > 3 ? arguments[3] : void 0;
    super(t, ue.Kind.Video, i, o, u), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.degradationPreference = "balanced", this.monitorSender = () => G(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let d;
      try {
        d = yield this.getSenderStats();
      } catch (m) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: m
        }));
        return;
      }
      const c = new Map(d.map((m) => [m.rid, m]));
      if (this.prevStats) {
        let m = 0;
        c.forEach((g, b) => {
          var C;
          const E = (C = this.prevStats) === null || C === void 0 ? void 0 : C.get(b);
          m += gb(g, E);
        }), this._currentBitrate = m;
      }
      this.prevStats = c;
    }), this.senderLock = new Aa();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(t) {
    var i;
    if (this.signalClient = t, !Ia())
      return;
    const o = (i = this.sender) === null || i === void 0 ? void 0 : i.getParameters();
    o && (this.encodings = o.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, PE));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((t) => {
      t.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const t = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    return G(this, void 0, void 0, function* () {
      var i, o, u, d, c;
      yield t.pauseUpstream.call(this);
      try {
        for (var m = !0, g = Ap(this.simulcastCodecs.values()), b; b = yield g.next(), i = b.done, !i; m = !0)
          d = b.value, m = !1, yield (c = d.sender) === null || c === void 0 ? void 0 : c.replaceTrack(null);
      } catch (C) {
        o = {
          error: C
        };
      } finally {
        try {
          !m && !i && (u = g.return) && (yield u.call(g));
        } finally {
          if (o)
            throw o.error;
        }
      }
    });
  }
  resumeUpstream() {
    const t = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    return G(this, void 0, void 0, function* () {
      var i, o, u, d, c;
      yield t.resumeUpstream.call(this);
      try {
        for (var m = !0, g = Ap(this.simulcastCodecs.values()), b; b = yield g.next(), i = b.done, !i; m = !0) {
          d = b.value, m = !1;
          const C = d;
          yield (c = C.sender) === null || c === void 0 ? void 0 : c.replaceTrack(C.mediaStreamTrack);
        }
      } catch (C) {
        o = {
          error: C
        };
      } finally {
        try {
          !m && !i && (u = g.return) && (yield u.call(g));
        } finally {
          if (o)
            throw o.error;
        }
      }
    });
  }
  mute() {
    const t = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return G(this, void 0, void 0, function* () {
      const i = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.log.debug("Track already muted", this.logContext), this) : (this.source === ue.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield t.mute.call(this), this);
      } finally {
        i();
      }
    });
  }
  unmute() {
    const t = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return G(this, void 0, void 0, function* () {
      const i = yield this.muteLock.lock();
      try {
        return this.isMuted ? (this.source === ue.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield t.unmute.call(this), this) : (this.log.debug("Track already unmuted", this.logContext), this);
      } finally {
        i();
      }
    });
  }
  setTrackMuted(t) {
    super.setTrackMuted(t);
    for (const i of this.simulcastCodecs.values())
      i.mediaStreamTrack.enabled = !t;
  }
  getSenderStats() {
    return G(this, void 0, void 0, function* () {
      var t;
      if (!(!((t = this.sender) === null || t === void 0) && t.getStats))
        return [];
      const i = [], o = yield this.sender.getStats();
      return o.forEach((u) => {
        var d;
        if (u.type === "outbound-rtp") {
          const c = {
            type: "video",
            streamId: u.id,
            frameHeight: u.frameHeight,
            frameWidth: u.frameWidth,
            framesPerSecond: u.framesPerSecond,
            framesSent: u.framesSent,
            firCount: u.firCount,
            pliCount: u.pliCount,
            nackCount: u.nackCount,
            packetsSent: u.packetsSent,
            bytesSent: u.bytesSent,
            qualityLimitationReason: u.qualityLimitationReason,
            qualityLimitationDurations: u.qualityLimitationDurations,
            qualityLimitationResolutionChanges: u.qualityLimitationResolutionChanges,
            rid: (d = u.rid) !== null && d !== void 0 ? d : u.id,
            retransmittedPacketsSent: u.retransmittedPacketsSent,
            targetBitrate: u.targetBitrate,
            timestamp: u.timestamp
          }, m = o.get(u.remoteId);
          m && (c.jitter = m.jitter, c.packetsLost = m.packetsLost, c.roundTripTime = m.roundTripTime), i.push(c);
        }
      }), i.sort((u, d) => {
        var c, m;
        return ((c = d.frameWidth) !== null && c !== void 0 ? c : 0) - ((m = u.frameWidth) !== null && m !== void 0 ? m : 0);
      }), i;
    });
  }
  setPublishingQuality(t) {
    const i = [];
    for (let o = To.LOW; o <= To.HIGH; o += 1)
      i.push(new CE({
        quality: o,
        enabled: o <= t
      }));
    this.log.debug("setting publishing quality. max quality ".concat(t), this.logContext), this.setPublishingLayers(i);
  }
  restartTrack(t) {
    return G(this, void 0, void 0, function* () {
      var i, o, u, d;
      let c;
      if (t) {
        const C = vb({
          video: t
        });
        typeof C.video != "boolean" && (c = C.video);
      }
      yield this.restart(c);
      try {
        for (var m = !0, g = Ap(this.simulcastCodecs.values()), b; b = yield g.next(), i = b.done, !i; m = !0) {
          d = b.value, m = !1;
          const C = d;
          C.sender && (C.mediaStreamTrack = this.mediaStreamTrack.clone(), yield C.sender.replaceTrack(C.mediaStreamTrack));
        }
      } catch (C) {
        o = {
          error: C
        };
      } finally {
        try {
          !m && !i && (u = g.return) && (yield u.call(g));
        } finally {
          if (o)
            throw o.error;
        }
      }
    });
  }
  setProcessor(t) {
    const i = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    return G(this, arguments, void 0, function(o) {
      var u = this;
      let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return function* () {
        var c, m, g, b, C, E;
        if (yield i.setProcessor.call(u, o, d), !((C = u.processor) === null || C === void 0) && C.processedTrack)
          try {
            for (var x = !0, O = Ap(u.simulcastCodecs.values()), N; N = yield O.next(), c = N.done, !c; x = !0)
              b = N.value, x = !1, yield (E = b.sender) === null || E === void 0 ? void 0 : E.replaceTrack(u.processor.processedTrack);
          } catch (M) {
            m = {
              error: M
            };
          } finally {
            try {
              !x && !c && (g = O.return) && (yield g.call(O));
            } finally {
              if (m)
                throw m.error;
            }
          }
      }();
    });
  }
  setDegradationPreference(t) {
    return G(this, void 0, void 0, function* () {
      if (this.degradationPreference = t, this.sender)
        try {
          this.log.debug("setting degradationPreference to ".concat(t), this.logContext);
          const i = this.sender.getParameters();
          i.degradationPreference = t, this.sender.setParameters(i);
        } catch (i) {
          this.log.warn("failed to set degradationPreference", Object.assign({
            error: i
          }, this.logContext));
        }
    });
  }
  addSimulcastTrack(t, i) {
    if (this.simulcastCodecs.has(t)) {
      this.log.error("".concat(t, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const o = {
      codec: t,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: i
    };
    return this.simulcastCodecs.set(t, o), o;
  }
  setSimulcastTrackSender(t, i) {
    const o = this.simulcastCodecs.get(t);
    o && (o.sender = i, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, vF));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(t) {
    return G(this, void 0, void 0, function* () {
      var i, o, u, d, c, m, g;
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: t,
        currentCodec: this.codec
      })), !this.codec && t.length > 0)
        return yield this.setPublishingLayers(t[0].qualities), [];
      this.subscribedCodecs = t;
      const b = [];
      try {
        for (i = !0, o = Ap(t); u = yield o.next(), d = u.done, !d; i = !0) {
          g = u.value, i = !1;
          const C = g;
          if (!this.codec || this.codec === C.codec)
            yield this.setPublishingLayers(C.qualities);
          else {
            const E = this.simulcastCodecs.get(C.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(C.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: E
            })), !E || !E.sender) {
              for (const x of C.qualities)
                if (x.enabled) {
                  b.push(C.codec);
                  break;
                }
            } else
              E.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(C.codec), this.logContext), yield Ox(E.sender, E.encodings, C.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (C) {
        c = {
          error: C
        };
      } finally {
        try {
          !i && !d && (m = o.return) && (yield m.call(o));
        } finally {
          if (c)
            throw c.error;
        }
      }
      return b;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(t) {
    return G(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: t
      })), !(!this.sender || !this.encodings) && (yield Ox(this.sender, this.encodings, t, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const t = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return G(this, void 0, void 0, function* () {
      yield t.handleAppVisibilityChanged.call(this), VD() && this.isInBackground && this.source === ue.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function Ox(r, t, i, o, u, d) {
  return G(this, void 0, void 0, function* () {
    const c = yield o.lock();
    u.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, d), {
      sender: r,
      qualities: i,
      senderEncodings: t
    }));
    try {
      const m = r.getParameters(), {
        encodings: g
      } = m;
      if (!g)
        return;
      if (g.length !== t.length) {
        u.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, d), {
          encodings: g,
          senderEncodings: t
        }));
        return;
      }
      let b = !1;
      !1 && g[0].scalabilityMode || g.forEach((E, x) => {
        var O;
        let N = (O = E.rid) !== null && O !== void 0 ? O : "";
        N === "" && (N = "q");
        const M = KD(N), I = i.find((U) => U.quality === M);
        I && E.active !== I.enabled && (b = !0, E.active = I.enabled, u.debug("setting layer ".concat(I.quality, " to ").concat(E.active ? "enabled" : "disabled"), d), Kp() && (I.enabled ? (E.scaleResolutionDownBy = t[x].scaleResolutionDownBy, E.maxBitrate = t[x].maxBitrate, E.maxFrameRate = t[x].maxFrameRate) : (E.scaleResolutionDownBy = 4, E.maxBitrate = 10, E.maxFrameRate = 2)));
      }), b && (m.encodings = g, u.debug("setting encodings", Object.assign(Object.assign({}, d), {
        encodings: m.encodings
      })), yield r.setParameters(m));
    } finally {
      c();
    }
  });
}
function KD(r) {
  switch (r) {
    case "f":
      return To.HIGH;
    case "h":
      return To.MEDIUM;
    case "q":
      return To.LOW;
    default:
      return To.HIGH;
  }
}
function Mx(r, t, i, o) {
  if (!i)
    return [new Md({
      quality: To.HIGH,
      width: r,
      height: t,
      bitrate: 0,
      ssrc: 0
    })];
  if (o) {
    const u = i[0].scalabilityMode, d = new YD(u), c = [], m = d.suffix == "h" ? 1.5 : 2, g = d.suffix == "h" ? 2 : 3;
    for (let b = 0; b < d.spatial; b += 1)
      c.push(new Md({
        quality: Math.min(To.HIGH, d.spatial - 1) - b,
        width: Math.ceil(r / Math.pow(m, b)),
        height: Math.ceil(t / Math.pow(m, b)),
        bitrate: i[0].maxBitrate ? Math.ceil(i[0].maxBitrate / Math.pow(g, b)) : 0,
        ssrc: 0
      }));
    return c;
  }
  return i.map((u) => {
    var d, c, m;
    const g = (d = u.scaleResolutionDownBy) !== null && d !== void 0 ? d : 1;
    let b = KD((c = u.rid) !== null && c !== void 0 ? c : "");
    return new Md({
      quality: b,
      width: Math.ceil(r / g),
      height: Math.ceil(t / g),
      bitrate: (m = u.maxBitrate) !== null && m !== void 0 ? m : 0,
      ssrc: 0
    });
  });
}
const Nx = "_lossy", Lx = "_reliable", gF = 2 * 1e3, hT = "leave-reconnect";
var rs;
(function(r) {
  r[r.New = 0] = "New", r[r.Connected = 1] = "Connected", r[r.Disconnected = 2] = "Disconnected", r[r.Reconnecting = 3] = "Reconnecting", r[r.Closed = 4] = "Closed";
})(rs || (rs = {}));
class yF extends rl.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(t) {
    var i;
    super(), this.options = t, this.rtcConfig = {}, this.peerConnectionTimeout = xE.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = rs.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = Wt, this.handleDataChannel = (o) => G(this, [o], void 0, function(u) {
      var d = this;
      let {
        channel: c
      } = u;
      return function* () {
        if (c) {
          if (c.label === Lx)
            d.reliableDCSub = c;
          else if (c.label === Nx)
            d.lossyDCSub = c;
          else
            return;
          d.log.debug("on data channel ".concat(c.id, ", ").concat(c.label), d.logContext), c.onmessage = d.handleDataMessage;
        }
      }();
    }), this.handleDataMessage = (o) => G(this, void 0, void 0, function* () {
      var u, d;
      const c = yield this.dataProcessLock.lock();
      try {
        let m;
        if (o.data instanceof ArrayBuffer)
          m = o.data;
        else if (o.data instanceof Blob)
          m = yield o.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: o.data
          }));
          return;
        }
        const g = pc.fromBinary(new Uint8Array(m));
        ((u = g.value) === null || u === void 0 ? void 0 : u.case) === "speaker" ? this.emit(qe.ActiveSpeakersUpdate, g.value.value.speakers) : (((d = g.value) === null || d === void 0 ? void 0 : d.case) === "user" && SF(g, g.value.value), this.emit(qe.DataPacketReceived, g));
      } finally {
        c();
      }
    }), this.handleDataError = (o) => {
      const d = o.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (o instanceof ErrorEvent && o.error) {
        const {
          error: c
        } = o.error;
        this.log.error("DataChannel error on ".concat(d, ": ").concat(o.message), Object.assign(Object.assign({}, this.logContext), {
          error: c
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(d), Object.assign(Object.assign({}, this.logContext), {
          event: o
        }));
    }, this.handleBufferedAmountLow = (o) => {
      const d = o.currentTarget.maxRetransmits === 0 ? zn.LOSSY : zn.RELIABLE;
      this.updateAndEmitDCBufferStatus(d);
    }, this.handleDisconnect = (o, u) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(o, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const d = (g) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(g, "ms. giving up"), this.logContext), this.emit(qe.Disconnected), this.close();
      }, c = Date.now() - this.reconnectStart;
      let m = this.getNextRetryDelay({
        elapsedMs: c,
        retryCount: this.reconnectAttempts
      });
      if (m === null) {
        d(c);
        return;
      }
      o === hT && (m = 0), this.log.debug("reconnecting in ".concat(m, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = gi.setTimeout(() => this.attemptReconnect(u).finally(() => this.reconnectTimeout = void 0), m);
    }, this.waitForRestarted = () => new Promise((o, u) => {
      this.pcState === rs.Connected && o();
      const d = () => {
        this.off(qe.Disconnected, c), o();
      }, c = () => {
        this.off(qe.Restarted, d), u();
      };
      this.once(qe.Restarted, d), this.once(qe.Disconnected, c);
    }), this.updateAndEmitDCBufferStatus = (o) => {
      const u = this.isBufferStatusLow(o);
      typeof u < "u" && u !== this.dcBufferStatus.get(o) && (this.dcBufferStatus.set(o, u), this.emit(qe.DCBufferStatusChanged, u, o));
    }, this.isBufferStatusLow = (o) => {
      const u = this.dataChannelForKind(o);
      if (u)
        return u.bufferedAmount <= u.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === Wn.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(Np.RR_SIGNAL_DISCONNECTED));
    }, this.log = Yl((i = t.loggerName) !== null && i !== void 0 ? i : cs.Engine), this.loggerOptions = {
      loggerName: t.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new RE(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Aa(), this.dataProcessLock = new Aa(), this.dcBufferStatus = /* @__PURE__ */ new Map([[zn.LOSSY, !0], [zn.RELIABLE, !0]]), this.client.onParticipantUpdate = (o) => this.emit(qe.ParticipantUpdate, o), this.client.onConnectionQuality = (o) => this.emit(qe.ConnectionQualityUpdate, o), this.client.onRoomUpdate = (o) => this.emit(qe.RoomUpdate, o), this.client.onSubscriptionError = (o) => this.emit(qe.SubscriptionError, o), this.client.onSubscriptionPermissionUpdate = (o) => this.emit(qe.SubscriptionPermissionUpdate, o), this.client.onSpeakersChanged = (o) => this.emit(qe.SpeakersChanged, o), this.client.onStreamStateUpdate = (o) => this.emit(qe.StreamStateChanged, o), this.client.onRequestResponse = (o) => this.emit(qe.SignalRequestResponse, o);
  }
  /** @internal */
  get logContext() {
    var t, i, o, u, d, c, m, g;
    return {
      room: (i = (t = this.latestJoinResponse) === null || t === void 0 ? void 0 : t.room) === null || i === void 0 ? void 0 : i.name,
      roomID: (u = (o = this.latestJoinResponse) === null || o === void 0 ? void 0 : o.room) === null || u === void 0 ? void 0 : u.sid,
      participant: (c = (d = this.latestJoinResponse) === null || d === void 0 ? void 0 : d.participant) === null || c === void 0 ? void 0 : c.identity,
      pID: (g = (m = this.latestJoinResponse) === null || m === void 0 ? void 0 : m.participant) === null || g === void 0 ? void 0 : g.sid
    };
  }
  join(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      this.url = t, this.token = i, this.signalOpts = o, this.maxJoinAttempts = o.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const d = yield this.client.join(t, i, o, u);
        return this._isClosed = !1, this.latestJoinResponse = d, this.subscriberPrimary = d.subscriberPrimary, this.pcManager || (yield this.configure(d)), (!this.subscriberPrimary || d.fastPublish) && this.negotiate(), this.clientConfiguration = d.clientConfiguration, d;
      } catch (d) {
        if (d instanceof xn && d.reason === nn.ServerUnreachable && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(t, i, o, u);
        throw d;
      }
    });
  }
  close() {
    return G(this, void 0, void 0, function* () {
      const t = yield this.closingLock.lock();
      if (this.isClosed) {
        t();
        return;
      }
      try {
        this._isClosed = !0, this.joinAttempts = 0, this.emit(qe.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        t();
      }
    });
  }
  cleanupPeerConnections() {
    return G(this, void 0, void 0, function* () {
      var t;
      yield (t = this.pcManager) === null || t === void 0 ? void 0 : t.close(), this.pcManager = void 0;
      const i = (o) => {
        o && (o.close(), o.onbufferedamountlow = null, o.onclose = null, o.onclosing = null, o.onerror = null, o.onmessage = null, o.onopen = null);
      };
      i(this.lossyDC), i(this.lossyDCSub), i(this.reliableDC), i(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return G(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(t) {
    if (this.pendingTrackResolvers[t.cid])
      throw new Gl("a track with the same ID has already been published");
    return new Promise((i, o) => {
      const u = setTimeout(() => {
        delete this.pendingTrackResolvers[t.cid], o(new xn("publication of local track timed out, no response from server", nn.InternalError));
      }, 1e4);
      this.pendingTrackResolvers[t.cid] = {
        resolve: (d) => {
          clearTimeout(u), i(d);
        },
        reject: () => {
          clearTimeout(u), o(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(t);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(t) {
    if (t.track && this.pendingTrackResolvers[t.track.id]) {
      const {
        reject: i
      } = this.pendingTrackResolvers[t.track.id];
      i && i(), delete this.pendingTrackResolvers[t.track.id];
    }
    try {
      return this.pcManager.removeTrack(t), !0;
    } catch (i) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: i
      }));
    }
    return !1;
  }
  updateMuteStatus(t, i) {
    this.client.sendMuteTrack(t, i);
  }
  get dataSubscriberReadyState() {
    var t;
    return (t = this.reliableDCSub) === null || t === void 0 ? void 0 : t.readyState;
  }
  getConnectedServerAddress() {
    return G(this, void 0, void 0, function* () {
      var t;
      return (t = this.pcManager) === null || t === void 0 ? void 0 : t.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(t) {
    this.regionUrlProvider = t;
  }
  configure(t) {
    return G(this, void 0, void 0, function* () {
      var i, o;
      if (this.pcManager && this.pcManager.currentState !== sr.NEW)
        return;
      this.participantSid = (i = t.participant) === null || i === void 0 ? void 0 : i.sid;
      const u = this.makeRTCConfiguration(t);
      this.pcManager = new aF(u, t.subscriberPrimary, this.loggerOptions), this.emit(qe.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (d, c) => {
        this.client.sendIceCandidate(d, c);
      }, this.pcManager.onPublisherOffer = (d) => {
        this.client.sendOffer(d);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (d, c, m) => G(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(d), this.logContext), ["closed", "disconnected", "failed"].includes(c) && (this.publisherConnectionPromise = void 0), d === sr.CONNECTED) {
          const C = this.pcState === rs.New;
          this.pcState = rs.Connected, C && this.emit(qe.Connected, t);
        } else
          d === sr.FAILED && this.pcState === rs.Connected && (this.pcState = rs.Disconnected, this.handleDisconnect("peerconnection failed", m === "failed" ? Np.RR_SUBSCRIBER_FAILED : Np.RR_PUBLISHER_FAILED));
        const g = this.client.isDisconnected || this.client.currentState === Wn.RECONNECTING, b = [sr.FAILED, sr.CLOSING, sr.CLOSED].includes(d);
        g && b && !this._isClosed && this.emit(qe.Offline);
      }), this.pcManager.onTrack = (d) => {
        this.emit(qe.MediaTrackAdded, d.track, d.streams[0], d.receiver);
      }, bF((o = t.serverInfo) === null || o === void 0 ? void 0 : o.protocol) || this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (t) => G(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: t.type
      })), yield this.pcManager.setPublisherAnswer(t));
    }), this.client.onTrickle = (t, i) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: t,
        target: i
      })), this.pcManager.addIceCandidate(t, i));
    }, this.client.onOffer = (t) => G(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const i = yield this.pcManager.createSubscriberAnswerFromOffer(t);
      this.client.sendAnswer(i);
    }), this.client.onLocalTrackPublished = (t) => {
      var i;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: t.cid,
        track: (i = t.track) === null || i === void 0 ? void 0 : i.sid
      })), !this.pendingTrackResolvers[t.cid]) {
        this.log.error("missing track resolver for ".concat(t.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: t.cid
        }));
        return;
      }
      const {
        resolve: o
      } = this.pendingTrackResolvers[t.cid];
      delete this.pendingTrackResolvers[t.cid], o(t.track);
    }, this.client.onLocalTrackUnpublished = (t) => {
      this.emit(qe.LocalTrackUnpublished, t);
    }, this.client.onLocalTrackSubscribed = (t) => {
      this.emit(qe.LocalTrackSubscribed, t);
    }, this.client.onTokenRefresh = (t) => {
      this.token = t;
    }, this.client.onRemoteMuteChanged = (t, i) => {
      this.emit(qe.RemoteMute, t, i);
    }, this.client.onSubscribedQualityUpdate = (t) => {
      this.emit(qe.SubscribedQualityUpdate, t);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", Np.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (t) => {
      switch (this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: t == null ? void 0 : t.reason
      })), t.regions && this.regionUrlProvider && (this.log.debug("updating regions", this.logContext), this.regionUrlProvider.setServerReportedRegions(t.regions)), t.action) {
        case jp.DISCONNECT:
          this.emit(qe.Disconnected, t == null ? void 0 : t.reason), this.close();
          break;
        case jp.RECONNECT:
          this.fullReconnectOnNext = !0, this.handleDisconnect(hT);
          break;
        case jp.RESUME:
          this.handleDisconnect(hT);
      }
    };
  }
  makeRTCConfiguration(t) {
    var i;
    const o = Object.assign({}, this.rtcConfig);
    if (!((i = this.signalOpts) === null || i === void 0) && i.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), o.encodedInsertableStreams = !0), t.iceServers && !o.iceServers) {
      const u = [];
      t.iceServers.forEach((d) => {
        const c = {
          urls: d.urls
        };
        d.username && (c.username = d.username), d.credential && (c.credential = d.credential), u.push(c);
      }), o.iceServers = u;
    }
    return t.clientConfiguration && t.clientConfiguration.forceRelay === Ev.ENABLED && (o.iceTransportPolicy = "relay"), o.sdpSemantics = "unified-plan", o.continualGatheringPolicy = "gather_continually", o;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(Nx, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(Lx, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  createSender(t, i, o) {
    return G(this, void 0, void 0, function* () {
      if ($T())
        return yield this.createTransceiverRTCRtpSender(t, i, o);
      if (qT())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(t.mediaStreamTrack);
      throw new zr("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      if ($T())
        return this.createSimulcastTransceiverSender(t, i, o, u);
      if (qT())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(t.mediaStreamTrack);
      throw new zr("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(t, i, o) {
    return G(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new zr("publisher is closed");
      const u = [];
      t.mediaStream && u.push(t.mediaStream), t instanceof Bi && (t.codec = i.videoCodec);
      const d = {
        direction: "sendonly",
        streams: u
      };
      return o && (d.sendEncodings = o), (yield this.pcManager.addPublisherTransceiver(t.mediaStreamTrack, d)).sender;
    });
  }
  createSimulcastTransceiverSender(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new zr("publisher is closed");
      const d = {
        direction: "sendonly"
      };
      u && (d.sendEncodings = u);
      const c = yield this.pcManager.addPublisherTransceiver(i.mediaStreamTrack, d);
      if (o.videoCodec)
        return t.setSimulcastTrackSender(o.videoCodec, c.sender), c.sender;
    });
  }
  createRTCRtpSender(t) {
    return G(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new zr("publisher is closed");
      return this.pcManager.addPublisherTrack(t);
    });
  }
  attemptReconnect(t) {
    return G(this, void 0, void 0, function* () {
      var i, o, u;
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          Wt.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((i = this.clientConfiguration) === null || i === void 0 ? void 0 : i.resumeConnection) === Ev.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((u = (o = this.pcManager) === null || o === void 0 ? void 0 : o.currentState) !== null && u !== void 0 ? u : sr.NEW) === sr.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(t), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (d) {
          this.reconnectAttempts += 1;
          let c = !0;
          d instanceof zr ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: d
          })), c = !1) : d instanceof Lp || (this.fullReconnectOnNext = !0), c ? this.handleDisconnect("reconnect", Np.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(qe.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(t) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(t);
    } catch (i) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: i
      }));
    }
    return null;
  }
  restartConnection(t) {
    return G(this, void 0, void 0, function* () {
      var i, o, u;
      try {
        if (!this.url || !this.token)
          throw new zr("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(qe.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let d;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new Lp();
          d = yield this.join(t ?? this.url, this.token, this.signalOpts);
        } catch (c) {
          throw c instanceof xn && c.reason === nn.NotAllowed ? new zr("could not reconnect, token might be expired") : new Lp();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(qe.SignalRestarted, d), yield this.waitForPCReconnected(), this.client.currentState !== Wn.CONNECTED)
          throw new Lp("Signal connection got severed during reconnect");
        (i = this.regionUrlProvider) === null || i === void 0 || i.resetAttempts(), this.emit(qe.Restarted);
      } catch (d) {
        const c = yield (o = this.regionUrlProvider) === null || o === void 0 ? void 0 : o.getNextBestRegionUrl();
        if (c) {
          yield this.restartConnection(c);
          return;
        } else
          throw (u = this.regionUrlProvider) === null || u === void 0 || u.resetAttempts(), d;
      }
    });
  }
  resumeConnection(t) {
    return G(this, void 0, void 0, function* () {
      var i;
      if (!this.url || !this.token)
        throw new zr("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new zr("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(qe.Resuming);
      let o;
      try {
        this.setupSignalClientCallbacks(), o = yield this.client.reconnect(this.url, this.token, this.participantSid, t);
      } catch (u) {
        let d = "";
        throw u instanceof Error && (d = u.message, this.log.error(u.message, Object.assign(Object.assign({}, this.logContext), {
          error: u
        }))), u instanceof xn && u.reason === nn.NotAllowed ? new zr("could not reconnect, token might be expired") : u instanceof xn && u.reason === nn.LeaveRequest ? u : new Lp(d);
      }
      if (this.emit(qe.SignalResumed), o) {
        const u = this.makeRTCConfiguration(o);
        this.pcManager.updateConfiguration(u);
      } else
        this.log.warn("Did not receive reconnect response", this.logContext);
      if (this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== Wn.CONNECTED)
        throw new Lp("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((i = this.reliableDC) === null || i === void 0 ? void 0 : i.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(qe.Resumed);
    });
  }
  waitForPCInitialConnection(t, i) {
    return G(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new zr("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(i, t);
    });
  }
  waitForPCReconnected() {
    return G(this, void 0, void 0, function* () {
      this.pcState = rs.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield us(gF), !this.pcManager)
          throw new zr("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = rs.Connected;
      } catch (t) {
        throw this.pcState = rs.Disconnected, new xn("could not establish PC connection, ".concat(t.message), nn.InternalError);
      }
    });
  }
  /* @internal */
  sendDataPacket(t, i) {
    return G(this, void 0, void 0, function* () {
      const o = t.toBinary();
      yield this.ensurePublisherConnected(i);
      const u = this.dataChannelForKind(i);
      u && u.send(o), this.updateAndEmitDCBufferStatus(i);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
      return function* () {
        var d;
        if (!o.pcManager)
          throw new zr("PC manager is closed");
        const c = u ? o.pcManager.subscriber : o.pcManager.publisher, m = u ? "Subscriber" : "Publisher";
        if (!c)
          throw new xn("".concat(m, " connection not set"), nn.InternalError);
        let g = !1;
        !u && !o.dataChannelForKind(i, u) && (o.createDataChannels(), g = !0), !g && !u && !o.pcManager.publisher.isICEConnected && o.pcManager.publisher.getICEConnectionState() !== "checking" && (g = !0), g && o.negotiate();
        const b = o.dataChannelForKind(i, u);
        if ((b == null ? void 0 : b.readyState) === "open")
          return;
        const C = (/* @__PURE__ */ new Date()).getTime() + o.peerConnectionTimeout;
        for (; (/* @__PURE__ */ new Date()).getTime() < C; ) {
          if (c.isICEConnected && ((d = o.dataChannelForKind(i, u)) === null || d === void 0 ? void 0 : d.readyState) === "open")
            return;
          yield us(50);
        }
        throw new xn("could not establish ".concat(m, " connection, state: ").concat(c.getICEConnectionState()), nn.InternalError);
      }();
    });
  }
  ensurePublisherConnected(t) {
    return G(this, void 0, void 0, function* () {
      this.publisherConnectionPromise || (this.publisherConnectionPromise = this.ensureDataTransportConnected(t, !1)), yield this.publisherConnectionPromise;
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== sr.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return G(this, void 0, void 0, function* () {
      return new Promise((t, i) => G(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          i(new zT("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher(), this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC && this.createDataChannels();
        const o = new AbortController(), u = () => {
          o.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), t();
        };
        this.isClosed && i("cannot negotiate on closed engine"), this.on(qe.Closing, u), this.pcManager.publisher.once(Bp.RTPVideoPayloadTypes, (d) => {
          const c = /* @__PURE__ */ new Map();
          d.forEach((m) => {
            const g = m.codec.toLowerCase();
            V3(g) && c.set(m.payload, g);
          }), this.emit(qe.RTPVideoMapUpdate, c);
        });
        try {
          yield this.pcManager.negotiate(o), t();
        } catch (d) {
          d instanceof zT && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", Np.RR_UNKNOWN), i(d);
        } finally {
          this.off(qe.Closing, u);
        }
      }));
    });
  }
  dataChannelForKind(t, i) {
    if (i) {
      if (t === zn.LOSSY)
        return this.lossyDCSub;
      if (t === zn.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (t === zn.LOSSY)
        return this.lossyDC;
      if (t === zn.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(t, i) {
    var o, u;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const d = this.pcManager.subscriber.getLocalDescription(), c = this.pcManager.subscriber.getRemoteDescription(), m = (u = (o = this.signalOpts) === null || o === void 0 ? void 0 : o.autoSubscribe) !== null && u !== void 0 ? u : !0, g = new Array(), b = new Array();
    t.forEach((C) => {
      C.isDesired !== m && g.push(C.trackSid), C.isEnabled || b.push(C.trackSid);
    }), this.client.sendSyncState(new nD({
      answer: d ? eb({
        sdp: d.sdp,
        type: d.type
      }) : void 0,
      offer: c ? eb({
        sdp: c.sdp,
        type: c.type
      }) : void 0,
      subscription: new fb({
        trackSids: g,
        subscribe: !m,
        participantTracks: []
      }),
      publishTracks: x3(i),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: b
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const t = [], i = (o, u) => {
      (o == null ? void 0 : o.id) !== void 0 && o.id !== null && t.push(new rD({
        label: o.label,
        id: o.id,
        target: u
      }));
    };
    return i(this.dataChannelForKind(zn.LOSSY), ss.PUBLISHER), i(this.dataChannelForKind(zn.RELIABLE), ss.PUBLISHER), i(this.dataChannelForKind(zn.LOSSY, !0), ss.SUBSCRIBER), i(this.dataChannelForKind(zn.RELIABLE, !0), ss.SUBSCRIBER), t;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && gi.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    Ia() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    Ia() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class Lp extends Error {
}
function bF(r) {
  return r !== void 0 && r > 13;
}
function SF(r, t) {
  const i = r.participantIdentity ? r.participantIdentity : t.participantIdentity;
  r.participantIdentity = i, t.participantIdentity = i;
  const o = r.destinationIdentities.length !== 0 ? r.destinationIdentities : t.destinationIdentities;
  r.destinationIdentities = o, t.destinationIdentities = o;
}
class Ax {
  constructor(t, i) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(t), this.token = i;
  }
  updateToken(t) {
    this.token = t;
  }
  isCloud() {
    return GT(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(t) {
    return G(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(t));
      const i = this.regionSettings.regions.filter((o) => !this.attemptedRegions.find((u) => u.url === o.url));
      if (i.length > 0) {
        const o = i[0];
        return this.attemptedRegions.push(o), Wt.debug("next region: ".concat(o.region)), o.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(t) {
    return G(this, void 0, void 0, function* () {
      const i = yield fetch("".concat(CF(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: t
      });
      if (i.ok) {
        const o = yield i.json();
        return this.lastUpdateAt = Date.now(), o;
      } else
        throw new xn("Could not fetch region settings: ".concat(i.statusText), i.status === 401 ? nn.NotAllowed : nn.InternalError, i.status);
    });
  }
  setServerReportedRegions(t) {
    this.regionSettings = t, this.lastUpdateAt = Date.now();
  }
}
function CF(r) {
  return "".concat(r.protocol.replace("ws", "http"), "//").concat(r.host, "/settings");
}
class or extends Error {
  /**
   * Creates an error object with the given code and message, plus an optional data payload.
   *
   * If thrown in an RPC method handler, the error will be sent back to the caller.
   *
   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
   */
  constructor(t, i, o) {
    super(i), this.code = t, this.message = Ux(i, or.MAX_MESSAGE_BYTES), this.data = o ? Ux(o, or.MAX_DATA_BYTES) : void 0;
  }
  /**
   * @internal
   */
  static fromProto(t) {
    return new or(t.code, t.message, t.data);
  }
  /**
   * @internal
   */
  toProto() {
    return new HP({
      code: this.code,
      message: this.message,
      data: this.data
    });
  }
  /**
   * Creates an error object from the code, with an auto-populated message.
   *
   * @internal
   */
  static builtIn(t, i) {
    return new or(or.ErrorCode[t], or.ErrorMessage[t], i);
  }
}
or.MAX_MESSAGE_BYTES = 256;
or.MAX_DATA_BYTES = 15360;
or.ErrorCode = {
  APPLICATION_ERROR: 1500,
  CONNECTION_TIMEOUT: 1501,
  RESPONSE_TIMEOUT: 1502,
  RECIPIENT_DISCONNECTED: 1503,
  RESPONSE_PAYLOAD_TOO_LARGE: 1504,
  SEND_FAILED: 1505,
  UNSUPPORTED_METHOD: 1400,
  RECIPIENT_NOT_FOUND: 1401,
  REQUEST_PAYLOAD_TOO_LARGE: 1402,
  UNSUPPORTED_SERVER: 1403,
  UNSUPPORTED_VERSION: 1404
};
or.ErrorMessage = {
  APPLICATION_ERROR: "Application error in method handler",
  CONNECTION_TIMEOUT: "Connection timeout",
  RESPONSE_TIMEOUT: "Response timeout",
  RECIPIENT_DISCONNECTED: "Recipient disconnected",
  RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
  SEND_FAILED: "Failed to send",
  UNSUPPORTED_METHOD: "Method not supported at destination",
  RECIPIENT_NOT_FOUND: "Recipient not found",
  REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
  UNSUPPORTED_SERVER: "RPC not supported by server",
  UNSUPPORTED_VERSION: "Unsupported RPC version"
};
const Ix = 15360;
function JT(r) {
  return new TextEncoder().encode(r).length;
}
function Ux(r, t) {
  if (JT(r) <= t)
    return r;
  let i = 0, o = r.length;
  const u = new TextEncoder();
  for (; i < o; ) {
    const d = Math.floor((i + o + 1) / 2);
    u.encode(r.slice(0, d)).length <= t ? i = d : o = d - 1;
  }
  return r.slice(0, i);
}
class QD extends ue {
  constructor(t, i, o, u, d) {
    super(t, o, d), this.sid = i, this.receiver = u;
  }
  /** @internal */
  setMuted(t) {
    this.isMuted !== t && (this.isMuted = t, this._mediaStreamTrack.enabled = !t, this.emit(t ? Le.Muted : Le.Unmuted, this));
  }
  /** @internal */
  setMediaStream(t) {
    this.mediaStream = t;
    const i = (o) => {
      o.track === this._mediaStreamTrack && (t.removeEventListener("removetrack", i), this.receiver && "playoutDelayHint" in this.receiver && (this.receiver.playoutDelayHint = void 0), this.receiver = void 0, this._currentBitrate = 0, this.emit(Le.Ended, this));
    };
    t.addEventListener("removetrack", i);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    return G(this, void 0, void 0, function* () {
      var t;
      return !((t = this.receiver) === null || t === void 0) && t.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /**
   * Allows to set a playout delay (in seconds) for this track.
   * A higher value allows for more buffering of the track in the browser
   * and will result in a delay of media being played back of `delayInSeconds`
   */
  setPlayoutDelay(t) {
    this.receiver ? "playoutDelayHint" in this.receiver ? this.receiver.playoutDelayHint = t : this.log.warn("Playout delay not supported in this browser") : this.log.warn("Cannot set playout delay, track already ended");
  }
  /**
   * Returns the current playout delay (in seconds) of this track.
   */
  getPlayoutDelay() {
    if (this.receiver) {
      if ("playoutDelayHint" in this.receiver)
        return this.receiver.playoutDelayHint;
      this.log.warn("Playout delay not supported in this browser");
    } else
      this.log.warn("Cannot get playout delay, track already ended");
    return 0;
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), PE)), P3() && this.registerTimeSyncUpdate();
  }
  registerTimeSyncUpdate() {
    const t = () => {
      var i;
      this.timeSyncHandle = requestAnimationFrame(() => t());
      const o = (i = this.receiver) === null || i === void 0 ? void 0 : i.getSynchronizationSources()[0];
      if (o) {
        const {
          timestamp: u,
          rtpTimestamp: d
        } = o;
        d && this.rtpTimestamp !== d && (this.emit(Le.TimeSyncUpdate, {
          timestamp: u,
          rtpTimestamp: d
        }), this.rtpTimestamp = d);
      }
    };
    t();
  }
}
class Hp extends QD {
  constructor(t, i, o, u, d, c) {
    super(t, i, ue.Kind.Audio, o, c), this.monitorReceiver = () => G(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const m = yield this.getReceiverStats();
      m && this.prevStats && this.receiver && (this._currentBitrate = gb(m, this.prevStats)), this.prevStats = m;
    }), this.audioContext = u, this.webAudioPluginNodes = [], d && (this.sinkId = d.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(t) {
    var i;
    for (const o of this.attachedElements)
      this.audioContext ? (i = this.gainNode) === null || i === void 0 || i.gain.setTargetAtTime(t, 0, 0.1) : o.volume = t;
    Kl() && this._mediaStreamTrack._setVolume(t), this.elementVolume = t;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (Kl())
      return 1;
    let t = 0;
    return this.attachedElements.forEach((i) => {
      i.volume > t && (t = i.volume);
    }), t;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(t) {
    return G(this, void 0, void 0, function* () {
      this.sinkId = t, yield Promise.all(this.attachedElements.map((i) => {
        if (WT(i))
          return i.setSinkId(t);
      }));
    });
  }
  attach(t) {
    const i = this.attachedElements.length === 0;
    return t ? super.attach(t) : t = super.attach(), this.sinkId && WT(t) && t.setSinkId(this.sinkId), this.audioContext && i && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, t), t.volume = 0, t.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), t;
  }
  detach(t) {
    let i;
    return t ? (i = super.detach(t), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (i = super.detach(), this.disconnectWebAudio()), i;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(t) {
    this.audioContext = t, t && this.attachedElements.length > 0 ? this.connectWebAudio(t, this.attachedElements[0]) : t || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(t) {
    this.webAudioPluginNodes = t, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(t, i) {
    this.disconnectWebAudio(), this.sourceNode = t.createMediaStreamSource(i.srcObject);
    let o = this.sourceNode;
    this.webAudioPluginNodes.forEach((u) => {
      o.connect(u), o = u;
    }), this.gainNode = t.createGain(), o.connect(this.gainNode), this.gainNode.connect(t.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), t.state !== "running" && t.resume().then(() => {
      t.state !== "running" && this.emit(Le.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((u) => {
      this.emit(Le.AudioPlaybackFailed, u);
    });
  }
  disconnectWebAudio() {
    var t, i;
    (t = this.gainNode) === null || t === void 0 || t.disconnect(), (i = this.sourceNode) === null || i === void 0 || i.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return G(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const t = yield this.receiver.getStats();
      let i;
      return t.forEach((o) => {
        o.type === "inbound-rtp" && (i = {
          type: "audio",
          timestamp: o.timestamp,
          jitter: o.jitter,
          bytesReceived: o.bytesReceived,
          concealedSamples: o.concealedSamples,
          concealmentEvents: o.concealmentEvents,
          silentConcealedSamples: o.silentConcealedSamples,
          silentConcealmentEvents: o.silentConcealmentEvents,
          totalAudioEnergy: o.totalAudioEnergy,
          totalSamplesDuration: o.totalSamplesDuration
        });
      }), i;
    });
  }
}
const mT = 100;
class Tv extends QD {
  constructor(t, i, o, u, d) {
    super(t, i, ue.Kind.Video, o, d), this.elementInfos = [], this.monitorReceiver = () => G(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const c = yield this.getReceiverStats();
      c && this.prevStats && this.receiver && (this._currentBitrate = gb(c, this.prevStats)), this.prevStats = c;
    }), this.debouncedHandleResize = TE(() => {
      this.updateDimensions();
    }, mT), this.adaptiveStreamSettings = u;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(t) {
    super.setMuted(t), this.attachedElements.forEach((i) => {
      t ? Vp(this._mediaStreamTrack, i) : Fp(this._mediaStreamTrack, i);
    });
  }
  attach(t) {
    if (t ? super.attach(t) : t = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((i) => i.element === t) === void 0) {
      const i = new kF(t);
      this.observeElementInfo(i);
    }
    return t;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(t) {
    this.adaptiveStreamSettings && this.elementInfos.find((i) => i === t) === void 0 ? (t.handleResize = () => {
      this.debouncedHandleResize();
    }, t.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(t), t.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(t) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const i = this.elementInfos.filter((o) => o === t);
    for (const o of i)
      o.stopObserving();
    this.elementInfos = this.elementInfos.filter((o) => o !== t), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(t) {
    let i = [];
    if (t)
      return this.stopObservingElement(t), super.detach(t);
    i = super.detach();
    for (const o of i)
      this.stopObservingElement(o);
    return i;
  }
  /** @internal */
  getDecoderImplementation() {
    var t;
    return (t = this.prevStats) === null || t === void 0 ? void 0 : t.decoderImplementation;
  }
  getReceiverStats() {
    return G(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const t = yield this.receiver.getStats();
      let i, o = "", u = /* @__PURE__ */ new Map();
      return t.forEach((d) => {
        d.type === "inbound-rtp" ? (o = d.codecId, i = {
          type: "video",
          framesDecoded: d.framesDecoded,
          framesDropped: d.framesDropped,
          framesReceived: d.framesReceived,
          packetsReceived: d.packetsReceived,
          packetsLost: d.packetsLost,
          frameWidth: d.frameWidth,
          frameHeight: d.frameHeight,
          pliCount: d.pliCount,
          firCount: d.firCount,
          nackCount: d.nackCount,
          jitter: d.jitter,
          timestamp: d.timestamp,
          bytesReceived: d.bytesReceived,
          decoderImplementation: d.decoderImplementation
        }) : d.type === "codec" && u.set(d.id, d);
      }), i && o !== "" && u.get(o) && (i.mimeType = u.get(o).mimeType), i;
    });
  }
  stopObservingElement(t) {
    const i = this.elementInfos.filter((o) => o.element === t);
    for (const o of i)
      this.stopObservingElementInfo(o);
  }
  handleAppVisibilityChanged() {
    const t = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return G(this, void 0, void 0, function* () {
      yield t.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var t, i;
    const o = this.elementInfos.reduce((m, g) => Math.max(m, g.visibilityChangedAt || 0), 0), u = !((i = (t = this.adaptiveStreamSettings) === null || t === void 0 ? void 0 : t.pauseVideoInBackground) !== null && i !== void 0) || i ? this.isInBackground : !1, d = this.elementInfos.some((m) => m.pictureInPicture), c = this.elementInfos.some((m) => m.visible) && !u || d;
    if (this.lastVisible !== c) {
      if (!c && Date.now() - o < mT) {
        gi.setTimeout(() => {
          this.updateVisibility();
        }, mT);
        return;
      }
      this.lastVisible = c, this.emit(Le.VisibilityChanged, c, this);
    }
  }
  updateDimensions() {
    var t, i;
    let o = 0, u = 0;
    const d = this.getPixelDensity();
    for (const c of this.elementInfos) {
      const m = c.width() * d, g = c.height() * d;
      m + g > o + u && (o = m, u = g);
    }
    ((t = this.lastDimensions) === null || t === void 0 ? void 0 : t.width) === o && ((i = this.lastDimensions) === null || i === void 0 ? void 0 : i.height) === u || (this.lastDimensions = {
      width: o,
      height: u
    }, this.emit(Le.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var t;
    const i = (t = this.adaptiveStreamSettings) === null || t === void 0 ? void 0 : t.pixelDensity;
    return i === "screen" ? mx() : i || (mx() > 2 ? 2 : 1);
  }
}
class kF {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(t, i) {
    this.onVisibilityChanged = (o) => {
      var u;
      const {
        target: d,
        isIntersecting: c
      } = o;
      d === this.element && (this.isIntersecting = c, this.isPiP = hv(this.element), this.visibilityChangedAt = Date.now(), (u = this.handleVisibilityChanged) === null || u === void 0 || u.call(this));
    }, this.onEnterPiP = () => {
      var o, u, d;
      (u = (o = window.documentPictureInPicture) === null || o === void 0 ? void 0 : o.window) === null || u === void 0 || u.addEventListener("pagehide", this.onLeavePiP), this.isPiP = hv(this.element), (d = this.handleVisibilityChanged) === null || d === void 0 || d.call(this);
    }, this.onLeavePiP = () => {
      var o;
      this.isPiP = hv(this.element), (o = this.handleVisibilityChanged) === null || o === void 0 || o.call(this);
    }, this.element = t, this.isIntersecting = i ?? XT(t), this.isPiP = Ia() && hv(t), this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    var t, i, o;
    this.isIntersecting = XT(this.element), this.isPiP = hv(this.element), this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, gx().observe(this.element), vx().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP), (t = window.documentPictureInPicture) === null || t === void 0 || t.addEventListener("enter", this.onEnterPiP), (o = (i = window.documentPictureInPicture) === null || i === void 0 ? void 0 : i.window) === null || o === void 0 || o.addEventListener("pagehide", this.onLeavePiP);
  }
  stopObserving() {
    var t, i, o, u, d;
    (t = gx()) === null || t === void 0 || t.unobserve(this.element), (i = vx()) === null || i === void 0 || i.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP), (o = window.documentPictureInPicture) === null || o === void 0 || o.removeEventListener("enter", this.onEnterPiP), (d = (u = window.documentPictureInPicture) === null || u === void 0 ? void 0 : u.window) === null || d === void 0 || d.removeEventListener("pagehide", this.onLeavePiP);
  }
}
function hv(r) {
  var t, i;
  return document.pictureInPictureElement === r ? !0 : !((t = window.documentPictureInPicture) === null || t === void 0) && t.window ? XT(r, (i = window.documentPictureInPicture) === null || i === void 0 ? void 0 : i.window) : !1;
}
function XT(r, t) {
  const i = t || window;
  let o = r.offsetTop, u = r.offsetLeft;
  const d = r.offsetWidth, c = r.offsetHeight, {
    hidden: m
  } = r, {
    display: g
  } = getComputedStyle(r);
  for (; r.offsetParent; )
    r = r.offsetParent, o += r.offsetTop, u += r.offsetLeft;
  return o < i.pageYOffset + i.innerHeight && u < i.pageXOffset + i.innerWidth && o + c > i.pageYOffset && u + d > i.pageXOffset && !m && g !== "none";
}
class mc extends rl.EventEmitter {
  constructor(t, i, o, u) {
    var d;
    super(), this.metadataMuted = !1, this.encryption = Ja.NONE, this.log = Wt, this.handleMuted = () => {
      this.emit(Le.Muted);
    }, this.handleUnmuted = () => {
      this.emit(Le.Unmuted);
    }, this.log = Yl((d = u == null ? void 0 : u.loggerName) !== null && d !== void 0 ? d : cs.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = t, this.trackSid = i, this.trackName = o, this.source = ue.Source.Unknown;
  }
  /** @internal */
  setTrack(t) {
    this.track && (this.track.off(Le.Muted, this.handleMuted), this.track.off(Le.Unmuted, this.handleUnmuted)), this.track = t, t && (t.on(Le.Muted, this.handleMuted), t.on(Le.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var t;
    return Object.assign(Object.assign({}, (t = this.loggerContextCb) === null || t === void 0 ? void 0 : t.call(this)), _n(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Ja.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof vi || this.track instanceof Hp)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof Bi || this.track instanceof Tv)
      return this.track;
  }
  /** @internal */
  updateInfo(t) {
    this.trackSid = t.sid, this.trackName = t.name, this.source = ue.sourceFromProto(t.source), this.mimeType = t.mimeType, this.kind === ue.Kind.Video && t.width > 0 && (this.dimensions = {
      width: t.width,
      height: t.height
    }, this.simulcasted = t.simulcast), this.encryption = t.encryption, this.trackInfo = t, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: t
    }));
  }
}
(function(r) {
  (function(t) {
    t.Desired = "desired", t.Subscribed = "subscribed", t.Unsubscribed = "unsubscribed";
  })(r.SubscriptionStatus || (r.SubscriptionStatus = {})), function(t) {
    t.Allowed = "allowed", t.NotAllowed = "not_allowed";
  }(r.PermissionStatus || (r.PermissionStatus = {}));
})(mc);
class _v extends mc {
  get isUpstreamPaused() {
    var t;
    return (t = this.track) === null || t === void 0 ? void 0 : t.isUpstreamPaused;
  }
  constructor(t, i, o, u) {
    super(t, i.sid, i.name, u), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(Le.Ended);
    }, this.updateInfo(i), this.setTrack(o);
  }
  setTrack(t) {
    this.track && this.track.off(Le.Ended, this.handleTrackEnded), super.setTrack(t), t && t.on(Le.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    return G(this, void 0, void 0, function* () {
      var t;
      return (t = this.track) === null || t === void 0 ? void 0 : t.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    return G(this, void 0, void 0, function* () {
      var t;
      return (t = this.track) === null || t === void 0 ? void 0 : t.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    return G(this, void 0, void 0, function* () {
      var t;
      yield (t = this.track) === null || t === void 0 ? void 0 : t.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    return G(this, void 0, void 0, function* () {
      var t;
      yield (t = this.track) === null || t === void 0 ? void 0 : t.resumeUpstream();
    });
  }
  getTrackFeatures() {
    var t;
    if (this.track instanceof vi) {
      const i = this.track.getSourceTrackSettings(), o = /* @__PURE__ */ new Set();
      return i.autoGainControl && o.add(el.TF_AUTO_GAIN_CONTROL), i.echoCancellation && o.add(el.TF_ECHO_CANCELLATION), i.noiseSuppression && o.add(el.TF_NOISE_SUPPRESSION), i.channelCount && i.channelCount > 1 && o.add(el.TF_STEREO), !((t = this.options) === null || t === void 0) && t.dtx || o.add(el.TF_NO_DTX), this.track.enhancedNoiseCancellation && o.add(el.TF_ENHANCED_NOISE_CANCELLATION), Array.from(o.values());
    } else
      return [];
  }
}
var ko;
(function(r) {
  r.Excellent = "excellent", r.Good = "good", r.Poor = "poor", r.Lost = "lost", r.Unknown = "unknown";
})(ko || (ko = {}));
function TF(r) {
  switch (r) {
    case gv.EXCELLENT:
      return ko.Excellent;
    case gv.GOOD:
      return ko.Good;
    case gv.POOR:
      return ko.Poor;
    case gv.LOST:
      return ko.Lost;
    default:
      return ko.Unknown;
  }
}
class JD extends rl.EventEmitter {
  get logContext() {
    var t, i;
    return Object.assign({}, (i = (t = this.loggerOptions) === null || t === void 0 ? void 0 : t.loggerContextCb) === null || i === void 0 ? void 0 : i.call(t));
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((t) => t.isEncrypted);
  }
  get isAgent() {
    var t;
    return ((t = this.permissions) === null || t === void 0 ? void 0 : t.agent) || this.kind === Z0.AGENT;
  }
  get kind() {
    return this._kind;
  }
  /** participant attributes, similar to metadata, but as a key/value map */
  get attributes() {
    return Object.freeze(Object.assign({}, this._attributes));
  }
  /** @internal */
  constructor(t, i, o, u, d, c) {
    let m = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Z0.STANDARD;
    var g;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ko.Unknown, this.log = Wt, this.log = Yl((g = c == null ? void 0 : c.loggerName) !== null && g !== void 0 ? g : cs.Participant), this.loggerOptions = c, this.setMaxListeners(100), this.sid = t, this.identity = i, this.name = o, this.metadata = u, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this._kind = m, this._attributes = d ?? {};
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(t) {
    for (const [, i] of this.trackPublications)
      if (i.source === t)
        return i;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(t) {
    for (const [, i] of this.trackPublications)
      if (i.trackName === t)
        return i;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var t;
    const i = this.getTrackPublication(ue.Source.Camera);
    return !(!((t = i == null ? void 0 : i.isMuted) !== null && t !== void 0) || t);
  }
  get isMicrophoneEnabled() {
    var t;
    const i = this.getTrackPublication(ue.Source.Microphone);
    return !(!((t = i == null ? void 0 : i.isMuted) !== null && t !== void 0) || t);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(ue.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(t) {
    return this.participantInfo && this.participantInfo.sid === t.sid && this.participantInfo.version > t.version ? !1 : (this.identity = t.identity, this.sid = t.sid, this._setName(t.name), this._setMetadata(t.metadata), this._setAttributes(t.attributes), t.permission && this.setPermissions(t.permission), this.participantInfo = t, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: t
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(t) {
    const i = this.metadata !== t, o = this.metadata;
    this.metadata = t, i && this.emit(ce.ParticipantMetadataChanged, o);
  }
  _setName(t) {
    const i = this.name !== t;
    this.name = t, i && this.emit(ce.ParticipantNameChanged, t);
  }
  /**
   * Updates metadata from server
   **/
  _setAttributes(t) {
    const i = D3(this.attributes, t);
    this._attributes = t, Object.keys(i).length > 0 && this.emit(ce.AttributesChanged, i);
  }
  /** @internal */
  setPermissions(t) {
    var i, o, u, d, c, m;
    const g = this.permissions, b = t.canPublish !== ((i = this.permissions) === null || i === void 0 ? void 0 : i.canPublish) || t.canSubscribe !== ((o = this.permissions) === null || o === void 0 ? void 0 : o.canSubscribe) || t.canPublishData !== ((u = this.permissions) === null || u === void 0 ? void 0 : u.canPublishData) || t.hidden !== ((d = this.permissions) === null || d === void 0 ? void 0 : d.hidden) || t.recorder !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.recorder) || t.canPublishSources.length !== this.permissions.canPublishSources.length || t.canPublishSources.some((C, E) => {
      var x;
      return C !== ((x = this.permissions) === null || x === void 0 ? void 0 : x.canPublishSources[E]);
    }) || t.canSubscribeMetrics !== ((m = this.permissions) === null || m === void 0 ? void 0 : m.canSubscribeMetrics);
    return this.permissions = t, b && this.emit(ce.ParticipantPermissionsChanged, g), b;
  }
  /** @internal */
  setIsSpeaking(t) {
    t !== this.isSpeaking && (this.isSpeaking = t, t && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ce.IsSpeakingChanged, t));
  }
  /** @internal */
  setConnectionQuality(t) {
    const i = this._connectionQuality;
    this._connectionQuality = TF(t), i !== this._connectionQuality && this.emit(ce.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(t) {
    this.audioContext = t, this.audioTrackPublications.forEach((i) => (i.track instanceof Hp || i.track instanceof vi) && i.track.setAudioContext(t));
  }
  addTrackPublication(t) {
    t.on(Le.Muted, () => {
      this.emit(ce.TrackMuted, t);
    }), t.on(Le.Unmuted, () => {
      this.emit(ce.TrackUnmuted, t);
    });
    const i = t;
    switch (i.track && (i.track.sid = t.trackSid), this.trackPublications.set(t.trackSid, t), t.kind) {
      case ue.Kind.Audio:
        this.audioTrackPublications.set(t.trackSid, t);
        break;
      case ue.Kind.Video:
        this.videoTrackPublications.set(t.trackSid, t);
        break;
    }
  }
}
function EF(r) {
  var t, i, o;
  if (!r.participantSid && !r.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new eD({
    participantIdentity: (t = r.participantIdentity) !== null && t !== void 0 ? t : "",
    participantSid: (i = r.participantSid) !== null && i !== void 0 ? i : "",
    allTracks: (o = r.allowAll) !== null && o !== void 0 ? o : !1,
    trackSids: r.allowedTrackSids || []
  });
}
class Fx extends JD {
  /** @internal */
  constructor(t, i, o, u) {
    super(t, i, void 0, void 0, void 0, {
      loggerName: u.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Ja.NONE, this.enabledPublishVideoCodecs = [], this.rpcHandlers = /* @__PURE__ */ new Map(), this.pendingAcks = /* @__PURE__ */ new Map(), this.pendingResponses = /* @__PURE__ */ new Map(), this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new $D());
    }, this.handleReconnected = () => {
      var d, c;
      (c = (d = this.reconnectFuture) === null || d === void 0 ? void 0 : d.resolve) === null || c === void 0 || c.call(d), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var d, c;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((m) => this.log.warn(m.message, this.logContext)), (c = (d = this.reconnectFuture) === null || d === void 0 ? void 0 : d.reject) === null || c === void 0 || c.call(d, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.handleSignalRequestResponse = (d) => {
      const {
        requestId: c,
        reason: m,
        message: g
      } = d, b = this.pendingSignalRequests.get(c);
      b && (m !== aD.OK && b.reject(new dx(g, m)), this.pendingSignalRequests.delete(c));
    }, this.handleDataPacket = (d) => {
      switch (d.value.case) {
        case "rpcRequest":
          let c = d.value.value;
          this.handleIncomingRpcRequest(d.participantIdentity, c.id, c.method, c.payload, c.responseTimeoutMs, c.version);
          break;
        case "rpcResponse":
          let m = d.value.value, g = null, b = null;
          m.value.case === "payload" ? g = m.value.value : m.value.case === "error" && (b = or.fromProto(m.value.value)), this.handleIncomingRpcResponse(m.requestId, g, b);
          break;
        case "rpcAck":
          let C = d.value.value;
          this.handleIncomingRpcAck(C.requestId);
          break;
      }
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((d) => EF(d)));
    }, this.onTrackUnmuted = (d) => {
      this.onTrackMuted(d, d.isUpstreamPaused);
    }, this.onTrackMuted = (d, c) => {
      if (c === void 0 && (c = !0), !d.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), _n(d)));
        return;
      }
      this.engine.updateMuteStatus(d.sid, c);
    }, this.onTrackUpstreamPaused = (d) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), _n(d))), this.onTrackMuted(d, !0);
    }, this.onTrackUpstreamResumed = (d) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), _n(d))), this.onTrackMuted(d, d.isMuted);
    }, this.onTrackFeatureUpdate = (d) => {
      const c = this.audioTrackPublications.get(d.sid);
      if (!c) {
        this.log.warn("Could not update local audio track settings, missing publication for track ".concat(d.sid), this.logContext);
        return;
      }
      this.engine.client.sendUpdateLocalAudioTrack(c.trackSid, c.getTrackFeatures());
    }, this.handleSubscribedQualityUpdate = (d) => G(this, void 0, void 0, function* () {
      var c, m, g, b, C, E;
      if (!(!((C = this.roomOptions) === null || C === void 0) && C.dynacast))
        return;
      const x = this.videoTrackPublications.get(d.trackSid);
      if (!x) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: d.trackSid
        }));
        return;
      }
      if (d.subscribedCodecs.length > 0) {
        if (!x.videoTrack)
          return;
        const I = yield x.videoTrack.setPublishingCodecs(d.subscribedCodecs);
        try {
          for (var O = !0, N = Ap(I), M; M = yield N.next(), c = M.done, !c; O = !0) {
            b = M.value, O = !1;
            const U = b;
            T3(U) && (this.log.debug("publish ".concat(U, " for ").concat(x.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), _n(x))), yield this.publishAdditionalCodecForTrack(x.videoTrack, U, x.options));
          }
        } catch (U) {
          m = {
            error: U
          };
        } finally {
          try {
            !O && !c && (g = N.return) && (yield g.call(N));
          } finally {
            if (m)
              throw m.error;
          }
        }
      } else
        d.subscribedQualities.length > 0 && (yield (E = x.videoTrack) === null || E === void 0 ? void 0 : E.setPublishingLayers(d.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (d) => {
      const c = this.trackPublications.get(d.trackSid);
      if (!c) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: d.trackSid
        }));
        return;
      }
      this.unpublishTrack(c.track);
    }, this.handleTrackEnded = (d) => G(this, void 0, void 0, function* () {
      if (d.source === ue.Source.ScreenShare || d.source === ue.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), _n(d))), this.unpublishTrack(d);
      else if (d.isUserProvided)
        yield d.mute();
      else if (d instanceof vi || d instanceof Bi)
        try {
          if (Ia())
            try {
              const c = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: d.source === ue.Source.Camera ? "camera" : "microphone"
              });
              if (c && c.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(d.source), Object.assign(Object.assign({}, this.logContext), _n(d))), c.onchange = () => {
                  c.state !== "denied" && (d.isMuted || d.restartTrack(), c.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          d.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), _n(d))), d instanceof vi ? yield d.restartTrack({
            deviceId: "default"
          }) : yield d.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), _n(d))), yield d.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = o, this.roomOptions = u, this.setupEngine(o), this.activeDeviceMap = /* @__PURE__ */ new Map([["audioinput", "default"], ["videoinput", "default"], ["audiooutput", "default"]]), this.pendingSignalRequests = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Ja.NONE;
  }
  getTrackPublication(t) {
    const i = super.getTrackPublication(t);
    if (i)
      return i;
  }
  getTrackPublicationByName(t) {
    const i = super.getTrackPublicationByName(t);
    if (i)
      return i;
  }
  /**
   * @internal
   */
  setupEngine(t) {
    this.engine = t, this.engine.on(qe.RemoteMute, (i, o) => {
      const u = this.trackPublications.get(i);
      !u || !u.track || (o ? u.mute() : u.unmute());
    }), this.engine.on(qe.Connected, this.handleReconnected).on(qe.SignalRestarted, this.handleReconnected).on(qe.SignalResumed, this.handleReconnected).on(qe.Restarting, this.handleReconnecting).on(qe.Resuming, this.handleReconnecting).on(qe.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(qe.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(qe.Disconnected, this.handleDisconnected).on(qe.SignalRequestResponse, this.handleSignalRequestResponse).on(qe.DataPacketReceived, this.handleDataPacket);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * method will throw if the user doesn't have the required permissions
   * @param metadata
   */
  setMetadata(t) {
    return G(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        metadata: t
      });
    });
  }
  /**
   * Sets and updates the name of the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * method will throw if the user doesn't have the required permissions
   * @param metadata
   */
  setName(t) {
    return G(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        name: t
      });
    });
  }
  /**
   * Set or update participant attributes. It will make updates only to keys that
   * are present in `attributes`, and will not override others.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param attributes attributes to update
   */
  setAttributes(t) {
    return G(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        attributes: t
      });
    });
  }
  requestMetadataUpdate(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let {
        metadata: u,
        name: d,
        attributes: c
      } = i;
      return function* () {
        return new Promise((m, g) => G(o, void 0, void 0, function* () {
          var b, C;
          try {
            let E = !1;
            const x = yield this.engine.client.sendUpdateLocalMetadata((b = u ?? this.metadata) !== null && b !== void 0 ? b : "", (C = d ?? this.name) !== null && C !== void 0 ? C : "", c), O = performance.now();
            for (this.pendingSignalRequests.set(x, {
              resolve: m,
              reject: (N) => {
                g(N), E = !0;
              },
              values: {
                name: d,
                metadata: u,
                attributes: c
              }
            }); performance.now() - O < 5e3 && !E; ) {
              if ((!d || this.name === d) && (!u || this.metadata === u) && (!c || Object.entries(c).every((N) => {
                let [M, I] = N;
                return this.attributes[M] === I || I === "" && !this.attributes[M];
              }))) {
                this.pendingSignalRequests.delete(x), m();
                return;
              }
              yield us(50);
            }
            g(new dx("Request to update local metadata timed out", "TimeoutError"));
          } catch (E) {
            E instanceof Error && g(E);
          }
        }));
      }();
    });
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(t, i, o) {
    return this.setTrackEnabled(ue.Source.Camera, t, i, o);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(t, i, o) {
    return this.setTrackEnabled(ue.Source.Microphone, t, i, o);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(t, i, o) {
    return this.setTrackEnabled(ue.Source.ScreenShare, t, i, o);
  }
  /** @internal */
  setPermissions(t) {
    const i = this.permissions, o = super.setPermissions(t);
    return o && i && this.emit(ce.ParticipantPermissionsChanged, i), o;
  }
  /** @internal */
  setE2EEEnabled(t) {
    return G(this, void 0, void 0, function* () {
      this.encryptionType = t ? Ja.GCM : Ja.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      var d, c;
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: t,
        enabled: i
      })), this.republishPromise && (yield this.republishPromise);
      let m = this.getTrackPublication(t);
      if (i)
        if (m)
          yield m.unmute();
        else {
          let g;
          if (this.pendingPublishing.has(t)) {
            const b = yield this.waitForPendingPublicationOfSource(t);
            return b || this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
              source: t
            })), yield b == null ? void 0 : b.unmute(), b;
          }
          this.pendingPublishing.add(t);
          try {
            switch (t) {
              case ue.Source.Camera:
                g = yield this.createTracks({
                  video: (d = o) !== null && d !== void 0 ? d : !0
                });
                break;
              case ue.Source.Microphone:
                g = yield this.createTracks({
                  audio: (c = o) !== null && c !== void 0 ? c : !0
                });
                break;
              case ue.Source.ScreenShare:
                g = yield this.createScreenTracks(Object.assign({}, o));
                break;
              default:
                throw new Gl(t);
            }
          } catch (b) {
            throw g == null || g.forEach((C) => {
              C.stop();
            }), b instanceof Error && this.emit(ce.MediaDevicesError, b), b;
          }
          try {
            const b = [];
            for (const E of g)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), _n(E))), b.push(this.publishTrack(E, u));
            [m] = yield Promise.all(b);
          } catch (b) {
            throw g == null || g.forEach((C) => {
              C.stop();
            }), b;
          } finally {
            this.pendingPublishing.delete(t);
          }
        }
      else if (!(m != null && m.track) && this.pendingPublishing.has(t) && (m = yield this.waitForPendingPublicationOfSource(t), m || this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
        source: t
      }))), m && m.track)
        if (t === ue.Source.ScreenShare) {
          m = yield this.unpublishTrack(m.track);
          const g = this.getTrackPublication(ue.Source.ScreenShareAudio);
          g && g.track && this.unpublishTrack(g.track);
        } else
          yield m.mute();
      return m;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return G(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(ue.Source.Camera) || this.pendingPublishing.has(ue.Source.Microphone))) {
        this.pendingPublishing.add(ue.Source.Camera), this.pendingPublishing.add(ue.Source.Microphone);
        try {
          const t = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(t.map((i) => this.publishTrack(i)));
        } finally {
          this.pendingPublishing.delete(ue.Source.Camera), this.pendingPublishing.delete(ue.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(t) {
    return G(this, void 0, void 0, function* () {
      var i, o;
      t ?? (t = {});
      const {
        audioProcessor: u,
        videoProcessor: d,
        optionsWithoutProcessor: c
      } = wE(t), m = jD(c, (i = this.roomOptions) === null || i === void 0 ? void 0 : i.audioCaptureDefaults, (o = this.roomOptions) === null || o === void 0 ? void 0 : o.videoCaptureDefaults), g = vb(m);
      let b;
      try {
        b = yield navigator.mediaDevices.getUserMedia(g);
      } catch (C) {
        throw C instanceof Error && (g.audio && (this.microphoneError = C), g.video && (this.cameraError = C)), C;
      }
      return g.audio && (this.microphoneError = void 0, this.emit(ce.AudioStreamAcquired)), g.video && (this.cameraError = void 0), Promise.all(b.getTracks().map((C) => G(this, void 0, void 0, function* () {
        const E = C.kind === "audio";
        E ? m.audio : m.video;
        let x;
        const O = E ? g.audio : g.video;
        typeof O != "boolean" && (x = O);
        const N = GD(C, x, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return N.kind === ue.Kind.Video ? N.source = ue.Source.Camera : N.kind === ue.Kind.Audio && (N.source = ue.Source.Microphone, N.setAudioContext(this.audioContext)), N.mediaStream = b, N instanceof vi && u ? yield N.setProcessor(u) : N instanceof Bi && d && (yield N.setProcessor(d)), N;
      })));
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(t) {
    return G(this, void 0, void 0, function* () {
      if (t === void 0 && (t = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new mb("getDisplayMedia not supported");
      t.resolution === void 0 && !I3() && (t.resolution = EE.h1080fps30.resolution);
      const i = _3(t), o = yield navigator.mediaDevices.getDisplayMedia(i), u = o.getVideoTracks();
      if (u.length === 0)
        throw new Gl("no video track found");
      const d = new Bi(u[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      d.source = ue.Source.ScreenShare, t.contentHint && (d.mediaStreamTrack.contentHint = t.contentHint);
      const c = [d];
      if (o.getAudioTracks().length > 0) {
        this.emit(ce.AudioStreamAcquired);
        const m = new vi(o.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        m.source = ue.Source.ScreenShareAudio, c.push(m);
      }
      return c;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(t, i) {
    return G(this, void 0, void 0, function* () {
      return this.publishOrRepublishTrack(t, i);
    });
  }
  publishOrRepublishTrack(t, i) {
    return G(this, arguments, void 0, function(o, u) {
      var d = this;
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return function* () {
        var m, g, b, C;
        o instanceof vi && o.setAudioContext(d.audioContext), yield (m = d.reconnectFuture) === null || m === void 0 ? void 0 : m.promise, d.republishPromise && !c && (yield d.republishPromise), o instanceof Ld && d.pendingPublishPromises.has(o) && (yield d.pendingPublishPromises.get(o));
        let E;
        if (o instanceof MediaStreamTrack)
          E = o.getConstraints();
        else {
          E = o.constraints;
          let U;
          switch (o.source) {
            case ue.Source.Microphone:
              U = "audioinput";
              break;
            case ue.Source.Camera:
              U = "videoinput";
          }
          U && d.activeDeviceMap.has(U) && (E = Object.assign(Object.assign({}, E), {
            deviceId: d.activeDeviceMap.get(U)
          }));
        }
        if (o instanceof MediaStreamTrack)
          switch (o.kind) {
            case "audio":
              o = new vi(o, E, !0, d.audioContext, {
                loggerName: d.roomOptions.loggerName,
                loggerContextCb: () => d.logContext
              });
              break;
            case "video":
              o = new Bi(o, E, !0, {
                loggerName: d.roomOptions.loggerName,
                loggerContextCb: () => d.logContext
              });
              break;
            default:
              throw new Gl("unsupported MediaStreamTrack kind ".concat(o.kind));
          }
        else
          o.updateLoggerOptions({
            loggerName: d.roomOptions.loggerName,
            loggerContextCb: () => d.logContext
          });
        let x;
        if (d.trackPublications.forEach((U) => {
          U.track && U.track === o && (x = U);
        }), x)
          return d.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, d.logContext), _n(x))), x;
        const O = "channelCount" in o.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
        o.mediaStreamTrack.getSettings().channelCount === 2 || o.mediaStreamTrack.getConstraints().channelCount === 2, N = (g = u == null ? void 0 : u.forceStereo) !== null && g !== void 0 ? g : O;
        N && (u || (u = {}), u.dtx === void 0 && d.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, d.logContext), _n(o))), u.red === void 0 && d.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (b = u.dtx) !== null && b !== void 0 || (u.dtx = !1), (C = u.red) !== null && C !== void 0 || (u.red = !1));
        const M = Object.assign(Object.assign({}, d.roomOptions.publishDefaults), u);
        !U3() && d.roomOptions.e2ee && (d.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, d.logContext)), M.simulcast = !1), M.source && (o.source = M.source);
        const I = d.publish(o, M, N);
        d.pendingPublishPromises.set(o, I);
        try {
          return yield I;
        } catch (U) {
          throw U;
        } finally {
          d.pendingPublishPromises.delete(o);
        }
      }();
    });
  }
  publish(t, i, o) {
    return G(this, void 0, void 0, function* () {
      var u, d, c, m, g, b, C, E, x, O;
      Array.from(this.trackPublications.values()).find((F) => t instanceof Ld && F.source === t.source) && t.source !== ue.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(t.source), Object.assign(Object.assign({}, this.logContext), _n(t))), i.stopMicTrackOnMute && t instanceof vi && (t.stopOnMute = !0), t.source === ue.Source.ScreenShare && Kp() && (i.simulcast = !1), i.videoCodec === "av1" && !N3() && (i.videoCodec = void 0), i.videoCodec === "vp9" && !L3() && (i.videoCodec = void 0), i.videoCodec === void 0 && (i.videoCodec = YT), this.enabledPublishVideoCodecs.length > 0 && (this.enabledPublishVideoCodecs.some((F) => i.videoCodec === G0(F.mime)) || (i.videoCodec = G0(this.enabledPublishVideoCodecs[0].mime)));
      const M = i.videoCodec;
      t.on(Le.Muted, this.onTrackMuted), t.on(Le.Unmuted, this.onTrackUnmuted), t.on(Le.Ended, this.handleTrackEnded), t.on(Le.UpstreamPaused, this.onTrackUpstreamPaused), t.on(Le.UpstreamResumed, this.onTrackUpstreamResumed), t.on(Le.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
      const I = new OT({
        // get local track id for use during publishing
        cid: t.mediaStreamTrack.id,
        name: i.name,
        type: ue.kindToProto(t.kind),
        muted: t.isMuted,
        source: ue.sourceToProto(t.source),
        disableDtx: !(!((u = i.dtx) !== null && u !== void 0) || u),
        encryption: this.encryptionType,
        stereo: o,
        disableRed: this.isE2EEEnabled || !(!((d = i.red) !== null && d !== void 0) || d),
        stream: i == null ? void 0 : i.stream
      });
      let U;
      if (t.kind === ue.Kind.Video) {
        let F = {
          width: 0,
          height: 0
        };
        try {
          F = yield t.waitForDimensions();
        } catch {
          const te = (m = (c = this.roomOptions.videoCaptureDefaults) === null || c === void 0 ? void 0 : c.resolution) !== null && m !== void 0 ? m : as.h720.resolution;
          F = {
            width: te.width,
            height: te.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), _n(t)), {
            dims: F
          }));
        }
        I.width = F.width, I.height = F.height, t instanceof Bi && (Cv(M) && (t.source === ue.Source.ScreenShare && (i.scalabilityMode = "L1T3", "contentHint" in t.mediaStreamTrack && (t.mediaStreamTrack.contentHint = "motion", this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), _n(t))))), i.scalabilityMode = (g = i.scalabilityMode) !== null && g !== void 0 ? g : "L3T3_KEY"), I.simulcastCodecs = [new DT({
          codec: M,
          cid: t.mediaStreamTrack.id
        })], i.backupCodec === !0 && (i.backupCodec = {
          codec: YT
        }), i.backupCodec && M !== i.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        I.encryption === Ja.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), I.simulcastCodecs.push(new DT({
          codec: i.backupCodec.codec,
          cid: ""
        })))), U = QT(t.source === ue.Source.ScreenShare, I.width, I.height, i), I.layers = Mx(I.width, I.height, U, Cv(i.videoCodec));
      } else
        t.kind === ue.Kind.Audio && (U = [{
          maxBitrate: (b = i.audioPreset) === null || b === void 0 ? void 0 : b.maxBitrate,
          priority: (E = (C = i.audioPreset) === null || C === void 0 ? void 0 : C.priority) !== null && E !== void 0 ? E : "high",
          networkPriority: (O = (x = i.audioPreset) === null || x === void 0 ? void 0 : x.priority) !== null && O !== void 0 ? O : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new zr("cannot publish track when not connected");
      const ae = () => G(this, void 0, void 0, function* () {
        var F, K, te;
        if (!this.engine.pcManager)
          throw new zr("pcManager is not ready");
        if (t.sender = yield this.engine.createSender(t, i, U), t instanceof Bi && ((F = i.degradationPreference) !== null && F !== void 0 || (i.degradationPreference = mF(t)), t.setDegradationPreference(i.degradationPreference)), U)
          if (Kp() && t.kind === ue.Kind.Audio) {
            let he;
            for (const pe of this.engine.pcManager.publisher.getTransceivers())
              if (pe.sender === t.sender) {
                he = pe;
                break;
              }
            he && this.engine.pcManager.publisher.setTrackCodecBitrate({
              transceiver: he,
              codec: "opus",
              maxbr: !((K = U[0]) === null || K === void 0) && K.maxBitrate ? U[0].maxBitrate / 1e3 : 0
            });
          } else
            t.codec && Cv(t.codec) && (!((te = U[0]) === null || te === void 0) && te.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
              cid: I.cid,
              codec: t.codec,
              maxbr: U[0].maxBitrate / 1e3
            });
        yield this.engine.negotiate();
      });
      let Z;
      if (this.enabledPublishVideoCodecs.length > 0)
        Z = (yield Promise.all([this.engine.addTrack(I), ae()]))[0];
      else {
        Z = yield this.engine.addTrack(I);
        let F;
        if (Z.codecs.forEach((K) => {
          F === void 0 && (F = K.mimeType);
        }), F && t.kind === ue.Kind.Video) {
          const K = G0(F);
          K !== M && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), _n(t)), {
            codec: K
          })), i.videoCodec = K, U = QT(t.source === ue.Source.ScreenShare, I.width, I.height, i));
        }
        yield ae();
      }
      const B = new _v(t.kind, Z, t, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      return B.options = i, t.sid = Z.sid, this.log.debug("publishing ".concat(t.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: U,
        trackInfo: Z
      })), t instanceof Bi ? t.startMonitor(this.engine.client) : t instanceof vi && t.startMonitor(), this.addTrackPublication(B), this.emit(ce.LocalTrackPublished, B), B;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(t, i, o) {
    return G(this, void 0, void 0, function* () {
      var u;
      if (this.encryptionType !== Ja.NONE)
        return;
      let d;
      if (this.trackPublications.forEach((O) => {
        O.track && O.track === t && (d = O);
      }), !d)
        throw new Gl("track is not published");
      if (!(t instanceof Bi))
        throw new Gl("track is not a video track");
      const c = Object.assign(Object.assign({}, (u = this.roomOptions) === null || u === void 0 ? void 0 : u.publishDefaults), o), m = fF(t, i, c);
      if (!m) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), _n(t)));
        return;
      }
      const g = t.addSimulcastTrack(i, m);
      if (!g)
        return;
      const b = new OT({
        cid: g.mediaStreamTrack.id,
        type: ue.kindToProto(t.kind),
        muted: t.isMuted,
        source: ue.sourceToProto(t.source),
        sid: t.sid,
        simulcastCodecs: [{
          codec: c.videoCodec,
          cid: g.mediaStreamTrack.id
        }]
      });
      if (b.layers = Mx(b.width, b.height, m), !this.engine || this.engine.isClosed)
        throw new zr("cannot publish track when not connected");
      const C = () => G(this, void 0, void 0, function* () {
        yield this.engine.createSimulcastSender(t, g, c, m), yield this.engine.negotiate();
      }), x = (yield Promise.all([this.engine.addTrack(b), C()]))[0];
      this.log.debug("published ".concat(i, " for track ").concat(t.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: m,
        trackInfo: x
      }));
    });
  }
  unpublishTrack(t, i) {
    return G(this, void 0, void 0, function* () {
      var o, u;
      if (t instanceof Ld) {
        const b = this.pendingPublishPromises.get(t);
        b && (this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), _n(t))), yield b);
      }
      const d = this.getPublicationForTrack(t), c = d ? _n(d) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), c)), !d || !d.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), c));
        return;
      }
      t = d.track, t.off(Le.Muted, this.onTrackMuted), t.off(Le.Unmuted, this.onTrackUnmuted), t.off(Le.Ended, this.handleTrackEnded), t.off(Le.UpstreamPaused, this.onTrackUpstreamPaused), t.off(Le.UpstreamResumed, this.onTrackUpstreamResumed), t.off(Le.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate), i === void 0 && (i = (u = (o = this.roomOptions) === null || o === void 0 ? void 0 : o.stopLocalTrackOnUnpublish) !== null && u !== void 0 ? u : !0), i ? t.stop() : t.stopMonitor();
      let m = !1;
      const g = t.sender;
      if (t.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < sr.FAILED && g)
        try {
          for (const b of this.engine.pcManager.publisher.getTransceivers())
            b.sender === g && (b.direction = "inactive", m = !0);
          if (this.engine.removeTrack(g) && (m = !0), t instanceof Bi) {
            for (const [, b] of t.simulcastCodecs)
              b.sender && (this.engine.removeTrack(b.sender) && (m = !0), b.sender = void 0);
            t.simulcastCodecs.clear();
          }
        } catch (b) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), c), {
            error: b
          }));
        }
      switch (this.trackPublications.delete(d.trackSid), d.kind) {
        case ue.Kind.Audio:
          this.audioTrackPublications.delete(d.trackSid);
          break;
        case ue.Kind.Video:
          this.videoTrackPublications.delete(d.trackSid);
          break;
      }
      return this.emit(ce.LocalTrackUnpublished, d), d.setTrack(void 0), m && (yield this.engine.negotiate()), d;
    });
  }
  unpublishTracks(t) {
    return G(this, void 0, void 0, function* () {
      return (yield Promise.all(t.map((o) => this.unpublishTrack(o)))).filter((o) => o instanceof _v);
    });
  }
  republishAllTracks(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return function* () {
        o.republishPromise && (yield o.republishPromise), o.republishPromise = new Promise((d, c) => G(o, void 0, void 0, function* () {
          try {
            const m = [];
            this.trackPublications.forEach((g) => {
              g.track && (i && (g.options = Object.assign(Object.assign({}, g.options), i)), m.push(g));
            }), yield Promise.all(m.map((g) => G(this, void 0, void 0, function* () {
              const b = g.track;
              yield this.unpublishTrack(b, !1), u && !b.isMuted && b.source !== ue.Source.ScreenShare && b.source !== ue.Source.ScreenShareAudio && (b instanceof vi || b instanceof Bi) && !b.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                track: g.trackSid
              })), yield b.restartTrack()), yield this.publishOrRepublishTrack(b, g.options, !0);
            }))), d();
          } catch (m) {
            c(m);
          } finally {
            this.republishPromise = void 0;
          }
        })), yield o.republishPromise;
      }();
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return function* () {
        const d = u.reliable ? zn.RELIABLE : zn.LOSSY, c = u.destinationIdentities, m = u.topic, g = new pc({
          kind: d,
          value: {
            case: "user",
            value: new FP({
              participantIdentity: o.identity,
              payload: i,
              destinationIdentities: c,
              topic: m
            })
          }
        });
        yield o.engine.sendDataPacket(g, d);
      }();
    });
  }
  /**
   * Publish SIP DTMF message to the room.
   *
   * @param code DTMF code
   * @param digit DTMF digit
   */
  publishDtmf(t, i) {
    return G(this, void 0, void 0, function* () {
      const o = new pc({
        kind: zn.RELIABLE,
        value: {
          case: "sipDtmf",
          value: new jP({
            code: t,
            digit: i
          })
        }
      });
      yield this.engine.sendDataPacket(o, zn.RELIABLE);
    });
  }
  sendChatMessage(t) {
    return G(this, void 0, void 0, function* () {
      const i = {
        id: crypto.randomUUID(),
        message: t,
        timestamp: Date.now()
      }, o = new pc({
        value: {
          case: "chatMessage",
          value: new xT(Object.assign(Object.assign({}, i), {
            timestamp: Gn.parse(i.timestamp)
          }))
        }
      });
      return yield this.engine.sendDataPacket(o, zn.RELIABLE), this.emit(ce.ChatMessage, i), i;
    });
  }
  editChatMessage(t, i) {
    return G(this, void 0, void 0, function* () {
      const o = Object.assign(Object.assign({}, i), {
        message: t,
        editTimestamp: Date.now()
      }), u = new pc({
        value: {
          case: "chatMessage",
          value: new xT(Object.assign(Object.assign({}, o), {
            timestamp: Gn.parse(o.timestamp),
            editTimestamp: Gn.parse(o.editTimestamp)
          }))
        }
      });
      return yield this.engine.sendDataPacket(u, zn.RELIABLE), this.emit(ce.ChatMessage, o), o;
    });
  }
  /**
   * Initiate an RPC call to a remote participant
   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
   * @returns A promise that resolves with the response payload or rejects with an error.
   * @throws Error on failure. Details in `message`.
   */
  performRpc(t) {
    return G(this, arguments, void 0, function(i) {
      var o = this;
      let {
        destinationIdentity: u,
        method: d,
        payload: c,
        responseTimeout: m = 1e4
      } = i;
      return function* () {
        return new Promise((b, C) => G(o, void 0, void 0, function* () {
          var E, x, O, N;
          if (JT(c) > Ix) {
            C(or.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
            return;
          }
          if (!((x = (E = this.engine.latestJoinResponse) === null || E === void 0 ? void 0 : E.serverInfo) === null || x === void 0) && x.version && Ud((N = (O = this.engine.latestJoinResponse) === null || O === void 0 ? void 0 : O.serverInfo) === null || N === void 0 ? void 0 : N.version, "1.8.0") < 0) {
            C(or.builtIn("UNSUPPORTED_SERVER"));
            return;
          }
          const M = crypto.randomUUID();
          yield this.publishRpcRequest(u, M, d, c, m - 2e3);
          const I = setTimeout(() => {
            this.pendingAcks.delete(M), C(or.builtIn("CONNECTION_TIMEOUT")), this.pendingResponses.delete(M), clearTimeout(U);
          }, 2e3);
          this.pendingAcks.set(M, {
            resolve: () => {
              clearTimeout(I);
            },
            participantIdentity: u
          });
          const U = setTimeout(() => {
            this.pendingResponses.delete(M), C(or.builtIn("RESPONSE_TIMEOUT"));
          }, m);
          this.pendingResponses.set(M, {
            resolve: (ae, Z) => {
              clearTimeout(U), this.pendingAcks.has(M) && (console.warn("RPC response received before ack", M), this.pendingAcks.delete(M), clearTimeout(I)), Z ? C(Z) : b(ae ?? "");
            },
            participantIdentity: u
          });
        }));
      }();
    });
  }
  /**
   * Establishes the participant as a receiver for calls of the specified RPC method.
   * Will overwrite any existing callback for the same method.
   *
   * @param method - The name of the indicated RPC method
   * @param handler - Will be invoked when an RPC request for this method is received
   * @returns A promise that resolves when the method is successfully registered
   *
   * @example
   * ```typescript
   * room.localParticipant?.registerRpcMethod(
   *   'greet',
   *   async (data: RpcInvocationData) => {
   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
   *     return `Hello, ${data.callerIdentity}!`;
   *   }
   * );
   * ```
   *
   * The handler should return a Promise that resolves to a string.
   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
   *
   * You may throw errors of type `RpcError` with a string `message` in the handler,
   * and they will be received on the caller's side with the message intact.
   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
   */
  registerRpcMethod(t, i) {
    this.rpcHandlers.set(t, i);
  }
  /**
   * Unregisters a previously registered RPC method.
   *
   * @param method - The name of the RPC method to unregister
   */
  unregisterRpcMethod(t) {
    this.rpcHandlers.delete(t);
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = i, this.allParticipantsAllowedToSubscribe = t, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  handleIncomingRpcAck(t) {
    const i = this.pendingAcks.get(t);
    i ? (i.resolve(), this.pendingAcks.delete(t)) : console.error("Ack received for unexpected RPC request", t);
  }
  handleIncomingRpcResponse(t, i, o) {
    const u = this.pendingResponses.get(t);
    u ? (u.resolve(i, o), this.pendingResponses.delete(t)) : console.error("Response received for unexpected RPC request", t);
  }
  handleIncomingRpcRequest(t, i, o, u, d, c) {
    return G(this, void 0, void 0, function* () {
      if (yield this.publishRpcAck(t, i), c !== 1) {
        yield this.publishRpcResponse(t, i, null, or.builtIn("UNSUPPORTED_VERSION"));
        return;
      }
      const m = this.rpcHandlers.get(o);
      if (!m) {
        yield this.publishRpcResponse(t, i, null, or.builtIn("UNSUPPORTED_METHOD"));
        return;
      }
      let g = null, b = null;
      try {
        const C = yield m({
          requestId: i,
          callerIdentity: t,
          payload: u,
          responseTimeout: d
        });
        JT(C) > Ix ? (g = or.builtIn("RESPONSE_PAYLOAD_TOO_LARGE"), console.warn("RPC Response payload too large for ".concat(o))) : b = C;
      } catch (C) {
        C instanceof or ? g = C : (console.warn("Uncaught error returned by RPC handler for ".concat(o, ". Returning APPLICATION_ERROR instead."), C), g = or.builtIn("APPLICATION_ERROR"));
      }
      yield this.publishRpcResponse(t, i, b, g);
    });
  }
  /** @internal */
  publishRpcRequest(t, i, o, u, d) {
    return G(this, void 0, void 0, function* () {
      const c = new pc({
        destinationIdentities: [t],
        kind: zn.RELIABLE,
        value: {
          case: "rpcRequest",
          value: new zP({
            id: i,
            method: o,
            payload: u,
            responseTimeoutMs: d,
            version: 1
          })
        }
      });
      yield this.engine.sendDataPacket(c, zn.RELIABLE);
    });
  }
  /** @internal */
  publishRpcResponse(t, i, o, u) {
    return G(this, void 0, void 0, function* () {
      const d = new pc({
        destinationIdentities: [t],
        kind: zn.RELIABLE,
        value: {
          case: "rpcResponse",
          value: new BP({
            requestId: i,
            value: u ? {
              case: "error",
              value: u.toProto()
            } : {
              case: "payload",
              value: o ?? ""
            }
          })
        }
      });
      yield this.engine.sendDataPacket(d, zn.RELIABLE);
    });
  }
  /** @internal */
  publishRpcAck(t, i) {
    return G(this, void 0, void 0, function* () {
      const o = new pc({
        destinationIdentities: [t],
        kind: zn.RELIABLE,
        value: {
          case: "rpcAck",
          value: new VP({
            requestId: i
          })
        }
      });
      yield this.engine.sendDataPacket(o, zn.RELIABLE);
    });
  }
  /** @internal */
  handleParticipantDisconnected(t) {
    for (const [i, {
      participantIdentity: o
    }] of this.pendingAcks)
      o === t && this.pendingAcks.delete(i);
    for (const [i, {
      participantIdentity: o,
      resolve: u
    }] of this.pendingResponses)
      o === t && (u(null, or.builtIn("RECIPIENT_DISCONNECTED")), this.pendingResponses.delete(i));
  }
  /** @internal */
  setEnabledPublishCodecs(t) {
    this.enabledPublishVideoCodecs = t.filter((i) => i.mime.split("/")[0].toLowerCase() === "video");
  }
  /** @internal */
  updateInfo(t) {
    return t.sid !== this.sid || !super.updateInfo(t) ? !1 : (t.tracks.forEach((i) => {
      var o, u;
      const d = this.trackPublications.get(i.sid);
      if (d) {
        const c = d.isMuted || ((u = (o = d.track) === null || o === void 0 ? void 0 : o.isUpstreamPaused) !== null && u !== void 0 ? u : !1);
        c !== i.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), _n(d)), {
          mutedOnServer: c
        })), this.engine.client.sendMuteTrack(i.sid, c));
      }
    }), !0);
  }
  getPublicationForTrack(t) {
    let i;
    return this.trackPublications.forEach((o) => {
      const u = o.track;
      u && (t instanceof MediaStreamTrack ? (u instanceof vi || u instanceof Bi) && u.mediaStreamTrack === t && (i = o) : t === u && (i = o));
    }), i;
  }
  waitForPendingPublicationOfSource(t) {
    return G(this, void 0, void 0, function* () {
      const o = Date.now();
      for (; Date.now() < o + 1e4; ) {
        const u = Array.from(this.pendingPublishPromises.entries()).find((d) => {
          let [c] = d;
          return c.source === t;
        });
        if (u)
          return u[1];
        yield us(20);
      }
    });
  }
}
class xv extends mc {
  constructor(t, i, o, u) {
    super(t, i.sid, i.name, u), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = To.HIGH, this.handleEnded = (d) => {
      this.setTrack(void 0), this.emit(Le.Ended, d);
    }, this.handleVisibilityChange = (d) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(d), this.logContext), this.disabled = !d, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (d) => {
      this.log.debug("adaptivestream video dimensions ".concat(d.width, "x").concat(d.height), this.logContext), this.videoDimensions = d, this.emitTrackUpdate();
    }, this.subscribed = o, this.updateInfo(i);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(t) {
    const i = this.subscriptionStatus, o = this.permissionStatus;
    this.subscribed = t, t && (this.allowed = !0);
    const u = new fb({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new $P({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(Le.UpdateSubscription, u), this.emitSubscriptionUpdateIfChanged(i), this.emitPermissionUpdateIfChanged(o);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? mc.SubscriptionStatus.Unsubscribed : super.isSubscribed ? mc.SubscriptionStatus.Subscribed : mc.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? mc.PermissionStatus.Allowed : mc.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(t) {
    !this.isManualOperationAllowed() || this.disabled === !t || (this.disabled = !t, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(t) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === t || (this.currentVideoQuality = t, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(t) {
    var i, o;
    this.isManualOperationAllowed() && (((i = this.videoDimensions) === null || i === void 0 ? void 0 : i.width) === t.width && ((o = this.videoDimensions) === null || o === void 0 ? void 0 : o.height) === t.height || (this.track instanceof Tv && (this.videoDimensions = t), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(t) {
    this.isManualOperationAllowed() && this.track instanceof Tv && this.fps !== t && (this.fps = t, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(t) {
    const i = this.subscriptionStatus, o = this.permissionStatus, u = this.track;
    u !== t && (u && (u.off(Le.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.off(Le.VisibilityChanged, this.handleVisibilityChange), u.off(Le.Ended, this.handleEnded), u.detach(), u.stopMonitor(), this.emit(Le.Unsubscribed, u)), super.setTrack(t), t && (t.sid = this.trackSid, t.on(Le.VideoDimensionsChanged, this.handleVideoDimensionsChange), t.on(Le.VisibilityChanged, this.handleVisibilityChange), t.on(Le.Ended, this.handleEnded), this.emit(Le.Subscribed, t)), this.emitPermissionUpdateIfChanged(o), this.emitSubscriptionUpdateIfChanged(i));
  }
  /** @internal */
  setAllowed(t) {
    const i = this.subscriptionStatus, o = this.permissionStatus;
    this.allowed = t, this.emitPermissionUpdateIfChanged(o), this.emitSubscriptionUpdateIfChanged(i);
  }
  /** @internal */
  setSubscriptionError(t) {
    this.emit(Le.SubscriptionFailed, t);
  }
  /** @internal */
  updateInfo(t) {
    super.updateInfo(t);
    const i = this.metadataMuted;
    this.metadataMuted = t.muted, this.track ? this.track.setMuted(t.muted) : i !== t.muted && this.emit(t.muted ? Le.Muted : Le.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(t) {
    const i = this.subscriptionStatus;
    t !== i && this.emit(Le.SubscriptionStatusChanged, i, t);
  }
  emitPermissionUpdateIfChanged(t) {
    this.permissionStatus !== t && this.emit(Le.SubscriptionPermissionChanged, this.permissionStatus, t);
  }
  isManualOperationAllowed() {
    return this.kind === ue.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof Tv && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const t = new KP({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (t.width = Math.ceil(this.videoDimensions.width), t.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? t.quality = this.currentVideoQuality : t.quality = To.HIGH, this.emit(Le.UpdateSettings, t);
  }
}
class tb extends JD {
  /** @internal */
  static fromParticipantInfo(t, i, o) {
    return new tb(t, i.sid, i.identity, i.name, i.metadata, i.attributes, o, i.kind);
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity
    });
  }
  /** @internal */
  constructor(t, i, o, u, d, c, m) {
    let g = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : Z0.STANDARD;
    super(i, o || "", u, d, c, m, g), this.signalClient = t, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(t) {
    super.addTrackPublication(t), t.on(Le.UpdateSettings, (i) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), _n(t))), this.signalClient.sendUpdateTrackSettings(i);
    }), t.on(Le.UpdateSubscription, (i) => {
      i.participantTracks.forEach((o) => {
        o.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(i);
    }), t.on(Le.SubscriptionPermissionChanged, (i) => {
      this.emit(ce.TrackSubscriptionPermissionChanged, t, i);
    }), t.on(Le.SubscriptionStatusChanged, (i) => {
      this.emit(ce.TrackSubscriptionStatusChanged, t, i);
    }), t.on(Le.Subscribed, (i) => {
      this.emit(ce.TrackSubscribed, i, t);
    }), t.on(Le.Unsubscribed, (i) => {
      this.emit(ce.TrackUnsubscribed, i, t);
    }), t.on(Le.SubscriptionFailed, (i) => {
      this.emit(ce.TrackSubscriptionFailed, t.trackSid, i);
    });
  }
  getTrackPublication(t) {
    const i = super.getTrackPublication(t);
    if (i)
      return i;
  }
  getTrackPublicationByName(t) {
    const i = super.getTrackPublicationByName(t);
    if (i)
      return i;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ue.Source.Microphone;
    this.volumeMap.set(i, t);
    const o = this.getTrackPublication(i);
    o && o.track && o.track.setVolume(t);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ue.Source.Microphone;
    const i = this.getTrackPublication(t);
    return i && i.track ? i.track.getVolume() : this.volumeMap.get(t);
  }
  /** @internal */
  addSubscribedMediaTrack(t, i, o, u, d, c) {
    let m = this.getTrackPublicationBySid(i);
    if (m || i.startsWith("TR") || this.trackPublications.forEach((C) => {
      !m && t.kind === C.kind.toString() && (m = C);
    }), !m) {
      if (c === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: i
        })), this.emit(ce.TrackSubscriptionFailed, i);
        return;
      }
      c === void 0 && (c = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(t, i, o, u, d, c - 1);
      }, 150);
      return;
    }
    if (t.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), _n(m))), this.emit(ce.TrackSubscriptionFailed, i);
      return;
    }
    const g = t.kind === "video";
    let b;
    return g ? b = new Tv(t, i, u, d) : b = new Hp(t, i, u, this.audioContext, this.audioOutput), b.source = m.source, b.isMuted = m.isMuted, b.setMediaStream(o), b.start(), m.setTrack(b), this.volumeMap.has(m.source) && b instanceof Hp && b.setVolume(this.volumeMap.get(m.source)), m;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(t) {
    return this.trackPublications.get(t);
  }
  /** @internal */
  updateInfo(t) {
    if (!super.updateInfo(t))
      return !1;
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    return t.tracks.forEach((u) => {
      var d, c;
      let m = this.getTrackPublicationBySid(u.sid);
      if (m)
        m.updateInfo(u);
      else {
        const g = ue.kindFromProto(u.type);
        if (!g)
          return;
        m = new xv(g, u, (d = this.signalClient.connectOptions) === null || d === void 0 ? void 0 : d.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (c = this.loggerOptions) === null || c === void 0 ? void 0 : c.loggerName
        }), m.updateInfo(u), o.set(u.sid, m);
        const b = Array.from(this.trackPublications.values()).find((C) => C.source === (m == null ? void 0 : m.source));
        b && m.source !== ue.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(m.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: _n(b),
          newTrack: _n(m)
        })), this.addTrackPublication(m);
      }
      i.set(u.sid, m);
    }), this.trackPublications.forEach((u) => {
      i.has(u.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), _n(u))), this.unpublishTrack(u.trackSid, !0));
    }), o.forEach((u) => {
      this.emit(ce.TrackPublished, u);
    }), !0;
  }
  /** @internal */
  unpublishTrack(t, i) {
    const o = this.trackPublications.get(t);
    if (!o)
      return;
    const {
      track: u
    } = o;
    switch (u && (u.stop(), o.setTrack(void 0)), this.trackPublications.delete(t), o.kind) {
      case ue.Kind.Audio:
        this.audioTrackPublications.delete(t);
        break;
      case ue.Kind.Video:
        this.videoTrackPublications.delete(t);
        break;
    }
    i && this.emit(ce.TrackUnpublished, o);
  }
  /**
   * @internal
   */
  setAudioOutput(t) {
    return G(this, void 0, void 0, function* () {
      this.audioOutput = t;
      const i = [];
      this.audioTrackPublications.forEach((o) => {
        var u;
        o.track instanceof Hp && i.push(o.track.setSinkId((u = t.deviceId) !== null && u !== void 0 ? u : "default"));
      }), yield Promise.all(i);
    });
  }
  /** @internal */
  emit(t) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++)
      o[u - 1] = arguments[u];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: t,
      args: o
    })), super.emit(t, ...o);
  }
}
var Yt;
(function(r) {
  r.Disconnected = "disconnected", r.Connecting = "connecting", r.Connected = "connected", r.Reconnecting = "reconnecting", r.SignalReconnecting = "signalReconnecting";
})(Yt || (Yt = {}));
const wF = 4 * 1e3;
class Ql extends rl.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(t) {
    var i, o, u, d;
    if (super(), i = this, this.state = Yt.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = Wt, this.bufferedEvents = [], this.isResuming = !1, this.connect = (c, m, g) => G(this, void 0, void 0, function* () {
      var b;
      if (!A3())
        throw Kl() ? Error("WebRTC isn't detected, have you called registerGlobals?") : Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
      const C = yield this.disconnectLock.lock();
      if (this.state === Yt.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), C(), Promise.resolve();
      if (this.connectFuture)
        return C(), this.connectFuture.promise;
      this.setAndEmitConnectionState(Yt.Connecting), ((b = this.regionUrlProvider) === null || b === void 0 ? void 0 : b.getServerUrl().toString()) !== c && (this.regionUrl = void 0, this.regionUrlProvider = void 0), GT(new URL(c)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new Ax(c, m) : this.regionUrlProvider.updateToken(m), this.regionUrlProvider.fetchRegionSettings().then((O) => {
        var N;
        (N = this.regionUrlProvider) === null || N === void 0 || N.setServerReportedRegions(O);
      }).catch((O) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: O
        }));
      }));
      const E = (O, N, M) => G(this, void 0, void 0, function* () {
        var I, U;
        this.abortController && this.abortController.abort();
        const ae = new AbortController();
        this.abortController = ae, C == null || C();
        try {
          yield this.attemptConnection(M ?? c, m, g, ae), this.abortController = void 0, O();
        } catch (Z) {
          if (this.regionUrlProvider && Z instanceof xn && Z.reason !== nn.Cancelled && Z.reason !== nn.NotAllowed) {
            let B = null;
            try {
              B = yield this.regionUrlProvider.getNextBestRegionUrl((I = this.abortController) === null || I === void 0 ? void 0 : I.signal);
            } catch (F) {
              if (F instanceof xn && (F.status === 401 || F.reason === nn.Cancelled)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), N(F);
                return;
              }
            }
            B && !(!((U = this.abortController) === null || U === void 0) && U.signal.aborted) ? (this.log.info("Initial connection failed with ConnectionError: ".concat(Z.message, ". Retrying with another region: ").concat(B), this.logContext), this.recreateEngine(), yield E(O, N, B)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, Sx(Z)), N(Z));
          } else {
            let B = ls.UNKNOWN_REASON;
            Z instanceof xn && (B = Sx(Z)), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, B), N(Z);
          }
        }
      }), x = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new $D((O, N) => {
        E(O, N, x);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (c, m, g, b, C, E) => G(this, void 0, void 0, function* () {
      var x, O, N;
      const M = yield g.join(c, m, {
        autoSubscribe: b.autoSubscribe,
        adaptiveStream: typeof C.adaptiveStream == "object" ? !0 : C.adaptiveStream,
        maxRetries: b.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: b.websocketTimeout
      }, E.signal);
      let I = M.serverInfo;
      if (I || (I = {
        version: M.serverVersion,
        region: M.serverRegion
      }), this.serverInfo = I, this.log.debug("connected to Livekit Server ".concat(Object.entries(I).map((U) => {
        let [ae, Z] = U;
        return "".concat(ae, ": ").concat(Z);
      }).join(", ")), {
        room: (x = M.room) === null || x === void 0 ? void 0 : x.name,
        roomSid: (O = M.room) === null || O === void 0 ? void 0 : O.sid,
        identity: (N = M.participant) === null || N === void 0 ? void 0 : N.identity
      }), !I.version)
        throw new v3("unknown server version");
      return I.version === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), C.dynacast = !1), M;
    }), this.applyJoinResponse = (c) => {
      const m = c.participant;
      if (this.localParticipant.sid = m.sid, this.localParticipant.identity = m.identity, this.localParticipant.setEnabledPublishCodecs(c.enabledPublishCodecs), this.options.e2ee && this.e2eeManager)
        try {
          this.e2eeManager.setSifTrailer(c.sifTrailer);
        } catch (g) {
          this.log.error(g instanceof Error ? g.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
            error: g
          }));
        }
      this.handleParticipantUpdates([m, ...c.otherParticipants]), c.room && this.handleRoomUpdate(c.room);
    }, this.attemptConnection = (c, m, g, b) => G(this, void 0, void 0, function* () {
      var C, E;
      this.state === Yt.Reconnecting || this.isResuming || !((C = this.engine) === null || C === void 0) && C.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((E = this.regionUrlProvider) === null || E === void 0) && E.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, xE), g), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const x = yield this.connectSignal(c, m, this.engine, this.connOptions, this.options, b);
        this.applyJoinResponse(x), this.setupLocalParticipantEvents(), this.emit(ne.SignalConnected);
      } catch (x) {
        yield this.engine.close(), this.recreateEngine();
        const O = new xn("could not establish signal connection", nn.ServerUnreachable);
        throw x instanceof Error && (O.message = "".concat(O.message, ": ").concat(x.message)), x instanceof xn && (O.reason = x.reason, O.status = x.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: x
        })), O;
      }
      if (b.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new xn("Connection attempt aborted", nn.Cancelled);
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, b);
      } catch (x) {
        throw yield this.engine.close(), this.recreateEngine(), x;
      }
      Ia() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), Ia() && document.addEventListener("freeze", this.onPageLeave), this.setAndEmitConnectionState(Yt.Connected), this.emit(ne.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
        m[g] = arguments[g];
      return G(i, [...m], void 0, function() {
        var b = this;
        let C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
        return function* () {
          var E, x, O, N;
          const M = yield b.disconnectLock.lock();
          try {
            if (b.state === Yt.Disconnected) {
              b.log.debug("already disconnected", b.logContext);
              return;
            }
            b.log.info("disconnect from room", Object.assign({}, b.logContext)), (b.state === Yt.Connecting || b.state === Yt.Reconnecting || b.isResuming) && (b.log.warn("abort connection attempt", b.logContext), (E = b.abortController) === null || E === void 0 || E.abort(), (O = (x = b.connectFuture) === null || x === void 0 ? void 0 : x.reject) === null || O === void 0 || O.call(x, new xn("Client initiated disconnect", nn.Cancelled)), b.connectFuture = void 0), !((N = b.engine) === null || N === void 0) && N.client.isDisconnected || (yield b.engine.client.sendLeave()), b.engine && (yield b.engine.close()), b.handleDisconnect(C, ls.CLIENT_INITIATED), b.engine = void 0;
          } finally {
            M();
          }
        }();
      });
    }, this.onPageLeave = () => G(this, void 0, void 0, function* () {
      this.log.info("Page leave detected, disconnecting", this.logContext), yield this.disconnect();
    }), this.startAudio = () => G(this, void 0, void 0, function* () {
      const c = [], m = tl();
      if (m && m.os === "iOS") {
        const g = "livekit-dummy-audio-el";
        let b = document.getElementById(g);
        if (!b) {
          b = document.createElement("audio"), b.id = g, b.autoplay = !0, b.hidden = !0;
          const C = lT();
          C.enabled = !0;
          const E = new MediaStream([C]);
          b.srcObject = E, document.addEventListener("visibilitychange", () => {
            b && (b.srcObject = document.hidden ? null : E, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(b), this.once(ne.Disconnected, () => {
            b == null || b.remove(), b = null;
          });
        }
        c.push(b);
      }
      this.remoteParticipants.forEach((g) => {
        g.audioTrackPublications.forEach((b) => {
          b.track && b.track.attachedElements.forEach((C) => {
            c.push(C);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...c.map((g) => (g.muted = !1, g.play()))]), this.handleAudioPlaybackStarted();
      } catch (g) {
        throw this.handleAudioPlaybackFailed(g), g;
      }
    }), this.startVideo = () => G(this, void 0, void 0, function* () {
      const c = [];
      for (const m of this.remoteParticipants.values())
        m.videoTrackPublications.forEach((g) => {
          var b;
          (b = g.track) === null || b === void 0 || b.attachedElements.forEach((C) => {
            c.includes(C) || c.push(C);
          });
        });
      yield Promise.all(c.map((m) => m.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((m) => {
        m.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const c of this.remoteParticipants.values())
        this.handleParticipantDisconnected(c.identity, c);
      this.setAndEmitConnectionState(Yt.Reconnecting) && this.emit(ne.Reconnecting);
    }, this.handleSignalRestarted = (c) => G(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(c.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: c.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(c);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (m) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: m
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: c.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(Yt.Connected), this.emit(ne.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (c) => {
      c.forEach((m) => {
        var g;
        if (m.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(m);
          return;
        }
        m.identity === "" && (m.identity = (g = this.sidToIdentity.get(m.sid)) !== null && g !== void 0 ? g : "");
        let b = this.remoteParticipants.get(m.identity);
        m.state === _T.DISCONNECTED ? this.handleParticipantDisconnected(m.identity, b) : b = this.getOrCreateParticipant(m.identity, m);
      });
    }, this.handleActiveSpeakersUpdate = (c) => {
      const m = [], g = {};
      c.forEach((b) => {
        if (g[b.sid] = !0, b.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = b.level, this.localParticipant.setIsSpeaking(!0), m.push(this.localParticipant);
        else {
          const C = this.getRemoteParticipantBySid(b.sid);
          C && (C.audioLevel = b.level, C.setIsSpeaking(!0), m.push(C));
        }
      }), g[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((b) => {
        g[b.sid] || (b.audioLevel = 0, b.setIsSpeaking(!1));
      }), this.activeSpeakers = m, this.emitWhenConnected(ne.ActiveSpeakersChanged, m);
    }, this.handleSpeakersChanged = (c) => {
      const m = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((b) => {
        const C = this.remoteParticipants.get(b.identity);
        C && C.sid !== b.sid || m.set(b.sid, b);
      }), c.forEach((b) => {
        let C = this.getRemoteParticipantBySid(b.sid);
        b.sid === this.localParticipant.sid && (C = this.localParticipant), C && (C.audioLevel = b.level, C.setIsSpeaking(b.active), b.active ? m.set(b.sid, C) : m.delete(b.sid));
      });
      const g = Array.from(m.values());
      g.sort((b, C) => C.audioLevel - b.audioLevel), this.activeSpeakers = g, this.emitWhenConnected(ne.ActiveSpeakersChanged, g);
    }, this.handleStreamStateUpdate = (c) => {
      c.streamStates.forEach((m) => {
        const g = this.getRemoteParticipantBySid(m.participantSid);
        if (!g)
          return;
        const b = g.getTrackPublicationBySid(m.trackSid);
        if (!b || !b.track)
          return;
        const C = ue.streamStateFromProto(m.state);
        C !== b.track.streamState && (b.track.streamState = C, g.emit(ce.TrackStreamStateChanged, b, b.track.streamState), this.emitWhenConnected(ne.TrackStreamStateChanged, b, b.track.streamState, g));
      });
    }, this.handleSubscriptionPermissionUpdate = (c) => {
      const m = this.getRemoteParticipantBySid(c.participantSid);
      if (!m)
        return;
      const g = m.getTrackPublicationBySid(c.trackSid);
      g && g.setAllowed(c.allowed);
    }, this.handleSubscriptionError = (c) => {
      const m = Array.from(this.remoteParticipants.values()).find((b) => b.trackPublications.has(c.trackSid));
      if (!m)
        return;
      const g = m.getTrackPublicationBySid(c.trackSid);
      g && g.setSubscriptionError(c.err);
    }, this.handleDataPacket = (c) => {
      const m = this.remoteParticipants.get(c.participantIdentity);
      c.value.case === "user" ? this.handleUserPacket(m, c.value.value, c.kind) : c.value.case === "transcription" ? this.handleTranscription(m, c.value.value) : c.value.case === "sipDtmf" ? this.handleSipDtmf(m, c.value.value) : c.value.case === "chatMessage" ? this.handleChatMessage(m, c.value.value) : c.value.case === "metrics" && this.handleMetrics(c.value.value, m);
    }, this.handleUserPacket = (c, m, g) => {
      this.emit(ne.DataReceived, m.payload, c, g, m.topic), c == null || c.emit(ce.DataReceived, m.payload, g);
    }, this.handleSipDtmf = (c, m) => {
      this.emit(ne.SipDTMFReceived, m, c), c == null || c.emit(ce.SipDTMFReceived, m);
    }, this.bufferedSegments = /* @__PURE__ */ new Map(), this.handleTranscription = (c, m) => {
      const g = m.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(m.transcribedParticipantIdentity), b = g == null ? void 0 : g.trackPublications.get(m.trackId), C = H3(m, this.transcriptionReceivedTimes);
      b == null || b.emit(Le.TranscriptionReceived, C), g == null || g.emit(ce.TranscriptionReceived, C, b), this.emit(ne.TranscriptionReceived, C, g, b);
    }, this.handleChatMessage = (c, m) => {
      const g = $3(m);
      this.emit(ne.ChatMessage, g, c);
    }, this.handleMetrics = (c, m) => {
      this.emit(ne.MetricsReceived, c, m);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(ne.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (c) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: c
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(ne.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(ne.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(ne.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => G(this, void 0, void 0, function* () {
      var c, m;
      const g = Jr.getInstance().previousDevices, b = yield Jr.getInstance().getDevices(void 0, !1), C = tl();
      if ((C == null ? void 0 : C.name) === "Chrome" && C.os !== "iOS")
        for (let x of b) {
          const O = g.find((N) => N.deviceId === x.deviceId);
          O && O.label !== "" && O.kind === x.kind && O.label !== x.label && this.getActiveDevice(x.kind) === "default" && this.emit(ne.ActiveDeviceChanged, x.kind, x.deviceId);
        }
      const E = ["audiooutput", "audioinput", "videoinput"];
      for (let x of E) {
        const O = b.filter((M) => M.kind === x), N = this.getActiveDevice(x);
        if (N === ((c = g.filter((M) => M.kind === x)[0]) === null || c === void 0 ? void 0 : c.deviceId) && O.length > 0 && ((m = O[0]) === null || m === void 0 ? void 0 : m.deviceId) !== N) {
          yield this.switchActiveDevice(x, O[0].deviceId);
          continue;
        }
        x === "audioinput" && !Cc() || x === "videoinput" || O.length > 0 && !O.find((M) => M.deviceId === this.getActiveDevice(x)) && (yield this.switchActiveDevice(x, O[0].deviceId));
      }
      this.emit(ne.MediaDevicesChanged);
    }), this.handleRoomUpdate = (c) => {
      const m = this.roomInfo;
      this.roomInfo = c, m && m.metadata !== c.metadata && this.emitWhenConnected(ne.RoomMetadataChanged, c.metadata), (m == null ? void 0 : m.activeRecording) !== c.activeRecording && this.emitWhenConnected(ne.RecordingStatusChanged, c.activeRecording);
    }, this.handleConnectionQualityUpdate = (c) => {
      c.updates.forEach((m) => {
        if (m.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(m.quality);
          return;
        }
        const g = this.getRemoteParticipantBySid(m.participantSid);
        g && g.setConnectionQuality(m.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (c) => {
      this.emit(ne.ParticipantMetadataChanged, c, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (c) => {
      this.emit(ne.ParticipantNameChanged, c, this.localParticipant);
    }, this.onLocalAttributesChanged = (c) => {
      this.emit(ne.ParticipantAttributesChanged, c, this.localParticipant);
    }, this.onLocalTrackMuted = (c) => {
      this.emit(ne.TrackMuted, c, this.localParticipant);
    }, this.onLocalTrackUnmuted = (c) => {
      this.emit(ne.TrackUnmuted, c, this.localParticipant);
    }, this.onTrackProcessorUpdate = (c) => {
      var m;
      (m = c == null ? void 0 : c.onPublish) === null || m === void 0 || m.call(c, this);
    }, this.onLocalTrackPublished = (c) => G(this, void 0, void 0, function* () {
      var m, g, b, C, E, x;
      (m = c.track) === null || m === void 0 || m.on(Le.TrackProcessorUpdate, this.onTrackProcessorUpdate), (g = c.track) === null || g === void 0 || g.on(Le.Restarted, this.onLocalTrackRestarted), (E = (C = (b = c.track) === null || b === void 0 ? void 0 : b.getProcessor()) === null || C === void 0 ? void 0 : C.onPublish) === null || E === void 0 || E.call(C, this), this.emit(ne.LocalTrackPublished, c, this.localParticipant), c.track instanceof vi && (yield c.track.checkForSilence()) && this.emit(ne.LocalAudioSilenceDetected, c);
      const O = yield (x = c.track) === null || x === void 0 ? void 0 : x.getDeviceId(!1), N = px(c.source);
      N && O && O !== this.localParticipant.activeDeviceMap.get(N) && (this.localParticipant.activeDeviceMap.set(N, O), this.emit(ne.ActiveDeviceChanged, N, O));
    }), this.onLocalTrackUnpublished = (c) => {
      var m, g;
      (m = c.track) === null || m === void 0 || m.off(Le.TrackProcessorUpdate, this.onTrackProcessorUpdate), (g = c.track) === null || g === void 0 || g.off(Le.Restarted, this.onLocalTrackRestarted), this.emit(ne.LocalTrackUnpublished, c, this.localParticipant);
    }, this.onLocalTrackRestarted = (c) => G(this, void 0, void 0, function* () {
      const m = yield c.getDeviceId(!1), g = px(c.source);
      g && m && m !== this.localParticipant.activeDeviceMap.get(g) && (this.log.debug("local track restarted, setting ".concat(g, " ").concat(m, " active"), this.logContext), this.localParticipant.activeDeviceMap.set(g, m), this.emit(ne.ActiveDeviceChanged, g, m));
    }), this.onLocalConnectionQualityChanged = (c) => {
      this.emit(ne.ConnectionQualityChanged, c, this.localParticipant);
    }, this.onMediaDevicesError = (c) => {
      this.emit(ne.MediaDevicesError, c);
    }, this.onLocalParticipantPermissionsChanged = (c) => {
      this.emit(ne.ParticipantPermissionsChanged, c, this.localParticipant);
    }, this.onLocalChatMessageSent = (c) => {
      this.emit(ne.ChatMessage, c, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, iF), t), this.log = Yl((o = this.options.loggerName) !== null && o !== void 0 ? o : cs.Room), this.transcriptionReceivedTimes = /* @__PURE__ */ new Map(), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, qD), t == null ? void 0 : t.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, WD), t == null ? void 0 : t.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, rF), t == null ? void 0 : t.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Aa(), this.localParticipant = new Fx("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", Nd(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", Nd(this.options.audioCaptureDefaults.deviceId)), !((u = this.options.audioOutput) === null || u === void 0) && u.deviceId && this.switchActiveDevice("audiooutput", Nd(this.options.audioOutput.deviceId)).catch((c) => this.log.warn("Could not set audio output: ".concat(c.message), this.logContext)), this.options.e2ee && this.setupE2EE(), Ia()) {
      const c = new AbortController();
      (d = navigator.mediaDevices) === null || d === void 0 || d.addEventListener("devicechange", this.handleDeviceChange, {
        signal: c.signal
      }), Ql.cleanupRegistry && Ql.cleanupRegistry.register(this, () => {
        c.abort();
      });
    }
  }
  /**
   * @experimental
   */
  setE2EEEnabled(t) {
    return G(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(t)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(t, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var t;
    this.options.e2ee && ("e2eeManager" in this.options.e2ee ? this.e2eeManager = this.options.e2ee.e2eeManager : this.e2eeManager = new W3(this.options.e2ee), this.e2eeManager.on(vc.ParticipantEncryptionStatusChanged, (i, o) => {
      o instanceof Fx && (this.isE2EEEnabled = i), this.emit(ne.ParticipantEncryptionStatusChanged, i, o);
    }), this.e2eeManager.on(vc.EncryptionError, (i) => this.emit(ne.EncryptionError, i)), (t = this.e2eeManager) === null || t === void 0 || t.setup(this));
  }
  get logContext() {
    var t;
    return {
      room: this.name,
      roomID: (t = this.roomInfo) === null || t === void 0 ? void 0 : t.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var t, i;
    return (i = (t = this.roomInfo) === null || t === void 0 ? void 0 : t.activeRecording) !== null && i !== void 0 ? i : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return G(this, void 0, void 0, function* () {
      return this.state === Yt.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((t, i) => {
        const o = (u) => {
          u.sid !== "" && (this.engine.off(qe.RoomUpdate, o), t(u.sid));
        };
        this.engine.on(qe.RoomUpdate, o), this.once(ne.Disconnected, () => {
          this.engine.off(qe.RoomUpdate, o), i("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var t, i;
    return (i = (t = this.roomInfo) === null || t === void 0 ? void 0 : t.name) !== null && i !== void 0 ? i : "";
  }
  /** room metadata */
  get metadata() {
    var t;
    return (t = this.roomInfo) === null || t === void 0 ? void 0 : t.metadata;
  }
  get numParticipants() {
    var t, i;
    return (i = (t = this.roomInfo) === null || t === void 0 ? void 0 : t.numParticipants) !== null && i !== void 0 ? i : 0;
  }
  get numPublishers() {
    var t, i;
    return (i = (t = this.roomInfo) === null || t === void 0 ? void 0 : t.numPublishers) !== null && i !== void 0 ? i : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new yF(this.options), this.engine.on(qe.ParticipantUpdate, this.handleParticipantUpdates).on(qe.RoomUpdate, this.handleRoomUpdate).on(qe.SpeakersChanged, this.handleSpeakersChanged).on(qe.StreamStateChanged, this.handleStreamStateUpdate).on(qe.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(qe.SubscriptionError, this.handleSubscriptionError).on(qe.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(qe.MediaTrackAdded, (t, i, o) => {
      this.onTrackAdded(t, i, o);
    }).on(qe.Disconnected, (t) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, t);
    }).on(qe.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(qe.DataPacketReceived, this.handleDataPacket).on(qe.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext), this.setAndEmitConnectionState(Yt.SignalReconnecting) && this.emit(ne.SignalReconnecting);
    }).on(qe.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents(), this.setAndEmitConnectionState(Yt.Connected) && this.emit(ne.Reconnected);
    }).on(qe.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === Yt.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(qe.Restarting, this.handleRestarting).on(qe.SignalRestarted, this.handleSignalRestarted).on(qe.Offline, () => {
      this.setAndEmitConnectionState(Yt.Reconnecting) && this.emit(ne.Reconnecting);
    }).on(qe.DCBufferStatusChanged, (t, i) => {
      this.emit(ne.DCBufferStatusChanged, t, i);
    }).on(qe.LocalTrackSubscribed, (t) => {
      const i = this.localParticipant.getTrackPublications().find((o) => {
        let {
          trackSid: u
        } = o;
        return u === t;
      });
      if (!i) {
        this.log.warn("could not find local track subscription for subscribed event", this.logContext);
        return;
      }
      this.localParticipant.emit(ce.LocalTrackSubscribed, i), this.emitWhenConnected(ne.LocalTrackSubscribed, i, this.localParticipant);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it requests device permissions by default if needed
   * and makes sure the returned device does not consist of dummy devices
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(t) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return Jr.getInstance().getDevices(t, i);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(t, i) {
    return G(this, void 0, void 0, function* () {
      if (this.state === Yt.Disconnected) {
        this.log.debug("prepareConnection to ".concat(t), this.logContext);
        try {
          if (GT(new URL(t)) && i) {
            this.regionUrlProvider = new Ax(t, i);
            const o = yield this.regionUrlProvider.getNextBestRegionUrl();
            o && this.state === Yt.Disconnected && (this.regionUrl = o, yield fetch(bx(o), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(o), this.logContext));
          } else
            yield fetch(bx(t), {
              method: "HEAD"
            });
        } catch (o) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: o
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(t) {
    return this.localParticipant.identity === t ? this.localParticipant : this.remoteParticipants.get(t);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(t, i) {
    return G(this, void 0, void 0, function* () {
      let o = () => {
      }, u;
      switch (t) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          u = new Xs({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          u = new Xs({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          u = new Xs({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          u = new Xs({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          o = () => G(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), u = new Xs({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          o = () => G(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), u = new Xs({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          u = new Xs({
            scenario: {
              case: "switchCandidateProtocol",
              value: t === "force-tls" ? 2 : 1
            }
          }), o = () => G(this, void 0, void 0, function* () {
            const d = this.engine.client.onLeave;
            d && d(new pb({
              reason: ls.CLIENT_INITIATED,
              action: jp.RECONNECT
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (i === void 0 || typeof i != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          u = new Xs({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(i)
            }
          });
          break;
        case "leave-full-reconnect":
          u = new Xs({
            scenario: {
              case: "leaveRequestFullReconnect",
              value: !0
            }
          });
      }
      u && (yield this.engine.client.sendSimulateScenario(u), yield o());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(t) {
    return this.localParticipant.activeDeviceMap.get(t);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(t, i) {
    return G(this, arguments, void 0, function(o, u) {
      var d = this;
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return function* () {
        var m, g, b, C, E, x, O;
        let N = !0, M = !1;
        const I = c ? {
          exact: u
        } : u;
        if (o === "audioinput") {
          M = d.localParticipant.audioTrackPublications.size === 0;
          const U = (m = d.getActiveDevice(o)) !== null && m !== void 0 ? m : d.options.audioCaptureDefaults.deviceId;
          d.options.audioCaptureDefaults.deviceId = I;
          const ae = Array.from(d.localParticipant.audioTrackPublications.values()).filter((Z) => Z.source === ue.Source.Microphone);
          try {
            N = (yield Promise.all(ae.map((Z) => {
              var B;
              return (B = Z.audioTrack) === null || B === void 0 ? void 0 : B.setDeviceId(I);
            }))).every((Z) => Z === !0);
          } catch (Z) {
            throw d.options.audioCaptureDefaults.deviceId = U, Z;
          }
        } else if (o === "videoinput") {
          M = d.localParticipant.videoTrackPublications.size === 0;
          const U = (g = d.getActiveDevice(o)) !== null && g !== void 0 ? g : d.options.videoCaptureDefaults.deviceId;
          d.options.videoCaptureDefaults.deviceId = I;
          const ae = Array.from(d.localParticipant.videoTrackPublications.values()).filter((Z) => Z.source === ue.Source.Camera);
          try {
            N = (yield Promise.all(ae.map((Z) => {
              var B;
              return (B = Z.videoTrack) === null || B === void 0 ? void 0 : B.setDeviceId(I);
            }))).every((Z) => Z === !0);
          } catch (Z) {
            throw d.options.videoCaptureDefaults.deviceId = U, Z;
          }
        } else if (o === "audiooutput") {
          if (!WT() && !d.options.webAudioMix || d.options.webAudioMix && d.audioContext && !("setSinkId" in d.audioContext))
            throw new Error("cannot switch audio output, setSinkId not supported");
          d.options.webAudioMix && (u = (b = yield Jr.getInstance().normalizeDeviceId("audiooutput", u)) !== null && b !== void 0 ? b : ""), (C = (O = d.options).audioOutput) !== null && C !== void 0 || (O.audioOutput = {});
          const U = (E = d.getActiveDevice(o)) !== null && E !== void 0 ? E : d.options.audioOutput.deviceId;
          d.options.audioOutput.deviceId = u;
          try {
            d.options.webAudioMix && ((x = d.audioContext) === null || x === void 0 || x.setSinkId(u)), yield Promise.all(Array.from(d.remoteParticipants.values()).map((ae) => ae.setAudioOutput({
              deviceId: u
            })));
          } catch (ae) {
            throw d.options.audioOutput.deviceId = U, ae;
          }
        }
        return M && (d.localParticipant.activeDeviceMap.set(o, u), d.emit(ne.ActiveDeviceChanged, o, u)), N;
      }();
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ce.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ce.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ce.AttributesChanged, this.onLocalAttributesChanged).on(ce.TrackMuted, this.onLocalTrackMuted).on(ce.TrackUnmuted, this.onLocalTrackUnmuted).on(ce.LocalTrackPublished, this.onLocalTrackPublished).on(ce.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ce.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ce.MediaDevicesError, this.onMediaDevicesError).on(ce.AudioStreamAcquired, this.startAudio).on(ce.ChatMessage, this.onLocalChatMessageSent).on(ce.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var t;
    (t = this.engine) === null || t === void 0 || t.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(t, i, o) {
    if (this.state === Yt.Connecting || this.state === Yt.Reconnecting) {
      const C = () => {
        this.onTrackAdded(t, i, o), E();
      }, E = () => {
        this.off(ne.Reconnected, C), this.off(ne.Connected, C), this.off(ne.Disconnected, E);
      };
      this.once(ne.Reconnected, C), this.once(ne.Connected, C), this.once(ne.Disconnected, E);
      return;
    }
    if (this.state === Yt.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const u = M3(i.id), d = u[0];
    let c = u[1], m = t.id;
    if (c && c.startsWith("TR") && (m = c), d === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const g = Array.from(this.remoteParticipants.values()).find((C) => C.sid === d);
    if (!g) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(d), this.logContext);
      return;
    }
    let b;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? b = this.options.adaptiveStream : b = {}), g.addSubscribedMediaTrack(t, m, i, o, b);
  }
  handleDisconnect() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, i = arguments.length > 1 ? arguments[1] : void 0;
    var o;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.transcriptionReceivedTimes.clear(), this.state !== Yt.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((u) => {
          u.trackPublications.forEach((d) => {
            u.unpublishTrack(d.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((u) => {
          var d, c, m;
          u.track && this.localParticipant.unpublishTrack(u.track, t), t ? ((d = u.track) === null || d === void 0 || d.detach(), (c = u.track) === null || c === void 0 || c.stop()) : (m = u.track) === null || m === void 0 || m.stopMonitor();
        }), this.localParticipant.off(ce.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ce.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ce.AttributesChanged, this.onLocalAttributesChanged).off(ce.TrackMuted, this.onLocalTrackMuted).off(ce.TrackUnmuted, this.onLocalTrackUnmuted).off(ce.LocalTrackPublished, this.onLocalTrackPublished).off(ce.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ce.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ce.MediaDevicesError, this.onMediaDevicesError).off(ce.AudioStreamAcquired, this.startAudio).off(ce.ChatMessage, this.onLocalChatMessageSent).off(ce.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), Ia() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (o = navigator.mediaDevices) === null || o === void 0 || o.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(Yt.Disconnected), this.emit(ne.Disconnected, i);
      }
    }
  }
  handleParticipantDisconnected(t, i) {
    var o;
    this.remoteParticipants.delete(t), i && (i.trackPublications.forEach((u) => {
      i.unpublishTrack(u.trackSid, !0);
    }), this.emit(ne.ParticipantDisconnected, i), (o = this.localParticipant) === null || o === void 0 || o.handleParticipantDisconnected(i.identity));
  }
  acquireAudioContext() {
    return G(this, void 0, void 0, function* () {
      var t, i;
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (t = zD()) !== null && t !== void 0 ? t : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (u) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: u
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((u) => u.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const o = ((i = this.audioContext) === null || i === void 0 ? void 0 : i.state) === "running";
      o !== this.canPlaybackAudio && (this.audioEnabled = o, this.emit(ne.AudioPlaybackStatusChanged, o));
    });
  }
  createParticipant(t, i) {
    var o;
    let u;
    return i ? u = tb.fromParticipantInfo(this.engine.client, i, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }) : u = new tb(this.engine.client, "", t, void 0, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && u.setAudioContext(this.audioContext), !((o = this.options.audioOutput) === null || o === void 0) && o.deviceId && u.setAudioOutput(this.options.audioOutput).catch((d) => this.log.warn("Could not set audio output: ".concat(d.message), this.logContext)), u;
  }
  getOrCreateParticipant(t, i) {
    if (this.remoteParticipants.has(t)) {
      const u = this.remoteParticipants.get(t);
      return i && u.updateInfo(i) && this.sidToIdentity.set(i.sid, i.identity), u;
    }
    const o = this.createParticipant(t, i);
    return this.remoteParticipants.set(t, o), this.sidToIdentity.set(i.sid, i.identity), this.emitWhenConnected(ne.ParticipantConnected, o), o.on(ce.TrackPublished, (u) => {
      this.emitWhenConnected(ne.TrackPublished, u, o);
    }).on(ce.TrackSubscribed, (u, d) => {
      u.kind === ue.Kind.Audio ? (u.on(Le.AudioPlaybackStarted, this.handleAudioPlaybackStarted), u.on(Le.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : u.kind === ue.Kind.Video && (u.on(Le.VideoPlaybackFailed, this.handleVideoPlaybackFailed), u.on(Le.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(ne.TrackSubscribed, u, d, o);
    }).on(ce.TrackUnpublished, (u) => {
      this.emit(ne.TrackUnpublished, u, o);
    }).on(ce.TrackUnsubscribed, (u, d) => {
      this.emit(ne.TrackUnsubscribed, u, d, o);
    }).on(ce.TrackSubscriptionFailed, (u) => {
      this.emit(ne.TrackSubscriptionFailed, u, o);
    }).on(ce.TrackMuted, (u) => {
      this.emitWhenConnected(ne.TrackMuted, u, o);
    }).on(ce.TrackUnmuted, (u) => {
      this.emitWhenConnected(ne.TrackUnmuted, u, o);
    }).on(ce.ParticipantMetadataChanged, (u) => {
      this.emitWhenConnected(ne.ParticipantMetadataChanged, u, o);
    }).on(ce.ParticipantNameChanged, (u) => {
      this.emitWhenConnected(ne.ParticipantNameChanged, u, o);
    }).on(ce.AttributesChanged, (u) => {
      this.emitWhenConnected(ne.ParticipantAttributesChanged, u, o);
    }).on(ce.ConnectionQualityChanged, (u) => {
      this.emitWhenConnected(ne.ConnectionQualityChanged, u, o);
    }).on(ce.ParticipantPermissionsChanged, (u) => {
      this.emitWhenConnected(ne.ParticipantPermissionsChanged, u, o);
    }).on(ce.TrackSubscriptionStatusChanged, (u, d) => {
      this.emitWhenConnected(ne.TrackSubscriptionStatusChanged, u, d, o);
    }).on(ce.TrackSubscriptionFailed, (u, d) => {
      this.emit(ne.TrackSubscriptionFailed, u, o, d);
    }).on(ce.TrackSubscriptionPermissionChanged, (u, d) => {
      this.emitWhenConnected(ne.TrackSubscriptionPermissionChanged, u, d, o);
    }), i && o.updateInfo(i), o;
  }
  sendSyncState() {
    const t = Array.from(this.remoteParticipants.values()).reduce((o, u) => (o.push(...u.getTrackPublications()), o), []), i = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(t, i);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const t of this.remoteParticipants.values())
      for (const i of t.videoTrackPublications.values())
        i.isSubscribed && i instanceof xv && i.emitTrackUpdate();
  }
  getRemoteParticipantBySid(t) {
    const i = this.sidToIdentity.get(t);
    if (i)
      return this.remoteParticipants.get(i);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let t = 0;
    this.connectionReconcileInterval = gi.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (t++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: t,
        engine: this.engine ? {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        } : void 0
      })), t >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, ls.STATE_MISMATCH))) : t = 0;
    }, wF);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && gi.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(t) {
    return t === this.state ? !1 : (this.state = t, this.emit(ne.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((t) => {
      let [i, o] = t;
      this.emit(i, ...o);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(t) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++)
      o[u - 1] = arguments[u];
    if (this.state === Yt.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([t, o]);
    else if (this.state === Yt.Connected)
      return this.emit(t, ...o);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(t) {
    return G(this, void 0, void 0, function* () {
      var i, o;
      const u = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, t.publish), d = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, t.participants);
      if (this.handleDisconnect(), this.roomInfo = new gE({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: Gn.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new wv({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(ne.SignalConnected), this.emit(ne.Connected), this.setAndEmitConnectionState(Yt.Connected), u.video) {
        const c = new _v(ue.Kind.Video, new Up({
          source: Hi.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: os.AUDIO,
          name: "video-dummy"
        }), new Bi(u.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : yx(160 * ((i = d.aspectRatios[0]) !== null && i !== void 0 ? i : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(c), this.localParticipant.emit(ce.LocalTrackPublished, c);
      }
      if (u.audio) {
        const c = new _v(ue.Kind.Audio, new Up({
          source: Hi.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: os.AUDIO
        }), new vi(u.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : lT(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(c), this.localParticipant.emit(ce.LocalTrackPublished, c);
      }
      for (let c = 0; c < d.count - 1; c += 1) {
        let m = new wv({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(c),
          state: _T.ACTIVE,
          tracks: [],
          joinedAt: Gn.parse(Date.now())
        });
        const g = this.getOrCreateParticipant(m.identity, m);
        if (d.video) {
          const b = yx(160 * ((o = d.aspectRatios[c % d.aspectRatios.length]) !== null && o !== void 0 ? o : 1), 160, !1, !0), C = new Up({
            source: Hi.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: os.AUDIO
          });
          g.addSubscribedMediaTrack(b, C.sid, new MediaStream([b]), new RTCRtpReceiver()), m.tracks = [...m.tracks, C];
        }
        if (d.audio) {
          const b = lT(), C = new Up({
            source: Hi.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: os.AUDIO
          });
          g.addSubscribedMediaTrack(b, C.sid, new MediaStream([b]), new RTCRtpReceiver()), m.tracks = [...m.tracks, C];
        }
        g.updateInfo(m);
      }
    });
  }
  // /** @internal */
  emit(t) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++)
      o[u - 1] = arguments[u];
    if (t !== ne.ActiveSpeakersChanged) {
      const d = XD(o).filter((c) => c !== void 0);
      this.log.debug("room event ".concat(t), Object.assign(Object.assign({}, this.logContext), {
        event: t,
        args: d
      }));
    }
    return super.emit(t, ...o);
  }
}
Ql.cleanupRegistry = typeof FinalizationRegistry < "u" && new FinalizationRegistry((r) => {
  r();
});
function XD(r) {
  return r.map((t) => {
    if (t)
      return Array.isArray(t) ? XD(t) : typeof t == "object" ? "logContext" in t && t.logContext : t;
  });
}
var is;
(function(r) {
  r[r.IDLE = 0] = "IDLE", r[r.RUNNING = 1] = "RUNNING", r[r.SKIPPED = 2] = "SKIPPED", r[r.SUCCESS = 3] = "SUCCESS", r[r.FAILED = 4] = "FAILED";
})(is || (is = {}));
class Zp extends rl.EventEmitter {
  constructor(t, i) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = is.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = t, this.token = i, this.name = this.constructor.name, this.room = new Ql(o.roomOptions), this.connectOptions = o.connectOptions, o.errorsAsWarnings && (this.errorsAsWarnings = o.errorsAsWarnings);
  }
  run(t) {
    return G(this, void 0, void 0, function* () {
      if (this.status !== is.IDLE)
        throw Error("check is running already");
      this.setStatus(is.RUNNING);
      try {
        yield this.perform();
      } catch (i) {
        i instanceof Error && (this.errorsAsWarnings ? this.appendWarning(i.message) : this.appendError(i.message));
      }
      return yield this.disconnect(), yield new Promise((i) => setTimeout(i, 500)), this.status !== is.SKIPPED && this.setStatus(this.isSuccess() ? is.SUCCESS : is.FAILED), t && t(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((t) => t.level === "error");
  }
  connect() {
    return G(this, void 0, void 0, function* () {
      return this.room.state === Yt.Connected ? this.room : (yield this.room.connect(this.url, this.token, this.connectOptions), this.room);
    });
  }
  disconnect() {
    return G(this, void 0, void 0, function* () {
      this.room && this.room.state !== Yt.Disconnected && (yield this.room.disconnect(), yield new Promise((t) => setTimeout(t, 500)));
    });
  }
  skip() {
    this.setStatus(is.SKIPPED);
  }
  appendMessage(t) {
    this.logs.push({
      level: "info",
      message: t
    }), this.emit("update", this.getInfo());
  }
  appendWarning(t) {
    this.logs.push({
      level: "warning",
      message: t
    }), this.emit("update", this.getInfo());
  }
  appendError(t) {
    this.logs.push({
      level: "error",
      message: t
    }), this.emit("update", this.getInfo());
  }
  setStatus(t) {
    this.status = t, this.emit("update", this.getInfo());
  }
  get engine() {
    var t;
    return (t = this.room) === null || t === void 0 ? void 0 : t.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function DE(r) {
  return G(this, void 0, void 0, function* () {
    var t, i;
    r ?? (r = {}), (t = r.audio) !== null && t !== void 0 || (r.audio = {
      deviceId: "default"
    }), (i = r.video) !== null && i !== void 0 || (r.video = {
      deviceId: "default"
    });
    const {
      audioProcessor: o,
      videoProcessor: u
    } = wE(r), d = jD(r, qD, WD), c = vb(d), m = navigator.mediaDevices.getUserMedia(c);
    r.audio && (Jr.userMediaPromiseMap.set("audioinput", m), m.catch(() => Jr.userMediaPromiseMap.delete("audioinput"))), r.video && (Jr.userMediaPromiseMap.set("videoinput", m), m.catch(() => Jr.userMediaPromiseMap.delete("videoinput")));
    const g = yield m;
    return Promise.all(g.getTracks().map((b) => G(this, void 0, void 0, function* () {
      const C = b.kind === "audio";
      C ? d.audio : d.video;
      let E;
      const x = C ? c.audio : c.video;
      typeof x != "boolean" && (E = x), E ? E.deviceId = b.getSettings().deviceId : E = {
        deviceId: b.getSettings().deviceId
      };
      const O = GD(b, E);
      return O.kind === ue.Kind.Video ? O.source = ue.Source.Camera : O.kind === ue.Kind.Audio && (O.source = ue.Source.Microphone), O.mediaStream = g, O instanceof vi && o ? yield O.setProcessor(o) : O instanceof Bi && u && (yield O.setProcessor(u)), O;
    })));
  });
}
function RF(r) {
  return G(this, void 0, void 0, function* () {
    return (yield DE({
      audio: !1,
      video: r
    }))[0];
  });
}
function _F(r) {
  return G(this, void 0, void 0, function* () {
    return (yield DE({
      audio: r,
      video: !1
    }))[0];
  });
}
class xF extends Zp {
  get description() {
    return "Can publish audio";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      var t;
      const i = yield this.connect(), o = yield _F();
      i.localParticipant.publishTrack(o), yield new Promise((c) => setTimeout(c, 3e3));
      const u = yield (t = o.sender) === null || t === void 0 ? void 0 : t.getStats();
      if (!u)
        throw new Error("Could not get RTCStats");
      let d = 0;
      if (u.forEach((c) => {
        c.type === "outbound-rtp" && (c.kind === "audio" || !c.kind && c.mediaType === "audio") && (d = c.packetsSent);
      }), d === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(d, " audio packets"));
    });
  }
}
class PF extends Zp {
  get description() {
    return "Can publish video";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      var t;
      const i = yield this.connect(), o = yield RF();
      i.localParticipant.publishTrack(o), yield new Promise((c) => setTimeout(c, 5e3));
      const u = yield (t = o.sender) === null || t === void 0 ? void 0 : t.getStats();
      if (!u)
        throw new Error("Could not get RTCStats");
      let d = 0;
      if (u.forEach((c) => {
        c.type === "outbound-rtp" && (c.kind === "video" || !c.kind && c.mediaType === "video") && (d += c.packetsSent);
      }), d === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(d, " video packets"));
    });
  }
}
class DF extends Zp {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      var t;
      const i = yield this.connect();
      let o = !1, u = !1, d;
      const c = new Promise((b) => {
        setTimeout(b, 5e3), d = b;
      }), m = () => {
        o = !0;
      };
      i.on(ne.SignalReconnecting, m).on(ne.Reconnecting, m).on(ne.Reconnected, () => {
        u = !0, d(!0);
      }), (t = i.engine.client.ws) === null || t === void 0 || t.close();
      const g = i.engine.client.onClose;
      if (g && g(""), yield c, o) {
        if (!u || i.state !== Yt.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class OF extends Zp {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      var t, i;
      const o = new RE(), u = yield o.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let d = !1, c = !1, m = !1;
      for (let g of u.iceServers)
        for (let b of g.urls)
          b.startsWith("turn:") ? (c = !0, m = !0) : b.startsWith("turns:") && (c = !0, m = !0, d = !0), b.startsWith("stun:") && (m = !0);
      m ? c && !d && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield o.close(), !((i = (t = this.connectOptions) === null || t === void 0 ? void 0 : t.rtcConfig) === null || i === void 0) && i.iceServers || c ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((g) => setTimeout(g, 0)));
    });
  }
}
class MF extends Zp {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      let t = !1, i = !1;
      this.room.on(ne.SignalConnected, () => {
        const o = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (u, d) => {
          if (u.candidate) {
            const c = new RTCIceCandidate(u);
            let m = "".concat(c.protocol, " ").concat(c.address, ":").concat(c.port, " ").concat(c.type);
            c.address && (NF(c.address) ? m += " (private)" : c.protocol === "tcp" && c.tcpType === "passive" ? (t = !0, m += " (passive)") : c.protocol === "udp" && (i = !0)), this.appendMessage(m);
          }
          o && o(u, d);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (u) => {
          u instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(u.errorCode, " ").concat(u.errorText, " ").concat(u.url));
        });
      });
      try {
        yield this.connect(), Wt.info("now the room is connected");
      } catch (o) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), o;
      }
      t || this.appendWarning("Server is not configured for ICE/TCP"), i || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function NF(r) {
  const t = r.split(".");
  if (t.length === 4) {
    if (t[0] === "10")
      return !0;
    if (t[0] === "192" && t[1] === "168")
      return !0;
    if (t[0] === "172") {
      const i = parseInt(t[1], 10);
      if (i >= 16 && i <= 31)
        return !0;
    }
  }
  return !1;
}
class LF extends Zp {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    return G(this, void 0, void 0, function* () {
      var t, i, o;
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let u = new RE();
      const d = yield u.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(d.serverVersion, ".")), ((t = d.serverInfo) === null || t === void 0 ? void 0 : t.edition) === qP.Cloud && (!((i = d.serverInfo) === null || i === void 0) && i.region) && this.appendMessage("LiveKit Cloud: ".concat((o = d.serverInfo) === null || o === void 0 ? void 0 : o.region)), yield u.close();
    });
  }
}
class d9 extends rl.EventEmitter {
  constructor(t, i) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.options = {}, this.checkResults = /* @__PURE__ */ new Map(), this.url = t, this.token = i, this.options = o;
  }
  getNextCheckId() {
    const t = this.checkResults.size;
    return this.checkResults.set(t, {
      logs: [],
      status: is.IDLE,
      name: "",
      description: ""
    }), t;
  }
  updateCheck(t, i) {
    this.checkResults.set(t, i), this.emit("checkUpdate", t, i);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((t) => t.status !== is.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(t) {
    return G(this, void 0, void 0, function* () {
      const i = this.getNextCheckId(), o = new t(this.url, this.token, this.options), u = (c) => {
        this.updateCheck(i, c);
      };
      o.on("update", u);
      const d = yield o.run();
      return o.off("update", u), d;
    });
  }
  checkWebsocket() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(LF);
    });
  }
  checkWebRTC() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(MF);
    });
  }
  checkTURN() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(OF);
    });
  }
  checkReconnect() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(DF);
    });
  }
  checkPublishAudio() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(xF);
    });
  }
  checkPublishVideo() {
    return G(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PF);
    });
  }
}
function ZD(r) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i;
  const o = r instanceof Ld ? r.mediaStreamTrack : r, u = o.getSettings();
  let d = {
    facingMode: (i = t.defaultFacingMode) !== null && i !== void 0 ? i : "user",
    confidence: "low"
  };
  if ("facingMode" in u) {
    const c = u.facingMode;
    Wt.trace("rawFacingMode", {
      rawFacingMode: c
    }), c && typeof c == "string" && UF(c) && (d = {
      facingMode: c,
      confidence: "high"
    });
  }
  if (["low", "medium"].includes(d.confidence)) {
    Wt.trace("Try to get facing mode from device label: (".concat(o.label, ")"));
    const c = IF(o.label);
    c !== void 0 && (d = c);
  }
  return d;
}
const jx = /* @__PURE__ */ new Map([["obs virtual camera", {
  facingMode: "environment",
  confidence: "medium"
}]]), AF = /* @__PURE__ */ new Map([["iphone", {
  facingMode: "environment",
  confidence: "medium"
}], ["ipad", {
  facingMode: "environment",
  confidence: "medium"
}]]);
function IF(r) {
  var t;
  const i = r.trim().toLowerCase();
  if (i !== "")
    return jx.has(i) ? jx.get(i) : (t = Array.from(AF.entries()).find((o) => {
      let [u] = o;
      return i.includes(u);
    })) === null || t === void 0 ? void 0 : t[1];
}
function UF(r) {
  return r === void 0 || ["user", "environment", "left", "right"].includes(r);
}
const ZT = Math.min, $p = Math.max, nb = Math.round, kc = (r) => ({
  x: r,
  y: r
}), FF = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, jF = {
  start: "end",
  end: "start"
};
function zx(r, t, i) {
  return $p(r, ZT(t, i));
}
function yb(r, t) {
  return typeof r == "function" ? r(t) : r;
}
function Fd(r) {
  return r.split("-")[0];
}
function bb(r) {
  return r.split("-")[1];
}
function eO(r) {
  return r === "x" ? "y" : "x";
}
function tO(r) {
  return r === "y" ? "height" : "width";
}
function Sb(r) {
  return ["top", "bottom"].includes(Fd(r)) ? "y" : "x";
}
function nO(r) {
  return eO(Sb(r));
}
function zF(r, t, i) {
  i === void 0 && (i = !1);
  const o = bb(r), u = nO(r), d = tO(u);
  let c = u === "x" ? o === (i ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[d] > t.floating[d] && (c = rb(c)), [c, rb(c)];
}
function VF(r) {
  const t = rb(r);
  return [eE(r), t, eE(t)];
}
function eE(r) {
  return r.replace(/start|end/g, (t) => jF[t]);
}
function BF(r, t, i) {
  const o = ["left", "right"], u = ["right", "left"], d = ["top", "bottom"], c = ["bottom", "top"];
  switch (r) {
    case "top":
    case "bottom":
      return i ? t ? u : o : t ? o : u;
    case "left":
    case "right":
      return t ? d : c;
    default:
      return [];
  }
}
function HF(r, t, i, o) {
  const u = bb(r);
  let d = BF(Fd(r), i === "start", o);
  return u && (d = d.map((c) => c + "-" + u), t && (d = d.concat(d.map(eE)))), d;
}
function rb(r) {
  return r.replace(/left|right|bottom|top/g, (t) => FF[t]);
}
function $F(r) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...r
  };
}
function qF(r) {
  return typeof r != "number" ? $F(r) : {
    top: r,
    right: r,
    bottom: r,
    left: r
  };
}
function ib(r) {
  const {
    x: t,
    y: i,
    width: o,
    height: u
  } = r;
  return {
    width: o,
    height: u,
    top: i,
    left: t,
    right: t + o,
    bottom: i + u,
    x: t,
    y: i
  };
}
function Vx(r, t, i) {
  let {
    reference: o,
    floating: u
  } = r;
  const d = Sb(t), c = nO(t), m = tO(c), g = Fd(t), b = d === "y", C = o.x + o.width / 2 - u.width / 2, E = o.y + o.height / 2 - u.height / 2, x = o[m] / 2 - u[m] / 2;
  let O;
  switch (g) {
    case "top":
      O = {
        x: C,
        y: o.y - u.height
      };
      break;
    case "bottom":
      O = {
        x: C,
        y: o.y + o.height
      };
      break;
    case "right":
      O = {
        x: o.x + o.width,
        y: E
      };
      break;
    case "left":
      O = {
        x: o.x - u.width,
        y: E
      };
      break;
    default:
      O = {
        x: o.x,
        y: o.y
      };
  }
  switch (bb(t)) {
    case "start":
      O[c] -= x * (i && b ? -1 : 1);
      break;
    case "end":
      O[c] += x * (i && b ? -1 : 1);
      break;
  }
  return O;
}
const WF = async (r, t, i) => {
  const {
    placement: o = "bottom",
    strategy: u = "absolute",
    middleware: d = [],
    platform: c
  } = i, m = d.filter(Boolean), g = await (c.isRTL == null ? void 0 : c.isRTL(t));
  let b = await c.getElementRects({
    reference: r,
    floating: t,
    strategy: u
  }), {
    x: C,
    y: E
  } = Vx(b, o, g), x = o, O = {}, N = 0;
  for (let M = 0; M < m.length; M++) {
    const {
      name: I,
      fn: U
    } = m[M], {
      x: ae,
      y: Z,
      data: B,
      reset: F
    } = await U({
      x: C,
      y: E,
      initialPlacement: o,
      placement: x,
      strategy: u,
      middlewareData: O,
      rects: b,
      platform: c,
      elements: {
        reference: r,
        floating: t
      }
    });
    C = ae ?? C, E = Z ?? E, O = {
      ...O,
      [I]: {
        ...O[I],
        ...B
      }
    }, F && N <= 50 && (N++, typeof F == "object" && (F.placement && (x = F.placement), F.rects && (b = F.rects === !0 ? await c.getElementRects({
      reference: r,
      floating: t,
      strategy: u
    }) : F.rects), {
      x: C,
      y: E
    } = Vx(b, x, g)), M = -1);
  }
  return {
    x: C,
    y: E,
    placement: x,
    strategy: u,
    middlewareData: O
  };
};
async function rO(r, t) {
  var i;
  t === void 0 && (t = {});
  const {
    x: o,
    y: u,
    platform: d,
    rects: c,
    elements: m,
    strategy: g
  } = r, {
    boundary: b = "clippingAncestors",
    rootBoundary: C = "viewport",
    elementContext: E = "floating",
    altBoundary: x = !1,
    padding: O = 0
  } = yb(t, r), N = qF(O), M = m[x ? E === "floating" ? "reference" : "floating" : E], I = ib(await d.getClippingRect({
    element: (i = await (d.isElement == null ? void 0 : d.isElement(M))) == null || i ? M : M.contextElement || await (d.getDocumentElement == null ? void 0 : d.getDocumentElement(m.floating)),
    boundary: b,
    rootBoundary: C,
    strategy: g
  })), U = E === "floating" ? {
    ...c.floating,
    x: o,
    y: u
  } : c.reference, ae = await (d.getOffsetParent == null ? void 0 : d.getOffsetParent(m.floating)), Z = await (d.isElement == null ? void 0 : d.isElement(ae)) ? await (d.getScale == null ? void 0 : d.getScale(ae)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = ib(d.convertOffsetParentRelativeRectToViewportRelativeRect ? await d.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: m,
    rect: U,
    offsetParent: ae,
    strategy: g
  }) : U);
  return {
    top: (I.top - B.top + N.top) / Z.y,
    bottom: (B.bottom - I.bottom + N.bottom) / Z.y,
    left: (I.left - B.left + N.left) / Z.x,
    right: (B.right - I.right + N.right) / Z.x
  };
}
const GF = function(r) {
  return r === void 0 && (r = {}), {
    name: "flip",
    options: r,
    async fn(t) {
      var i, o;
      const {
        placement: u,
        middlewareData: d,
        rects: c,
        initialPlacement: m,
        platform: g,
        elements: b
      } = t, {
        mainAxis: C = !0,
        crossAxis: E = !0,
        fallbackPlacements: x,
        fallbackStrategy: O = "bestFit",
        fallbackAxisSideDirection: N = "none",
        flipAlignment: M = !0,
        ...I
      } = yb(r, t);
      if ((i = d.arrow) != null && i.alignmentOffset)
        return {};
      const U = Fd(u), ae = Fd(m) === m, Z = await (g.isRTL == null ? void 0 : g.isRTL(b.floating)), B = x || (ae || !M ? [rb(m)] : VF(m));
      !x && N !== "none" && B.push(...HF(m, M, N, Z));
      const F = [m, ...B], K = await rO(t, I), te = [];
      let he = ((o = d.flip) == null ? void 0 : o.overflows) || [];
      if (C && te.push(K[U]), E) {
        const Ee = zF(u, c, Z);
        te.push(K[Ee[0]], K[Ee[1]]);
      }
      if (he = [...he, {
        placement: u,
        overflows: te
      }], !te.every((Ee) => Ee <= 0)) {
        var pe, ye;
        const Ee = (((pe = d.flip) == null ? void 0 : pe.index) || 0) + 1, Ne = F[Ee];
        if (Ne)
          return {
            data: {
              index: Ee,
              overflows: he
            },
            reset: {
              placement: Ne
            }
          };
        let Je = (ye = he.filter((vt) => vt.overflows[0] <= 0).sort((vt, Ct) => vt.overflows[1] - Ct.overflows[1])[0]) == null ? void 0 : ye.placement;
        if (!Je)
          switch (O) {
            case "bestFit": {
              var se;
              const vt = (se = he.map((Ct) => [Ct.placement, Ct.overflows.filter((Me) => Me > 0).reduce((Me, Pe) => Me + Pe, 0)]).sort((Ct, Me) => Ct[1] - Me[1])[0]) == null ? void 0 : se[0];
              vt && (Je = vt);
              break;
            }
            case "initialPlacement":
              Je = m;
              break;
          }
        if (u !== Je)
          return {
            reset: {
              placement: Je
            }
          };
      }
      return {};
    }
  };
};
async function YF(r, t) {
  const {
    placement: i,
    platform: o,
    elements: u
  } = r, d = await (o.isRTL == null ? void 0 : o.isRTL(u.floating)), c = Fd(i), m = bb(i), g = Sb(i) === "y", b = ["left", "top"].includes(c) ? -1 : 1, C = d && g ? -1 : 1, E = yb(t, r);
  let {
    mainAxis: x,
    crossAxis: O,
    alignmentAxis: N
  } = typeof E == "number" ? {
    mainAxis: E,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...E
  };
  return m && typeof N == "number" && (O = m === "end" ? N * -1 : N), g ? {
    x: O * C,
    y: x * b
  } : {
    x: x * b,
    y: O * C
  };
}
const KF = function(r) {
  return r === void 0 && (r = 0), {
    name: "offset",
    options: r,
    async fn(t) {
      var i, o;
      const {
        x: u,
        y: d,
        placement: c,
        middlewareData: m
      } = t, g = await YF(t, r);
      return c === ((i = m.offset) == null ? void 0 : i.placement) && (o = m.arrow) != null && o.alignmentOffset ? {} : {
        x: u + g.x,
        y: d + g.y,
        data: {
          ...g,
          placement: c
        }
      };
    }
  };
}, QF = function(r) {
  return r === void 0 && (r = {}), {
    name: "shift",
    options: r,
    async fn(t) {
      const {
        x: i,
        y: o,
        placement: u
      } = t, {
        mainAxis: d = !0,
        crossAxis: c = !1,
        limiter: m = {
          fn: (I) => {
            let {
              x: U,
              y: ae
            } = I;
            return {
              x: U,
              y: ae
            };
          }
        },
        ...g
      } = yb(r, t), b = {
        x: i,
        y: o
      }, C = await rO(t, g), E = Sb(Fd(u)), x = eO(E);
      let O = b[x], N = b[E];
      if (d) {
        const I = x === "y" ? "top" : "left", U = x === "y" ? "bottom" : "right", ae = O + C[I], Z = O - C[U];
        O = zx(ae, O, Z);
      }
      if (c) {
        const I = E === "y" ? "top" : "left", U = E === "y" ? "bottom" : "right", ae = N + C[I], Z = N - C[U];
        N = zx(ae, N, Z);
      }
      const M = m.fn({
        ...t,
        [x]: O,
        [E]: N
      });
      return {
        ...M,
        data: {
          x: M.x - i,
          y: M.y - o
        }
      };
    }
  };
};
function Cb() {
  return typeof window < "u";
}
function eh(r) {
  return iO(r) ? (r.nodeName || "").toLowerCase() : "#document";
}
function Xa(r) {
  var t;
  return (r == null || (t = r.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Jl(r) {
  var t;
  return (t = (iO(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : t.documentElement;
}
function iO(r) {
  return Cb() ? r instanceof Node || r instanceof Xa(r).Node : !1;
}
function ds(r) {
  return Cb() ? r instanceof Element || r instanceof Xa(r).Element : !1;
}
function nl(r) {
  return Cb() ? r instanceof HTMLElement || r instanceof Xa(r).HTMLElement : !1;
}
function Bx(r) {
  return !Cb() || typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof Xa(r).ShadowRoot;
}
function Mv(r) {
  const {
    overflow: t,
    overflowX: i,
    overflowY: o,
    display: u
  } = fs(r);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + i) && !["inline", "contents"].includes(u);
}
function JF(r) {
  return ["table", "td", "th"].includes(eh(r));
}
function kb(r) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return r.matches(t);
    } catch {
      return !1;
    }
  });
}
function OE(r) {
  const t = ME(), i = ds(r) ? fs(r) : r;
  return i.transform !== "none" || i.perspective !== "none" || (i.containerType ? i.containerType !== "normal" : !1) || !t && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !t && (i.filter ? i.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (i.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (i.contain || "").includes(o));
}
function XF(r) {
  let t = Tc(r);
  for (; nl(t) && !Qp(t); ) {
    if (OE(t))
      return t;
    if (kb(t))
      return null;
    t = Tc(t);
  }
  return null;
}
function ME() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Qp(r) {
  return ["html", "body", "#document"].includes(eh(r));
}
function fs(r) {
  return Xa(r).getComputedStyle(r);
}
function Tb(r) {
  return ds(r) ? {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  } : {
    scrollLeft: r.scrollX,
    scrollTop: r.scrollY
  };
}
function Tc(r) {
  if (eh(r) === "html")
    return r;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    r.assignedSlot || // DOM Element detected.
    r.parentNode || // ShadowRoot detected.
    Bx(r) && r.host || // Fallback.
    Jl(r)
  );
  return Bx(t) ? t.host : t;
}
function aO(r) {
  const t = Tc(r);
  return Qp(t) ? r.ownerDocument ? r.ownerDocument.body : r.body : nl(t) && Mv(t) ? t : aO(t);
}
function tE(r, t, i) {
  var o;
  t === void 0 && (t = []), i === void 0 && (i = !0);
  const u = aO(r), d = u === ((o = r.ownerDocument) == null ? void 0 : o.body), c = Xa(u);
  if (d) {
    const m = nE(c);
    return t.concat(c, c.visualViewport || [], Mv(u) ? u : [], m && i ? tE(m) : []);
  }
  return t.concat(u, tE(u, [], i));
}
function nE(r) {
  return r.parent && Object.getPrototypeOf(r.parent) ? r.frameElement : null;
}
function oO(r) {
  const t = fs(r);
  let i = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const u = nl(r), d = u ? r.offsetWidth : i, c = u ? r.offsetHeight : o, m = nb(i) !== d || nb(o) !== c;
  return m && (i = d, o = c), {
    width: i,
    height: o,
    $: m
  };
}
function sO(r) {
  return ds(r) ? r : r.contextElement;
}
function qp(r) {
  const t = sO(r);
  if (!nl(t))
    return kc(1);
  const i = t.getBoundingClientRect(), {
    width: o,
    height: u,
    $: d
  } = oO(t);
  let c = (d ? nb(i.width) : i.width) / o, m = (d ? nb(i.height) : i.height) / u;
  return (!c || !Number.isFinite(c)) && (c = 1), (!m || !Number.isFinite(m)) && (m = 1), {
    x: c,
    y: m
  };
}
const ZF = /* @__PURE__ */ kc(0);
function lO(r) {
  const t = Xa(r);
  return !ME() || !t.visualViewport ? ZF : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function e4(r, t, i) {
  return t === void 0 && (t = !1), !i || t && i !== Xa(r) ? !1 : t;
}
function Pv(r, t, i, o) {
  t === void 0 && (t = !1), i === void 0 && (i = !1);
  const u = r.getBoundingClientRect(), d = sO(r);
  let c = kc(1);
  t && (o ? ds(o) && (c = qp(o)) : c = qp(r));
  const m = e4(d, i, o) ? lO(d) : kc(0);
  let g = (u.left + m.x) / c.x, b = (u.top + m.y) / c.y, C = u.width / c.x, E = u.height / c.y;
  if (d) {
    const x = Xa(d), O = o && ds(o) ? Xa(o) : o;
    let N = x, M = nE(N);
    for (; M && o && O !== N; ) {
      const I = qp(M), U = M.getBoundingClientRect(), ae = fs(M), Z = U.left + (M.clientLeft + parseFloat(ae.paddingLeft)) * I.x, B = U.top + (M.clientTop + parseFloat(ae.paddingTop)) * I.y;
      g *= I.x, b *= I.y, C *= I.x, E *= I.y, g += Z, b += B, N = Xa(M), M = nE(N);
    }
  }
  return ib({
    width: C,
    height: E,
    x: g,
    y: b
  });
}
function t4(r) {
  let {
    elements: t,
    rect: i,
    offsetParent: o,
    strategy: u
  } = r;
  const d = u === "fixed", c = Jl(o), m = t ? kb(t.floating) : !1;
  if (o === c || m && d)
    return i;
  let g = {
    scrollLeft: 0,
    scrollTop: 0
  }, b = kc(1);
  const C = kc(0), E = nl(o);
  if ((E || !E && !d) && ((eh(o) !== "body" || Mv(c)) && (g = Tb(o)), nl(o))) {
    const x = Pv(o);
    b = qp(o), C.x = x.x + o.clientLeft, C.y = x.y + o.clientTop;
  }
  return {
    width: i.width * b.x,
    height: i.height * b.y,
    x: i.x * b.x - g.scrollLeft * b.x + C.x,
    y: i.y * b.y - g.scrollTop * b.y + C.y
  };
}
function n4(r) {
  return Array.from(r.getClientRects());
}
function rE(r, t) {
  const i = Tb(r).scrollLeft;
  return t ? t.left + i : Pv(Jl(r)).left + i;
}
function r4(r) {
  const t = Jl(r), i = Tb(r), o = r.ownerDocument.body, u = $p(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), d = $p(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let c = -i.scrollLeft + rE(r);
  const m = -i.scrollTop;
  return fs(o).direction === "rtl" && (c += $p(t.clientWidth, o.clientWidth) - u), {
    width: u,
    height: d,
    x: c,
    y: m
  };
}
function i4(r, t) {
  const i = Xa(r), o = Jl(r), u = i.visualViewport;
  let d = o.clientWidth, c = o.clientHeight, m = 0, g = 0;
  if (u) {
    d = u.width, c = u.height;
    const b = ME();
    (!b || b && t === "fixed") && (m = u.offsetLeft, g = u.offsetTop);
  }
  return {
    width: d,
    height: c,
    x: m,
    y: g
  };
}
function a4(r, t) {
  const i = Pv(r, !0, t === "fixed"), o = i.top + r.clientTop, u = i.left + r.clientLeft, d = nl(r) ? qp(r) : kc(1), c = r.clientWidth * d.x, m = r.clientHeight * d.y, g = u * d.x, b = o * d.y;
  return {
    width: c,
    height: m,
    x: g,
    y: b
  };
}
function Hx(r, t, i) {
  let o;
  if (t === "viewport")
    o = i4(r, i);
  else if (t === "document")
    o = r4(Jl(r));
  else if (ds(t))
    o = a4(t, i);
  else {
    const u = lO(r);
    o = {
      ...t,
      x: t.x - u.x,
      y: t.y - u.y
    };
  }
  return ib(o);
}
function uO(r, t) {
  const i = Tc(r);
  return i === t || !ds(i) || Qp(i) ? !1 : fs(i).position === "fixed" || uO(i, t);
}
function o4(r, t) {
  const i = t.get(r);
  if (i)
    return i;
  let o = tE(r, [], !1).filter((m) => ds(m) && eh(m) !== "body"), u = null;
  const d = fs(r).position === "fixed";
  let c = d ? Tc(r) : r;
  for (; ds(c) && !Qp(c); ) {
    const m = fs(c), g = OE(c);
    !g && m.position === "fixed" && (u = null), (d ? !g && !u : !g && m.position === "static" && u && ["absolute", "fixed"].includes(u.position) || Mv(c) && !g && uO(r, c)) ? o = o.filter((b) => b !== c) : u = m, c = Tc(c);
  }
  return t.set(r, o), o;
}
function s4(r) {
  let {
    element: t,
    boundary: i,
    rootBoundary: o,
    strategy: u
  } = r;
  const d = [...i === "clippingAncestors" ? kb(t) ? [] : o4(t, this._c) : [].concat(i), o], c = d[0], m = d.reduce((g, b) => {
    const C = Hx(t, b, u);
    return g.top = $p(C.top, g.top), g.right = ZT(C.right, g.right), g.bottom = ZT(C.bottom, g.bottom), g.left = $p(C.left, g.left), g;
  }, Hx(t, c, u));
  return {
    width: m.right - m.left,
    height: m.bottom - m.top,
    x: m.left,
    y: m.top
  };
}
function l4(r) {
  const {
    width: t,
    height: i
  } = oO(r);
  return {
    width: t,
    height: i
  };
}
function u4(r, t, i) {
  const o = nl(t), u = Jl(t), d = i === "fixed", c = Pv(r, !0, d, t);
  let m = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const g = kc(0);
  if (o || !o && !d)
    if ((eh(t) !== "body" || Mv(u)) && (m = Tb(t)), o) {
      const O = Pv(t, !0, d, t);
      g.x = O.x + t.clientLeft, g.y = O.y + t.clientTop;
    } else
      u && (g.x = rE(u));
  let b = 0, C = 0;
  if (u && !o && !d) {
    const O = u.getBoundingClientRect();
    C = O.top + m.scrollTop, b = O.left + m.scrollLeft - // RTL <body> scrollbar.
    rE(u, O);
  }
  const E = c.left + m.scrollLeft - g.x - b, x = c.top + m.scrollTop - g.y - C;
  return {
    x: E,
    y: x,
    width: c.width,
    height: c.height
  };
}
function vT(r) {
  return fs(r).position === "static";
}
function $x(r, t) {
  if (!nl(r) || fs(r).position === "fixed")
    return null;
  if (t)
    return t(r);
  let i = r.offsetParent;
  return Jl(r) === i && (i = i.ownerDocument.body), i;
}
function cO(r, t) {
  const i = Xa(r);
  if (kb(r))
    return i;
  if (!nl(r)) {
    let u = Tc(r);
    for (; u && !Qp(u); ) {
      if (ds(u) && !vT(u))
        return u;
      u = Tc(u);
    }
    return i;
  }
  let o = $x(r, t);
  for (; o && JF(o) && vT(o); )
    o = $x(o, t);
  return o && Qp(o) && vT(o) && !OE(o) ? i : o || XF(r) || i;
}
const c4 = async function(r) {
  const t = this.getOffsetParent || cO, i = this.getDimensions, o = await i(r.floating);
  return {
    reference: u4(r.reference, await t(r.floating), r.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function d4(r) {
  return fs(r).direction === "rtl";
}
const f4 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: t4,
  getDocumentElement: Jl,
  getClippingRect: s4,
  getOffsetParent: cO,
  getElementRects: c4,
  getClientRects: n4,
  getDimensions: l4,
  getScale: qp,
  isElement: ds,
  isRTL: d4
}, p4 = KF, h4 = QF, m4 = GF, v4 = (r, t, i) => {
  const o = /* @__PURE__ */ new Map(), u = {
    platform: f4,
    ...i
  }, d = {
    ...u.platform,
    _c: o
  };
  return WF(r, t, {
    ...u,
    platform: d
  });
};
var yv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function dO(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var fO = { exports: {} };
(function(r) {
  (function(t, i) {
    r.exports ? r.exports = i() : t.log = i();
  })(yv, function() {
    var t = function() {
    }, i = "undefined", o = typeof window !== i && typeof window.navigator !== i && /Trident\/|MSIE /.test(window.navigator.userAgent), u = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], d = {}, c = null;
    function m(M, I) {
      var U = M[I];
      if (typeof U.bind == "function")
        return U.bind(M);
      try {
        return Function.prototype.bind.call(U, M);
      } catch {
        return function() {
          return Function.prototype.apply.apply(U, [M, arguments]);
        };
      }
    }
    function g() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function b(M) {
      return M === "debug" && (M = "log"), typeof console === i ? !1 : M === "trace" && o ? g : console[M] !== void 0 ? m(console, M) : console.log !== void 0 ? m(console, "log") : t;
    }
    function C() {
      for (var M = this.getLevel(), I = 0; I < u.length; I++) {
        var U = u[I];
        this[U] = I < M ? t : this.methodFactory(U, M, this.name);
      }
      if (this.log = this.debug, typeof console === i && M < this.levels.SILENT)
        return "No console available for logging";
    }
    function E(M) {
      return function() {
        typeof console !== i && (C.call(this), this[M].apply(this, arguments));
      };
    }
    function x(M, I, U) {
      return b(M) || E.apply(this, arguments);
    }
    function O(M, I) {
      var U = this, ae, Z, B, F = "loglevel";
      typeof M == "string" ? F += ":" + M : typeof M == "symbol" && (F = void 0);
      function K(se) {
        var Ee = (u[se] || "silent").toUpperCase();
        if (!(typeof window === i || !F)) {
          try {
            window.localStorage[F] = Ee;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(F) + "=" + Ee + ";";
          } catch {
          }
        }
      }
      function te() {
        var se;
        if (!(typeof window === i || !F)) {
          try {
            se = window.localStorage[F];
          } catch {
          }
          if (typeof se === i)
            try {
              var Ee = window.document.cookie, Ne = encodeURIComponent(F), Je = Ee.indexOf(Ne + "=");
              Je !== -1 && (se = /^([^;]+)/.exec(
                Ee.slice(Je + Ne.length + 1)
              )[1]);
            } catch {
            }
          return U.levels[se] === void 0 && (se = void 0), se;
        }
      }
      function he() {
        if (!(typeof window === i || !F)) {
          try {
            window.localStorage.removeItem(F);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(F) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function pe(se) {
        var Ee = se;
        if (typeof Ee == "string" && U.levels[Ee.toUpperCase()] !== void 0 && (Ee = U.levels[Ee.toUpperCase()]), typeof Ee == "number" && Ee >= 0 && Ee <= U.levels.SILENT)
          return Ee;
        throw new TypeError("log.setLevel() called with invalid level: " + se);
      }
      U.name = M, U.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, U.methodFactory = I || x, U.getLevel = function() {
        return B ?? Z ?? ae;
      }, U.setLevel = function(se, Ee) {
        return B = pe(se), Ee !== !1 && K(B), C.call(U);
      }, U.setDefaultLevel = function(se) {
        Z = pe(se), te() || U.setLevel(se, !1);
      }, U.resetLevel = function() {
        B = null, he(), C.call(U);
      }, U.enableAll = function(se) {
        U.setLevel(U.levels.TRACE, se);
      }, U.disableAll = function(se) {
        U.setLevel(U.levels.SILENT, se);
      }, U.rebuild = function() {
        if (c !== U && (ae = pe(c.getLevel())), C.call(U), c === U)
          for (var se in d)
            d[se].rebuild();
      }, ae = pe(
        c ? c.getLevel() : "WARN"
      );
      var ye = te();
      ye != null && (B = pe(ye)), C.call(U);
    }
    c = new O(), c.getLogger = function(M) {
      if (typeof M != "symbol" && typeof M != "string" || M === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var I = d[M];
      return I || (I = d[M] = new O(
        M,
        c.methodFactory
      )), I;
    };
    var N = typeof window !== i ? window.log : void 0;
    return c.noConflict = function() {
      return typeof window !== i && window.log === c && (window.log = N), c;
    }, c.getLoggers = function() {
      return d;
    }, c.default = c, c;
  });
})(fO);
var g4 = fO.exports;
const y4 = /* @__PURE__ */ dO(g4);
var iE = function(r, t) {
  return iE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, o) {
    i.__proto__ = o;
  } || function(i, o) {
    for (var u in o)
      Object.prototype.hasOwnProperty.call(o, u) && (i[u] = o[u]);
  }, iE(r, t);
};
function Xl(r, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  iE(r, t);
  function i() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
function b4(r, t, i, o) {
  function u(d) {
    return d instanceof i ? d : new i(function(c) {
      c(d);
    });
  }
  return new (i || (i = Promise))(function(d, c) {
    function m(C) {
      try {
        b(o.next(C));
      } catch (E) {
        c(E);
      }
    }
    function g(C) {
      try {
        b(o.throw(C));
      } catch (E) {
        c(E);
      }
    }
    function b(C) {
      C.done ? d(C.value) : u(C.value).then(m, g);
    }
    b((o = o.apply(r, t || [])).next());
  });
}
function pO(r, t) {
  var i = { label: 0, sent: function() {
    if (d[0] & 1)
      throw d[1];
    return d[1];
  }, trys: [], ops: [] }, o, u, d, c = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return c.next = m(0), c.throw = m(1), c.return = m(2), typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function m(b) {
    return function(C) {
      return g([b, C]);
    };
  }
  function g(b) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; c && (c = 0, b[0] && (i = 0)), i; )
      try {
        if (o = 1, u && (d = b[0] & 2 ? u.return : b[0] ? u.throw || ((d = u.return) && d.call(u), 0) : u.next) && !(d = d.call(u, b[1])).done)
          return d;
        switch (u = 0, d && (b = [b[0] & 2, d.value]), b[0]) {
          case 0:
          case 1:
            d = b;
            break;
          case 4:
            return i.label++, { value: b[1], done: !1 };
          case 5:
            i.label++, u = b[1], b = [0];
            continue;
          case 7:
            b = i.ops.pop(), i.trys.pop();
            continue;
          default:
            if (d = i.trys, !(d = d.length > 0 && d[d.length - 1]) && (b[0] === 6 || b[0] === 2)) {
              i = 0;
              continue;
            }
            if (b[0] === 3 && (!d || b[1] > d[0] && b[1] < d[3])) {
              i.label = b[1];
              break;
            }
            if (b[0] === 6 && i.label < d[1]) {
              i.label = d[1], d = b;
              break;
            }
            if (d && i.label < d[2]) {
              i.label = d[2], i.ops.push(b);
              break;
            }
            d[2] && i.ops.pop(), i.trys.pop();
            continue;
        }
        b = t.call(r, i);
      } catch (C) {
        b = [6, C], u = 0;
      } finally {
        o = d = 0;
      }
    if (b[0] & 5)
      throw b[1];
    return { value: b[0] ? b[1] : void 0, done: !0 };
  }
}
function Jp(r) {
  var t = typeof Symbol == "function" && Symbol.iterator, i = t && r[t], o = 0;
  if (i)
    return i.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && o >= r.length && (r = void 0), { value: r && r[o++], done: !r };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Xp(r, t) {
  var i = typeof Symbol == "function" && r[Symbol.iterator];
  if (!i)
    return r;
  var o = i.call(r), u, d = [], c;
  try {
    for (; (t === void 0 || t-- > 0) && !(u = o.next()).done; )
      d.push(u.value);
  } catch (m) {
    c = { error: m };
  } finally {
    try {
      u && !u.done && (i = o.return) && i.call(o);
    } finally {
      if (c)
        throw c.error;
    }
  }
  return d;
}
function Dv(r, t, i) {
  if (i || arguments.length === 2)
    for (var o = 0, u = t.length, d; o < u; o++)
      (d || !(o in t)) && (d || (d = Array.prototype.slice.call(t, 0, o)), d[o] = t[o]);
  return r.concat(d || Array.prototype.slice.call(t));
}
function Wp(r) {
  return this instanceof Wp ? (this.v = r, this) : new Wp(r);
}
function S4(r, t, i) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var o = i.apply(r, t || []), u, d = [];
  return u = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), m("next"), m("throw"), m("return", c), u[Symbol.asyncIterator] = function() {
    return this;
  }, u;
  function c(O) {
    return function(N) {
      return Promise.resolve(N).then(O, E);
    };
  }
  function m(O, N) {
    o[O] && (u[O] = function(M) {
      return new Promise(function(I, U) {
        d.push([O, M, I, U]) > 1 || g(O, M);
      });
    }, N && (u[O] = N(u[O])));
  }
  function g(O, N) {
    try {
      b(o[O](N));
    } catch (M) {
      x(d[0][3], M);
    }
  }
  function b(O) {
    O.value instanceof Wp ? Promise.resolve(O.value.v).then(C, E) : x(d[0][2], O);
  }
  function C(O) {
    g("next", O);
  }
  function E(O) {
    g("throw", O);
  }
  function x(O, N) {
    O(N), d.shift(), d.length && g(d[0][0], d[0][1]);
  }
}
function C4(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = r[Symbol.asyncIterator], i;
  return t ? t.call(r) : (r = typeof Jp == "function" ? Jp(r) : r[Symbol.iterator](), i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function o(d) {
    i[d] = r[d] && function(c) {
      return new Promise(function(m, g) {
        c = r[d](c), u(m, g, c.done, c.value);
      });
    };
  }
  function u(d, c, m, g) {
    Promise.resolve(g).then(function(b) {
      d({ value: b, done: m });
    }, c);
  }
}
function Mn(r) {
  return typeof r == "function";
}
function NE(r) {
  var t = function(o) {
    Error.call(o), o.stack = new Error().stack;
  }, i = r(t);
  return i.prototype = Object.create(Error.prototype), i.prototype.constructor = i, i;
}
var gT = NE(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(i, o) {
      return o + 1 + ") " + i.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function ab(r, t) {
  if (r) {
    var i = r.indexOf(t);
    0 <= i && r.splice(i, 1);
  }
}
var Nv = function() {
  function r(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var t, i, o, u, d;
    if (!this.closed) {
      this.closed = !0;
      var c = this._parentage;
      if (c)
        if (this._parentage = null, Array.isArray(c))
          try {
            for (var m = Jp(c), g = m.next(); !g.done; g = m.next()) {
              var b = g.value;
              b.remove(this);
            }
          } catch (M) {
            t = { error: M };
          } finally {
            try {
              g && !g.done && (i = m.return) && i.call(m);
            } finally {
              if (t)
                throw t.error;
            }
          }
        else
          c.remove(this);
      var C = this.initialTeardown;
      if (Mn(C))
        try {
          C();
        } catch (M) {
          d = M instanceof gT ? M.errors : [M];
        }
      var E = this._finalizers;
      if (E) {
        this._finalizers = null;
        try {
          for (var x = Jp(E), O = x.next(); !O.done; O = x.next()) {
            var N = O.value;
            try {
              qx(N);
            } catch (M) {
              d = d ?? [], M instanceof gT ? d = Dv(Dv([], Xp(d)), Xp(M.errors)) : d.push(M);
            }
          }
        } catch (M) {
          o = { error: M };
        } finally {
          try {
            O && !O.done && (u = x.return) && u.call(x);
          } finally {
            if (o)
              throw o.error;
          }
        }
      }
      if (d)
        throw new gT(d);
    }
  }, r.prototype.add = function(t) {
    var i;
    if (t && t !== this)
      if (this.closed)
        qx(t);
      else {
        if (t instanceof r) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (i = this._finalizers) !== null && i !== void 0 ? i : []).push(t);
      }
  }, r.prototype._hasParent = function(t) {
    var i = this._parentage;
    return i === t || Array.isArray(i) && i.includes(t);
  }, r.prototype._addParent = function(t) {
    var i = this._parentage;
    this._parentage = Array.isArray(i) ? (i.push(t), i) : i ? [i, t] : t;
  }, r.prototype._removeParent = function(t) {
    var i = this._parentage;
    i === t ? this._parentage = null : Array.isArray(i) && ab(i, t);
  }, r.prototype.remove = function(t) {
    var i = this._finalizers;
    i && ab(i, t), t instanceof r && t._removeParent(this);
  }, r.EMPTY = function() {
    var t = new r();
    return t.closed = !0, t;
  }(), r;
}(), hO = Nv.EMPTY;
function mO(r) {
  return r instanceof Nv || r && "closed" in r && Mn(r.remove) && Mn(r.add) && Mn(r.unsubscribe);
}
function qx(r) {
  Mn(r) ? r() : r.unsubscribe();
}
var vO = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, k4 = {
  setTimeout: function(r, t) {
    for (var i = [], o = 2; o < arguments.length; o++)
      i[o - 2] = arguments[o];
    return setTimeout.apply(void 0, Dv([r, t], Xp(i)));
  },
  clearTimeout: function(r) {
    return clearTimeout(r);
  },
  delegate: void 0
};
function gO(r) {
  k4.setTimeout(function() {
    throw r;
  });
}
function ob() {
}
function Y0(r) {
  r();
}
var LE = function(r) {
  Xl(t, r);
  function t(i) {
    var o = r.call(this) || this;
    return o.isStopped = !1, i ? (o.destination = i, mO(i) && i.add(o)) : o.destination = R4, o;
  }
  return t.create = function(i, o, u) {
    return new aE(i, o, u);
  }, t.prototype.next = function(i) {
    this.isStopped || this._next(i);
  }, t.prototype.error = function(i) {
    this.isStopped || (this.isStopped = !0, this._error(i));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(i) {
    this.destination.next(i);
  }, t.prototype._error = function(i) {
    try {
      this.destination.error(i);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(Nv), T4 = Function.prototype.bind;
function yT(r, t) {
  return T4.call(r, t);
}
var E4 = function() {
  function r(t) {
    this.partialObserver = t;
  }
  return r.prototype.next = function(t) {
    var i = this.partialObserver;
    if (i.next)
      try {
        i.next(t);
      } catch (o) {
        O0(o);
      }
  }, r.prototype.error = function(t) {
    var i = this.partialObserver;
    if (i.error)
      try {
        i.error(t);
      } catch (o) {
        O0(o);
      }
    else
      O0(t);
  }, r.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (i) {
        O0(i);
      }
  }, r;
}(), aE = function(r) {
  Xl(t, r);
  function t(i, o, u) {
    var d = r.call(this) || this, c;
    if (Mn(i) || !i)
      c = {
        next: i ?? void 0,
        error: o ?? void 0,
        complete: u ?? void 0
      };
    else {
      var m;
      d && vO.useDeprecatedNextContext ? (m = Object.create(i), m.unsubscribe = function() {
        return d.unsubscribe();
      }, c = {
        next: i.next && yT(i.next, m),
        error: i.error && yT(i.error, m),
        complete: i.complete && yT(i.complete, m)
      }) : c = i;
    }
    return d.destination = new E4(c), d;
  }
  return t;
}(LE);
function O0(r) {
  gO(r);
}
function w4(r) {
  throw r;
}
var R4 = {
  closed: !0,
  next: ob,
  error: w4,
  complete: ob
}, AE = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function IE(r) {
  return r;
}
function _4(r) {
  return r.length === 0 ? IE : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(i, o) {
      return o(i);
    }, t);
  };
}
var Xr = function() {
  function r(t) {
    t && (this._subscribe = t);
  }
  return r.prototype.lift = function(t) {
    var i = new r();
    return i.source = this, i.operator = t, i;
  }, r.prototype.subscribe = function(t, i, o) {
    var u = this, d = P4(t) ? t : new aE(t, i, o);
    return Y0(function() {
      var c = u, m = c.operator, g = c.source;
      d.add(m ? m.call(d, g) : g ? u._subscribe(d) : u._trySubscribe(d));
    }), d;
  }, r.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (i) {
      t.error(i);
    }
  }, r.prototype.forEach = function(t, i) {
    var o = this;
    return i = Wx(i), new i(function(u, d) {
      var c = new aE({
        next: function(m) {
          try {
            t(m);
          } catch (g) {
            d(g), c.unsubscribe();
          }
        },
        error: d,
        complete: u
      });
      o.subscribe(c);
    });
  }, r.prototype._subscribe = function(t) {
    var i;
    return (i = this.source) === null || i === void 0 ? void 0 : i.subscribe(t);
  }, r.prototype[AE] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    return _4(t)(this);
  }, r.prototype.toPromise = function(t) {
    var i = this;
    return t = Wx(t), new t(function(o, u) {
      var d;
      i.subscribe(function(c) {
        return d = c;
      }, function(c) {
        return u(c);
      }, function() {
        return o(d);
      });
    });
  }, r.create = function(t) {
    return new r(t);
  }, r;
}();
function Wx(r) {
  var t;
  return (t = r ?? vO.Promise) !== null && t !== void 0 ? t : Promise;
}
function x4(r) {
  return r && Mn(r.next) && Mn(r.error) && Mn(r.complete);
}
function P4(r) {
  return r && r instanceof LE || x4(r) && mO(r);
}
function D4(r) {
  return Mn(r == null ? void 0 : r.lift);
}
function Eo(r) {
  return function(t) {
    if (D4(t))
      return t.lift(function(i) {
        try {
          return r(i, this);
        } catch (o) {
          this.error(o);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function ps(r, t, i, o, u) {
  return new O4(r, t, i, o, u);
}
var O4 = function(r) {
  Xl(t, r);
  function t(i, o, u, d, c, m) {
    var g = r.call(this, i) || this;
    return g.onFinalize = c, g.shouldUnsubscribe = m, g._next = o ? function(b) {
      try {
        o(b);
      } catch (C) {
        i.error(C);
      }
    } : r.prototype._next, g._error = d ? function(b) {
      try {
        d(b);
      } catch (C) {
        i.error(C);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, g._complete = u ? function() {
      try {
        u();
      } catch (b) {
        i.error(b);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, g;
  }
  return t.prototype.unsubscribe = function() {
    var i;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var o = this.closed;
      r.prototype.unsubscribe.call(this), !o && ((i = this.onFinalize) === null || i === void 0 || i.call(this));
    }
  }, t;
}(LE), M4 = NE(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Ec = function(r) {
  Xl(t, r);
  function t() {
    var i = r.call(this) || this;
    return i.closed = !1, i.currentObservers = null, i.observers = [], i.isStopped = !1, i.hasError = !1, i.thrownError = null, i;
  }
  return t.prototype.lift = function(i) {
    var o = new Gx(this, this);
    return o.operator = i, o;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new M4();
  }, t.prototype.next = function(i) {
    var o = this;
    Y0(function() {
      var u, d;
      if (o._throwIfClosed(), !o.isStopped) {
        o.currentObservers || (o.currentObservers = Array.from(o.observers));
        try {
          for (var c = Jp(o.currentObservers), m = c.next(); !m.done; m = c.next()) {
            var g = m.value;
            g.next(i);
          }
        } catch (b) {
          u = { error: b };
        } finally {
          try {
            m && !m.done && (d = c.return) && d.call(c);
          } finally {
            if (u)
              throw u.error;
          }
        }
      }
    });
  }, t.prototype.error = function(i) {
    var o = this;
    Y0(function() {
      if (o._throwIfClosed(), !o.isStopped) {
        o.hasError = o.isStopped = !0, o.thrownError = i;
        for (var u = o.observers; u.length; )
          u.shift().error(i);
      }
    });
  }, t.prototype.complete = function() {
    var i = this;
    Y0(function() {
      if (i._throwIfClosed(), !i.isStopped) {
        i.isStopped = !0;
        for (var o = i.observers; o.length; )
          o.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var i;
      return ((i = this.observers) === null || i === void 0 ? void 0 : i.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._trySubscribe = function(i) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, i);
  }, t.prototype._subscribe = function(i) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(i), this._innerSubscribe(i);
  }, t.prototype._innerSubscribe = function(i) {
    var o = this, u = this, d = u.hasError, c = u.isStopped, m = u.observers;
    return d || c ? hO : (this.currentObservers = null, m.push(i), new Nv(function() {
      o.currentObservers = null, ab(m, i);
    }));
  }, t.prototype._checkFinalizedStatuses = function(i) {
    var o = this, u = o.hasError, d = o.thrownError, c = o.isStopped;
    u ? i.error(d) : c && i.complete();
  }, t.prototype.asObservable = function() {
    var i = new Xr();
    return i.source = this, i;
  }, t.create = function(i, o) {
    return new Gx(i, o);
  }, t;
}(Xr), Gx = function(r) {
  Xl(t, r);
  function t(i, o) {
    var u = r.call(this) || this;
    return u.destination = i, u.source = o, u;
  }
  return t.prototype.next = function(i) {
    var o, u;
    (u = (o = this.destination) === null || o === void 0 ? void 0 : o.next) === null || u === void 0 || u.call(o, i);
  }, t.prototype.error = function(i) {
    var o, u;
    (u = (o = this.destination) === null || o === void 0 ? void 0 : o.error) === null || u === void 0 || u.call(o, i);
  }, t.prototype.complete = function() {
    var i, o;
    (o = (i = this.destination) === null || i === void 0 ? void 0 : i.complete) === null || o === void 0 || o.call(i);
  }, t.prototype._subscribe = function(i) {
    var o, u;
    return (u = (o = this.source) === null || o === void 0 ? void 0 : o.subscribe(i)) !== null && u !== void 0 ? u : hO;
  }, t;
}(Ec), yO = function(r) {
  Xl(t, r);
  function t(i) {
    var o = r.call(this) || this;
    return o._value = i, o;
  }
  return Object.defineProperty(t.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._subscribe = function(i) {
    var o = r.prototype._subscribe.call(this, i);
    return !o.closed && i.next(this._value), o;
  }, t.prototype.getValue = function() {
    var i = this, o = i.hasError, u = i.thrownError, d = i._value;
    if (o)
      throw u;
    return this._throwIfClosed(), d;
  }, t.prototype.next = function(i) {
    r.prototype.next.call(this, this._value = i);
  }, t;
}(Ec), N4 = {
  now: function() {
    return Date.now();
  },
  delegate: void 0
}, L4 = function(r) {
  Xl(t, r);
  function t(i, o) {
    return r.call(this) || this;
  }
  return t.prototype.schedule = function(i, o) {
    return this;
  }, t;
}(Nv), Yx = {
  setInterval: function(r, t) {
    for (var i = [], o = 2; o < arguments.length; o++)
      i[o - 2] = arguments[o];
    return setInterval.apply(void 0, Dv([r, t], Xp(i)));
  },
  clearInterval: function(r) {
    return clearInterval(r);
  },
  delegate: void 0
}, A4 = function(r) {
  Xl(t, r);
  function t(i, o) {
    var u = r.call(this, i, o) || this;
    return u.scheduler = i, u.work = o, u.pending = !1, u;
  }
  return t.prototype.schedule = function(i, o) {
    var u;
    if (o === void 0 && (o = 0), this.closed)
      return this;
    this.state = i;
    var d = this.id, c = this.scheduler;
    return d != null && (this.id = this.recycleAsyncId(c, d, o)), this.pending = !0, this.delay = o, this.id = (u = this.id) !== null && u !== void 0 ? u : this.requestAsyncId(c, this.id, o), this;
  }, t.prototype.requestAsyncId = function(i, o, u) {
    return u === void 0 && (u = 0), Yx.setInterval(i.flush.bind(i, this), u);
  }, t.prototype.recycleAsyncId = function(i, o, u) {
    if (u === void 0 && (u = 0), u != null && this.delay === u && this.pending === !1)
      return o;
    o != null && Yx.clearInterval(o);
  }, t.prototype.execute = function(i, o) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var u = this._execute(i, o);
    if (u)
      return u;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, t.prototype._execute = function(i, o) {
    var u = !1, d;
    try {
      this.work(i);
    } catch (c) {
      u = !0, d = c || new Error("Scheduled action threw falsy error");
    }
    if (u)
      return this.unsubscribe(), d;
  }, t.prototype.unsubscribe = function() {
    if (!this.closed) {
      var i = this, o = i.id, u = i.scheduler, d = u.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, ab(d, this), o != null && (this.id = this.recycleAsyncId(u, o, null)), this.delay = null, r.prototype.unsubscribe.call(this);
    }
  }, t;
}(L4), Kx = function() {
  function r(t, i) {
    i === void 0 && (i = r.now), this.schedulerActionCtor = t, this.now = i;
  }
  return r.prototype.schedule = function(t, i, o) {
    return i === void 0 && (i = 0), new this.schedulerActionCtor(this, t).schedule(o, i);
  }, r.now = N4.now, r;
}(), I4 = function(r) {
  Xl(t, r);
  function t(i, o) {
    o === void 0 && (o = Kx.now);
    var u = r.call(this, i, o) || this;
    return u.actions = [], u._active = !1, u;
  }
  return t.prototype.flush = function(i) {
    var o = this.actions;
    if (this._active) {
      o.push(i);
      return;
    }
    var u;
    this._active = !0;
    do
      if (u = i.execute(i.state, i.delay))
        break;
    while (i = o.shift());
    if (this._active = !1, u) {
      for (; i = o.shift(); )
        i.unsubscribe();
      throw u;
    }
  }, t;
}(Kx), U4 = new I4(A4), F4 = new Xr(function(r) {
  return r.complete();
});
function j4(r) {
  return r && Mn(r.schedule);
}
function bO(r) {
  return r[r.length - 1];
}
function Eb(r) {
  return j4(bO(r)) ? r.pop() : void 0;
}
function z4(r, t) {
  return typeof bO(r) == "number" ? r.pop() : t;
}
var UE = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function SO(r) {
  return Mn(r == null ? void 0 : r.then);
}
function CO(r) {
  return Mn(r[AE]);
}
function kO(r) {
  return Symbol.asyncIterator && Mn(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function TO(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function V4() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var EO = V4();
function wO(r) {
  return Mn(r == null ? void 0 : r[EO]);
}
function RO(r) {
  return S4(this, arguments, function() {
    var t, i, o, u;
    return pO(this, function(d) {
      switch (d.label) {
        case 0:
          t = r.getReader(), d.label = 1;
        case 1:
          d.trys.push([1, , 9, 10]), d.label = 2;
        case 2:
          return [4, Wp(t.read())];
        case 3:
          return i = d.sent(), o = i.value, u = i.done, u ? [4, Wp(void 0)] : [3, 5];
        case 4:
          return [2, d.sent()];
        case 5:
          return [4, Wp(o)];
        case 6:
          return [4, d.sent()];
        case 7:
          return d.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function _O(r) {
  return Mn(r == null ? void 0 : r.getReader);
}
function il(r) {
  if (r instanceof Xr)
    return r;
  if (r != null) {
    if (CO(r))
      return B4(r);
    if (UE(r))
      return H4(r);
    if (SO(r))
      return $4(r);
    if (kO(r))
      return xO(r);
    if (wO(r))
      return q4(r);
    if (_O(r))
      return W4(r);
  }
  throw TO(r);
}
function B4(r) {
  return new Xr(function(t) {
    var i = r[AE]();
    if (Mn(i.subscribe))
      return i.subscribe(t);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function H4(r) {
  return new Xr(function(t) {
    for (var i = 0; i < r.length && !t.closed; i++)
      t.next(r[i]);
    t.complete();
  });
}
function $4(r) {
  return new Xr(function(t) {
    r.then(function(i) {
      t.closed || (t.next(i), t.complete());
    }, function(i) {
      return t.error(i);
    }).then(null, gO);
  });
}
function q4(r) {
  return new Xr(function(t) {
    var i, o;
    try {
      for (var u = Jp(r), d = u.next(); !d.done; d = u.next()) {
        var c = d.value;
        if (t.next(c), t.closed)
          return;
      }
    } catch (m) {
      i = { error: m };
    } finally {
      try {
        d && !d.done && (o = u.return) && o.call(u);
      } finally {
        if (i)
          throw i.error;
      }
    }
    t.complete();
  });
}
function xO(r) {
  return new Xr(function(t) {
    G4(r, t).catch(function(i) {
      return t.error(i);
    });
  });
}
function W4(r) {
  return xO(RO(r));
}
function G4(r, t) {
  var i, o, u, d;
  return b4(this, void 0, void 0, function() {
    var c, m;
    return pO(this, function(g) {
      switch (g.label) {
        case 0:
          g.trys.push([0, 5, 6, 11]), i = C4(r), g.label = 1;
        case 1:
          return [4, i.next()];
        case 2:
          if (o = g.sent(), !!o.done)
            return [3, 4];
          if (c = o.value, t.next(c), t.closed)
            return [2];
          g.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return m = g.sent(), u = { error: m }, [3, 11];
        case 6:
          return g.trys.push([6, , 9, 10]), o && !o.done && (d = i.return) ? [4, d.call(i)] : [3, 8];
        case 7:
          g.sent(), g.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (u)
            throw u.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function bc(r, t, i, o, u) {
  o === void 0 && (o = 0), u === void 0 && (u = !1);
  var d = t.schedule(function() {
    i(), u ? r.add(this.schedule(null, o)) : this.unsubscribe();
  }, o);
  if (r.add(d), !u)
    return d;
}
function PO(r, t) {
  return t === void 0 && (t = 0), Eo(function(i, o) {
    i.subscribe(ps(o, function(u) {
      return bc(o, r, function() {
        return o.next(u);
      }, t);
    }, function() {
      return bc(o, r, function() {
        return o.complete();
      }, t);
    }, function(u) {
      return bc(o, r, function() {
        return o.error(u);
      }, t);
    }));
  });
}
function DO(r, t) {
  return t === void 0 && (t = 0), Eo(function(i, o) {
    o.add(r.schedule(function() {
      return i.subscribe(o);
    }, t));
  });
}
function Y4(r, t) {
  return il(r).pipe(DO(t), PO(t));
}
function K4(r, t) {
  return il(r).pipe(DO(t), PO(t));
}
function Q4(r, t) {
  return new Xr(function(i) {
    var o = 0;
    return t.schedule(function() {
      o === r.length ? i.complete() : (i.next(r[o++]), i.closed || this.schedule());
    });
  });
}
function J4(r, t) {
  return new Xr(function(i) {
    var o;
    return bc(i, t, function() {
      o = r[EO](), bc(i, t, function() {
        var u, d, c;
        try {
          u = o.next(), d = u.value, c = u.done;
        } catch (m) {
          i.error(m);
          return;
        }
        c ? i.complete() : i.next(d);
      }, 0, !0);
    }), function() {
      return Mn(o == null ? void 0 : o.return) && o.return();
    };
  });
}
function OO(r, t) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new Xr(function(i) {
    bc(i, t, function() {
      var o = r[Symbol.asyncIterator]();
      bc(i, t, function() {
        o.next().then(function(u) {
          u.done ? i.complete() : i.next(u.value);
        });
      }, 0, !0);
    });
  });
}
function X4(r, t) {
  return OO(RO(r), t);
}
function Z4(r, t) {
  if (r != null) {
    if (CO(r))
      return Y4(r, t);
    if (UE(r))
      return Q4(r, t);
    if (SO(r))
      return K4(r, t);
    if (kO(r))
      return OO(r, t);
    if (wO(r))
      return J4(r, t);
    if (_O(r))
      return X4(r, t);
  }
  throw TO(r);
}
function FE(r, t) {
  return t ? Z4(r, t) : il(r);
}
function Qx() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  var i = Eb(r);
  return FE(r, i);
}
function ej(r) {
  return r instanceof Date && !isNaN(r);
}
var tj = NE(function(r) {
  return function(t) {
    t === void 0 && (t = null), r(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = t;
  };
});
function nj(r, t) {
  var i = ej(r) ? { first: r } : typeof r == "number" ? { each: r } : r, o = i.first, u = i.each, d = i.with, c = d === void 0 ? rj : d, m = i.scheduler, g = m === void 0 ? U4 : m, b = i.meta, C = b === void 0 ? null : b;
  if (o == null && u == null)
    throw new TypeError("No timeout provided.");
  return Eo(function(E, x) {
    var O, N, M = null, I = 0, U = function(ae) {
      N = bc(x, g, function() {
        try {
          O.unsubscribe(), il(c({
            meta: C,
            lastValue: M,
            seen: I
          })).subscribe(x);
        } catch (Z) {
          x.error(Z);
        }
      }, ae);
    };
    O = E.subscribe(ps(x, function(ae) {
      N == null || N.unsubscribe(), I++, x.next(M = ae), u > 0 && U(u);
    }, void 0, void 0, function() {
      N != null && N.closed || N == null || N.unsubscribe(), M = null;
    })), !I && U(o != null ? typeof o == "number" ? o : +o - g.now() : u);
  });
}
function rj(r) {
  throw new tj(r);
}
function gr(r, t) {
  return Eo(function(i, o) {
    var u = 0;
    i.subscribe(ps(o, function(d) {
      o.next(r.call(t, d, u++));
    }));
  });
}
var ij = Array.isArray;
function aj(r, t) {
  return ij(t) ? r.apply(void 0, Dv([], Xp(t))) : r(t);
}
function oj(r) {
  return gr(function(t) {
    return aj(r, t);
  });
}
function sj(r, t, i, o, u, d, c, m) {
  var g = [], b = 0, C = 0, E = !1, x = function() {
    E && !g.length && !b && t.complete();
  }, O = function(M) {
    return b < o ? N(M) : g.push(M);
  }, N = function(M) {
    b++;
    var I = !1;
    il(i(M, C++)).subscribe(ps(t, function(U) {
      t.next(U);
    }, function() {
      I = !0;
    }, void 0, function() {
      if (I)
        try {
          b--;
          for (var U = function() {
            var ae = g.shift();
            c || N(ae);
          }; g.length && b < o; )
            U();
          x();
        } catch (ae) {
          t.error(ae);
        }
    }));
  };
  return r.subscribe(ps(t, O, function() {
    E = !0, x();
  })), function() {
  };
}
function jE(r, t, i) {
  return i === void 0 && (i = 1 / 0), Mn(t) ? jE(function(o, u) {
    return gr(function(d, c) {
      return t(o, d, u, c);
    })(il(r(o, u)));
  }, i) : (typeof t == "number" && (i = t), Eo(function(o, u) {
    return sj(o, u, r, i);
  }));
}
function MO(r) {
  return r === void 0 && (r = 1 / 0), jE(IE, r);
}
function lj() {
  return MO(1);
}
function sb() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  return lj()(FE(r, Eb(r)));
}
var uj = ["addListener", "removeListener"], cj = ["addEventListener", "removeEventListener"], dj = ["on", "off"];
function oE(r, t, i, o) {
  if (Mn(i) && (o = i, i = void 0), o)
    return oE(r, t, i).pipe(oj(o));
  var u = Xp(hj(r) ? cj.map(function(m) {
    return function(g) {
      return r[m](t, g, i);
    };
  }) : fj(r) ? uj.map(Jx(r, t)) : pj(r) ? dj.map(Jx(r, t)) : [], 2), d = u[0], c = u[1];
  if (!d && UE(r))
    return jE(function(m) {
      return oE(m, t, i);
    })(il(r));
  if (!d)
    throw new TypeError("Invalid event target");
  return new Xr(function(m) {
    var g = function() {
      for (var b = [], C = 0; C < arguments.length; C++)
        b[C] = arguments[C];
      return m.next(1 < b.length ? b : b[0]);
    };
    return d(g), function() {
      return c(g);
    };
  });
}
function Jx(r, t) {
  return function(i) {
    return function(o) {
      return r[i](t, o);
    };
  };
}
function fj(r) {
  return Mn(r.addListener) && Mn(r.removeListener);
}
function pj(r) {
  return Mn(r.on) && Mn(r.off);
}
function hj(r) {
  return Mn(r.addEventListener) && Mn(r.removeEventListener);
}
function mj() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  var i = Eb(r), o = z4(r, 1 / 0), u = r;
  return u.length ? u.length === 1 ? il(u[0]) : MO(o)(FE(u, i)) : F4;
}
function zE(r, t) {
  return Eo(function(i, o) {
    var u = 0;
    i.subscribe(ps(o, function(d) {
      return r.call(t, d, u++) && o.next(d);
    }));
  });
}
function vj(r, t, i, o, u) {
  return function(d, c) {
    var m = i, g = t, b = 0;
    d.subscribe(ps(c, function(C) {
      var E = b++;
      g = m ? r(g, C, E) : (m = !0, C), c.next(g);
    }, u));
  };
}
function gj(r, t) {
  return t === void 0 && (t = IE), r = r ?? yj, Eo(function(i, o) {
    var u, d = !0;
    i.subscribe(ps(o, function(c) {
      var m = t(c);
      (d || !r(u, m)) && (d = !1, u = m, o.next(c));
    }));
  });
}
function yj(r, t) {
  return r === t;
}
function bj(r) {
  return Eo(function(t, i) {
    try {
      t.subscribe(i);
    } finally {
      i.add(r);
    }
  });
}
function Sj(r, t) {
  return Eo(vj(r, t, arguments.length >= 2, !0));
}
function Cj(r) {
  return Eo(function(t, i) {
    var o = !1, u = ps(i, function() {
      u == null || u.unsubscribe(), o = !0;
    }, ob);
    il(r).subscribe(u), t.subscribe(ps(i, function(d) {
      return o && i.next(d);
    }));
  });
}
function wo() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  var i = Eb(r);
  return Eo(function(o, u) {
    (i ? sb(r, o, i) : sb(r, o)).subscribe(u);
  });
}
function Xx(r) {
  return Eo(function(t, i) {
    il(r).subscribe(ps(i, function() {
      return i.complete();
    }, ob)), !i.closed && t.subscribe(i);
  });
}
var kj = Object.defineProperty, Tj = Object.defineProperties, Ej = Object.getOwnPropertyDescriptors, Zx = Object.getOwnPropertySymbols, wj = Object.prototype.hasOwnProperty, Rj = Object.prototype.propertyIsEnumerable, eP = (r, t, i) => t in r ? kj(r, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[t] = i, gc = (r, t) => {
  for (var i in t || (t = {}))
    wj.call(t, i) && eP(r, i, t[i]);
  if (Zx)
    for (var i of Zx(t))
      Rj.call(t, i) && eP(r, i, t[i]);
  return r;
}, M0 = (r, t) => Tj(r, Ej(t)), Za = (r, t, i) => new Promise((o, u) => {
  var d = (g) => {
    try {
      m(i.next(g));
    } catch (b) {
      u(b);
    }
  }, c = (g) => {
    try {
      m(i.throw(g));
    } catch (b) {
      u(b);
    }
  }, m = (g) => g.done ? o(g.value) : Promise.resolve(g.value).then(d, c);
  m((i = i.apply(r, t)).next());
}), NO = "lk";
function Ua(r) {
  return typeof r > "u" ? !1 : _j(r) || xj(r);
}
function _j(r) {
  var t;
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && r.hasOwnProperty("track") && typeof ((t = r.publication) == null ? void 0 : t.track) < "u" : !1;
}
function xj(r) {
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && r.hasOwnProperty("publication") && typeof r.publication < "u" : !1;
}
function Ov(r) {
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && typeof r.publication > "u" : !1;
}
function $i(r) {
  if (typeof r == "string" || typeof r == "number")
    return `${r}`;
  if (Ov(r))
    return `${r.participant.identity}_${r.source}_placeholder`;
  if (Ua(r))
    return `${r.participant.identity}_${r.publication.source}_${r.publication.trackSid}`;
  throw new Error(`Can't generate a id for the given track reference: ${r}`);
}
function LO(r, t) {
  return typeof t > "u" ? !1 : Ua(r) ? t.some(
    (i) => i.participant.identity === r.participant.identity && Ua(i) && i.publication.trackSid === r.publication.trackSid
  ) : Ov(r) ? t.some(
    (i) => i.participant.identity === r.participant.identity && Ov(i) && i.source === r.source
  ) : !1;
}
function Pj(r, t) {
  return Ov(r) && Ua(t) && t.participant.identity === r.participant.identity && t.source === r.source;
}
function Dj() {
  const r = document.createElement("p");
  r.style.width = "100%", r.style.height = "200px";
  const t = document.createElement("div");
  t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.visibility = "hidden", t.style.width = "200px", t.style.height = "150px", t.style.overflow = "hidden", t.appendChild(r), document.body.appendChild(t);
  const i = r.offsetWidth;
  t.style.overflow = "scroll";
  let o = r.offsetWidth;
  return i === o && (o = t.clientWidth), document.body.removeChild(t), i - o;
}
function Oj(r) {
  r = gc({}, r);
  const t = "(?:(?:[a-z]+:)?//)?", i = "(?:\\S+(?::\\S*)?@)?", o = new RegExp(
    "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
    "g"
  ).source, u = `(?:${t}|www\\.)${i}(?:localhost|${o}|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))\\.?)(?::\\d{2,5})?(?:[/?#][^\\s"]*)?`;
  return r.exact ? new RegExp(`(?:^${u}$)`, "i") : new RegExp(u, "ig");
}
var tP = "[^\\.\\s@:](?:[^\\s@:]*[^\\s@:\\.])?@[^\\.\\s@]+(?:\\.[^\\.\\s@]+)*";
function Mj({ exact: r } = {}) {
  return r ? new RegExp(`^${tP}$`) : new RegExp(tP, "g");
}
function Nj(r, t) {
  return Za(this, null, function* () {
    const { x: i, y: o } = yield v4(r, t, {
      placement: "top",
      middleware: [p4(6), m4(), h4({ padding: 5 })]
    });
    return { x: i, y: o };
  });
}
function Lj(r, t) {
  return !r.contains(t.target);
}
var Aj = () => ({
  email: Mj(),
  url: Oj({})
});
function Ij(r, t) {
  const i = Object.entries(t).map(
    ([d, c], m) => Array.from(r.matchAll(c)).map(({ index: g, 0: b }) => ({
      type: d,
      weight: m,
      content: b,
      index: g ?? 0
    }))
  ).flat().sort((d, c) => {
    const m = d.index - c.index;
    return m !== 0 ? m : d.weight - c.weight;
  }).filter(({ index: d }, c, m) => {
    if (c === 0)
      return !0;
    const g = m[c - 1];
    return g.index + g.content.length <= d;
  }), o = [];
  let u = 0;
  for (const { type: d, content: c, index: m } of i)
    m > u && o.push(r.substring(u, m)), o.push({ type: d, content: c }), u = m + c.length;
  return r.length > u && o.push(r.substring(u)), o;
}
var Uj = [
  ne.ConnectionStateChanged,
  ne.RoomMetadataChanged,
  ne.ActiveSpeakersChanged,
  ne.ConnectionQualityChanged,
  ne.ParticipantConnected,
  ne.ParticipantDisconnected,
  ne.ParticipantPermissionsChanged,
  ne.ParticipantMetadataChanged,
  ne.ParticipantNameChanged,
  ne.ParticipantAttributesChanged,
  ne.TrackMuted,
  ne.TrackUnmuted,
  ne.TrackPublished,
  ne.TrackUnpublished,
  ne.TrackStreamStateChanged,
  ne.TrackSubscriptionFailed,
  ne.TrackSubscriptionPermissionChanged,
  ne.TrackSubscriptionStatusChanged
], Fj = [
  ...Uj,
  ne.LocalTrackPublished,
  ne.LocalTrackUnpublished
];
ce.TrackPublished, ce.TrackUnpublished, ce.TrackMuted, ce.TrackUnmuted, ce.TrackStreamStateChanged, ce.TrackSubscribed, ce.TrackUnsubscribed, ce.TrackSubscriptionPermissionChanged, ce.TrackSubscriptionFailed, ce.LocalTrackPublished, ce.LocalTrackUnpublished;
var jj = [
  ce.ConnectionQualityChanged,
  ce.IsSpeakingChanged,
  ce.ParticipantMetadataChanged,
  ce.ParticipantPermissionsChanged,
  ce.TrackMuted,
  ce.TrackUnmuted,
  ce.TrackPublished,
  ce.TrackUnpublished,
  ce.TrackStreamStateChanged,
  ce.TrackSubscriptionFailed,
  ce.TrackSubscriptionPermissionChanged,
  ce.TrackSubscriptionStatusChanged
];
[
  ...jj,
  ce.LocalTrackPublished,
  ce.LocalTrackUnpublished
];
var Ht = y4.getLogger("lk-components-js");
Ht.setDefaultLevel("WARN");
var zj = [
  {
    columns: 1,
    rows: 1
  },
  {
    columns: 1,
    rows: 2,
    orientation: "portrait"
  },
  {
    columns: 2,
    rows: 1,
    orientation: "landscape"
  },
  {
    columns: 2,
    rows: 2,
    minWidth: 560
  },
  {
    columns: 3,
    rows: 3,
    minWidth: 700
  },
  {
    columns: 4,
    rows: 4,
    minWidth: 960
  },
  {
    columns: 5,
    rows: 5,
    minWidth: 1100
  }
];
function AO(r, t, i, o) {
  if (r.length < 1)
    throw new Error("At least one grid layout definition must be provided.");
  const u = Vj(r);
  if (i <= 0 || o <= 0)
    return u[0];
  let d = 0;
  const c = i / o > 1 ? "landscape" : "portrait";
  let m = u.find((g, b, C) => {
    d = b;
    const E = C.findIndex((x, O) => {
      const N = !x.orientation || x.orientation === c, M = O > b, I = x.maxTiles === g.maxTiles;
      return M && I && N;
    }) !== -1;
    return g.maxTiles >= t && !E;
  });
  if (m === void 0)
    if (m = u[u.length - 1], m)
      Ht.warn(
        `No layout found for: participantCount: ${t}, width/height: ${i}/${o} fallback to biggest available layout (${m}).`
      );
    else
      throw new Error("No layout or fallback layout found.");
  if ((i < m.minWidth || o < m.minHeight) && d > 0) {
    const g = u[d - 1];
    m = AO(
      u.slice(0, d),
      g.maxTiles,
      i,
      o
    );
  }
  return m;
}
function Vj(r) {
  return [...r].map((t) => {
    var i, o;
    return {
      name: `${t.columns}x${t.rows}`,
      columns: t.columns,
      rows: t.rows,
      maxTiles: t.columns * t.rows,
      minWidth: (i = t.minWidth) != null ? i : 0,
      minHeight: (o = t.minHeight) != null ? o : 0,
      orientation: t.orientation
    };
  }).sort((t, i) => t.maxTiles !== i.maxTiles ? t.maxTiles - i.maxTiles : t.minWidth !== 0 || i.minWidth !== 0 ? t.minWidth - i.minWidth : t.minHeight !== 0 || i.minHeight !== 0 ? t.minHeight - i.minHeight : 0);
}
function Bj() {
  return typeof navigator < "u" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;
}
var IO = [], UO = {
  showChat: !1,
  unreadMessages: 0,
  showSettings: !1
};
function FO(r) {
  return typeof r == "object";
}
function jO(r) {
  return Array.isArray(r) && r.filter(FO).length > 0;
}
function Hj(r, t) {
  return t.audioLevel - r.audioLevel;
}
function $j(r, t) {
  return r.isSpeaking === t.isSpeaking ? 0 : r.isSpeaking ? -1 : 1;
}
function qj(r, t) {
  var i, o, u, d;
  return r.lastSpokeAt !== void 0 || t.lastSpokeAt !== void 0 ? ((o = (i = t.lastSpokeAt) == null ? void 0 : i.getTime()) != null ? o : 0) - ((d = (u = r.lastSpokeAt) == null ? void 0 : u.getTime()) != null ? d : 0) : 0;
}
function sE(r, t) {
  var i, o, u, d;
  return ((o = (i = r.joinedAt) == null ? void 0 : i.getTime()) != null ? o : 0) - ((d = (u = t.joinedAt) == null ? void 0 : u.getTime()) != null ? d : 0);
}
function Wj(r, t) {
  return Ua(r) ? Ua(t) ? 0 : -1 : Ua(t) ? 1 : 0;
}
function Gj(r, t) {
  const i = r.participant.isCameraEnabled, o = t.participant.isCameraEnabled;
  return i !== o ? i ? -1 : 1 : 0;
}
function Yj(r) {
  const t = [], i = [], o = [], u = [];
  r.forEach((m) => {
    m.participant.isLocal && m.source === ue.Source.Camera ? t.push(m) : m.source === ue.Source.ScreenShare ? i.push(m) : m.source === ue.Source.Camera ? o.push(m) : u.push(m);
  });
  const d = Kj(i), c = Qj(o);
  return [...t, ...d, ...c, ...u];
}
function Kj(r) {
  const t = [], i = [];
  return r.forEach((o) => {
    o.participant.isLocal ? t.push(o) : i.push(o);
  }), t.sort((o, u) => sE(o.participant, u.participant)), i.sort((o, u) => sE(o.participant, u.participant)), [...i, ...t];
}
function Qj(r) {
  const t = [], i = [];
  return r.forEach((o) => {
    o.participant.isLocal ? t.push(o) : i.push(o);
  }), i.sort((o, u) => o.participant.isSpeaking && u.participant.isSpeaking ? Hj(o.participant, u.participant) : o.participant.isSpeaking !== u.participant.isSpeaking ? $j(o.participant, u.participant) : o.participant.lastSpokeAt !== u.participant.lastSpokeAt ? qj(o.participant, u.participant) : Ua(o) !== Ua(u) ? Wj(o, u) : o.participant.isCameraEnabled !== u.participant.isCameraEnabled ? Gj(o, u) : sE(o.participant, u.participant)), [...t, ...i];
}
function Jj(r, t) {
  return r.reduce(
    (i, o, u) => u % t === 0 ? [...i, [o]] : [...i.slice(0, -1), [...i.slice(-1)[0], o]],
    []
  );
}
function nP(r, t) {
  const i = Math.max(r.length, t.length);
  return new Array(i).fill([]).map((o, u) => [r[u], t[u]]);
}
function lb(r, t, i) {
  return r.filter((o) => !t.map((u) => i(u)).includes(i(o)));
}
function lE(r) {
  return r.map((t) => typeof t == "string" || typeof t == "number" ? `${t}` : $i(t));
}
function Xj(r, t) {
  return {
    dropped: lb(r, t, $i),
    added: lb(t, r, $i)
  };
}
function Zj(r) {
  return r.added.length !== 0 || r.dropped.length !== 0;
}
function uE(r, t) {
  const i = t.findIndex(
    (o) => $i(o) === $i(r)
  );
  if (i === -1)
    throw new Error(
      `Element not part of the array: ${$i(
        r
      )} not in ${lE(t)}`
    );
  return i;
}
function e6(r, t, i) {
  const o = uE(r, i), u = uE(t, i);
  return i.splice(o, 1, t), i.splice(u, 1, r), i;
}
function t6(r, t) {
  const i = uE(r, t);
  return t.splice(i, 1), t;
}
function n6(r, t) {
  return [...t, r];
}
function bT(r, t) {
  return Jj(r, t);
}
function r6(r, t, i) {
  let o = i6(r, t);
  if (o.length < t.length) {
    const c = lb(t, o, $i);
    o = [...o, ...c];
  }
  const u = bT(o, i), d = bT(t, i);
  if (nP(u, d).forEach(([c, m], g) => {
    if (c && m) {
      const b = bT(o, i)[g], C = Xj(b, m);
      Zj(C) && (Ht.debug(
        `Detected visual changes on page: ${g}, current: ${lE(
          c
        )}, next: ${lE(m)}`,
        { changes: C }
      ), C.added.length === C.dropped.length && nP(C.added, C.dropped).forEach(([E, x]) => {
        if (E && x)
          o = e6(E, x, o);
        else
          throw new Error(
            `For a swap action we need a addition and a removal one is missing: ${E}, ${x}`
          );
      }), C.added.length === 0 && C.dropped.length > 0 && C.dropped.forEach((E) => {
        o = t6(E, o);
      }), C.added.length > 0 && C.dropped.length === 0 && C.added.forEach((E) => {
        o = n6(E, o);
      }));
    }
  }), o.length > t.length) {
    const c = lb(o, t, $i);
    o = o.filter(
      (m) => !c.map($i).includes($i(m))
    );
  }
  return o;
}
function i6(r, t) {
  return r.map((i) => t.find(
    (u) => (
      // If the IDs match or ..
      $i(i) === $i(u) || // ... if the current item is a placeholder and the new item is the track reference can replace it.
      typeof i != "number" && Ov(i) && Ua(u) && Pj(i, u)
    )
  ) ?? i);
}
function Fa(r) {
  return `${NO}-${r}`;
}
function a6(r) {
  const t = cE(r), i = zO(r.participant).pipe(
    gr(() => cE(r)),
    wo(t)
  );
  return { className: Fa(
    r.source === ue.Source.Camera || r.source === ue.Source.ScreenShare ? "participant-media-video" : "participant-media-audio"
  ), trackObserver: i };
}
function cE(r) {
  if (Ua(r))
    return r.publication;
  {
    const { source: t, name: i, participant: o } = r;
    if (t && i)
      return o.getTrackPublications().find((u) => u.source === t && u.trackName === i);
    if (i)
      return o.getTrackPublicationByName(i);
    if (t)
      return o.getTrackPublication(t);
    throw new Error("At least one of source and name needs to be defined");
  }
}
function VE(r, ...t) {
  return new Xr((i) => {
    const o = () => {
      i.next(r);
    };
    return t.forEach((u) => {
      r.on(u, o);
    }), () => {
      t.forEach((u) => {
        r.off(u, o);
      });
    };
  }).pipe(wo(r));
}
function th(r, t) {
  return new Xr((i) => {
    const o = (...u) => {
      i.next(u);
    };
    return r.on(t, o), () => {
      r.off(t, o);
    };
  });
}
function o6(r) {
  return th(r, ne.ConnectionStateChanged).pipe(
    gr(([t]) => t),
    wo(r.state)
  );
}
function s6(r, t, i = !0) {
  var o;
  const u = () => Za(this, null, function* () {
    try {
      const m = yield Ql.getLocalDevices(r, i);
      d.next(m);
    } catch (m) {
      t == null || t(m);
    }
  }), d = new Ec(), c = d.pipe(
    bj(() => {
      var m;
      (m = navigator == null ? void 0 : navigator.mediaDevices) == null || m.removeEventListener("devicechange", u);
    })
  );
  if (typeof window < "u") {
    if (!window.isSecureContext)
      throw new Error(
        "Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices"
      );
    (o = navigator == null ? void 0 : navigator.mediaDevices) == null || o.addEventListener("devicechange", u);
  }
  return sb(
    Ql.getLocalDevices(r, i).catch((m) => (t == null || t(m), [])),
    c
  );
}
function l6(r) {
  return th(r, ne.DataReceived);
}
function u6(r) {
  return th(r, ne.ChatMessage);
}
function c6(r) {
  return VE(r, ne.AudioPlaybackStatusChanged).pipe(
    gr((t) => ({ canPlayAudio: t.canPlaybackAudio }))
  );
}
function d6(r) {
  return VE(r, ne.VideoPlaybackStatusChanged).pipe(
    gr((t) => ({ canPlayVideo: t.canPlaybackVideo }))
  );
}
function f6(r, t) {
  return th(r, ne.ActiveDeviceChanged).pipe(
    zE(([i]) => i === t),
    gr(([i, o]) => (Ht.debug("activeDeviceObservable | RoomEvent.ActiveDeviceChanged", { kind: i, deviceId: o }), o))
  );
}
function p6(r, t) {
  return th(r, ne.ParticipantEncryptionStatusChanged).pipe(
    zE(
      ([, i]) => (t == null ? void 0 : t.identity) === (i == null ? void 0 : i.identity) || !i && (t == null ? void 0 : t.identity) === r.localParticipant.identity
    ),
    gr(([i]) => i),
    wo(
      t != null && t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)
    )
  );
}
function h6(r) {
  return th(r, ne.RecordingStatusChanged).pipe(
    gr(([t]) => t),
    wo(r.isRecording)
  );
}
function BE(r, ...t) {
  return new Xr((i) => {
    const o = () => {
      i.next(r);
    };
    return t.forEach((u) => {
      r.on(u, o);
    }), () => {
      t.forEach((u) => {
        r.off(u, o);
      });
    };
  }).pipe(wo(r));
}
function zO(r) {
  return BE(
    r,
    ce.TrackMuted,
    ce.TrackUnmuted,
    ce.ParticipantPermissionsChanged,
    // ParticipantEvent.IsSpeakingChanged,
    ce.TrackPublished,
    ce.TrackUnpublished,
    ce.LocalTrackPublished,
    ce.LocalTrackUnpublished,
    ce.MediaDevicesError,
    ce.TrackSubscriptionStatusChanged
    // ParticipantEvent.ConnectionQualityChanged,
  ).pipe(
    gr((t) => {
      const { isMicrophoneEnabled: i, isCameraEnabled: o, isScreenShareEnabled: u } = t, d = t.getTrackPublication(ue.Source.Microphone), c = t.getTrackPublication(ue.Source.Camera);
      return {
        isCameraEnabled: o,
        isMicrophoneEnabled: i,
        isScreenShareEnabled: u,
        cameraTrack: c,
        microphoneTrack: d,
        participant: t
      };
    })
  );
}
function m6(r) {
  return r ? BE(
    r,
    ce.ParticipantMetadataChanged,
    ce.ParticipantNameChanged
  ).pipe(
    gr(({ name: t, identity: i, metadata: o }) => ({
      name: t,
      identity: i,
      metadata: o
    })),
    wo({
      name: r.name,
      identity: r.identity,
      metadata: r.metadata
    })
  ) : void 0;
}
function v6(r) {
  return HE(
    r,
    ce.ConnectionQualityChanged
  ).pipe(
    gr(([t]) => t),
    wo(r.connectionQuality)
  );
}
function HE(r, t) {
  return new Xr((i) => {
    const o = (...u) => {
      i.next(u);
    };
    return r.on(t, o), () => {
      r.off(t, o);
    };
  });
}
function VO(r) {
  var t, i, o, u;
  return BE(
    r.participant,
    ce.TrackMuted,
    ce.TrackUnmuted,
    ce.TrackSubscribed,
    ce.TrackUnsubscribed,
    ce.LocalTrackPublished,
    ce.LocalTrackUnpublished
  ).pipe(
    gr((d) => {
      var c, m;
      const g = (c = r.publication) != null ? c : d.getTrackPublication(r.source);
      return (m = g == null ? void 0 : g.isMuted) != null ? m : !0;
    }),
    wo(
      (u = (o = (t = r.publication) == null ? void 0 : t.isMuted) != null ? o : (i = r.participant.getTrackPublication(r.source)) == null ? void 0 : i.isMuted) != null ? u : !0
    )
  );
}
function g6(r) {
  return HE(r, ce.IsSpeakingChanged).pipe(
    gr(([t]) => t)
  );
}
function y6(r) {
  return HE(
    r,
    ce.ParticipantPermissionsChanged
  ).pipe(
    gr(() => r.permissions),
    wo(r.permissions)
  );
}
function b6(r, t, i, o, u) {
  const { localParticipant: d } = t, c = (C, E) => {
    let x = !1;
    switch (C) {
      case ue.Source.Camera:
        x = E.isCameraEnabled;
        break;
      case ue.Source.Microphone:
        x = E.isMicrophoneEnabled;
        break;
      case ue.Source.ScreenShare:
        x = E.isScreenShareEnabled;
        break;
    }
    return x;
  }, m = zO(d).pipe(
    gr((C) => c(r, C.participant)),
    wo(c(r, d))
  ), g = new Ec(), b = (C, E) => Za(this, null, function* () {
    try {
      switch (E ?? (E = i), g.next(!0), r) {
        case ue.Source.Camera:
          return yield d.setCameraEnabled(
            C ?? !d.isCameraEnabled,
            E,
            o
          ), d.isCameraEnabled;
        case ue.Source.Microphone:
          return yield d.setMicrophoneEnabled(
            C ?? !d.isMicrophoneEnabled,
            E,
            o
          ), d.isMicrophoneEnabled;
        case ue.Source.ScreenShare:
          return yield d.setScreenShareEnabled(
            C ?? !d.isScreenShareEnabled,
            E,
            o
          ), d.isScreenShareEnabled;
        default:
          throw new TypeError("Tried to toggle unsupported source");
      }
    } catch (x) {
      if (u && x instanceof Error) {
        u == null || u(x);
        return;
      } else
        throw x;
    } finally {
      g.next(!1);
    }
  });
  return {
    className: Fa("button"),
    toggle: b,
    enabledObserver: m,
    pendingObserver: g.asObservable()
  };
}
function S6() {
  let r = !1;
  const t = new Ec(), i = new Ec(), o = (u) => Za(this, null, function* () {
    i.next(!0), r = u ?? !r, t.next(r), i.next(!1);
  });
  return {
    className: Fa("button"),
    toggle: o,
    enabledObserver: t.asObservable(),
    pendingObserver: i.asObservable()
  };
}
function C6(r, t, i) {
  const o = new yO(void 0), u = t ? f6(t, r) : o.asObservable(), d = (c, ...m) => Za(this, [c, ...m], function* (g, b = {}) {
    var C, E, x;
    if (t) {
      Ht.debug(`Switching active device of kind "${r}" with id ${g}.`), yield t.switchActiveDevice(r, g, b.exact);
      const O = (C = t.getActiveDevice(r)) != null ? C : g;
      O !== g && g !== "default" && Ht.info(
        `We tried to select the device with id (${g}), but the browser decided to select the device with id (${O}) instead.`
      );
      let N;
      r === "audioinput" ? N = (E = t.localParticipant.getTrackPublication(ue.Source.Microphone)) == null ? void 0 : E.track : r === "videoinput" && (N = (x = t.localParticipant.getTrackPublication(ue.Source.Camera)) == null ? void 0 : x.track);
      const M = g === "default" && !N || g === "default" && (N == null ? void 0 : N.mediaStreamTrack.label.startsWith("Default"));
      o.next(M ? g : O);
    } else if (i) {
      yield i.setDeviceId(b.exact ? { exact: g } : g);
      const O = yield i.getDeviceId();
      o.next(
        g === "default" && i.mediaStreamTrack.label.startsWith("Default") ? g : O
      );
    } else
      o.value !== g && (Ht.warn(
        "device switch skipped, please provide either a room or a local track to switch on. "
      ), o.next(g));
  });
  return {
    className: Fa("media-device-select"),
    activeDeviceObservable: u,
    setActiveMediaDevice: d
  };
}
function k6(r) {
  const t = (i) => {
    r.disconnect(i);
  };
  return { className: Fa("disconnect-button"), disconnect: t };
}
function T6(r) {
  const t = Fa("connection-quality"), i = v6(r);
  return { className: t, connectionQualityObserver: i };
}
function E6(r) {
  let t = "track-muted-indicator-camera";
  switch (r.source) {
    case ue.Source.Camera:
      t = "track-muted-indicator-camera";
      break;
    case ue.Source.Microphone:
      t = "track-muted-indicator-microphone";
      break;
  }
  const i = Fa(t), o = VO(r);
  return { className: i, mediaMutedObserver: o };
}
function w6(r) {
  return { className: "lk-participant-name", infoObserver: m6(r) };
}
function R6() {
  return {
    className: Fa("participant-tile")
  };
}
var rP = {
  CHAT: "lk-chat-topic",
  CHAT_UPDATE: "lk-chat-update-topic"
};
function dE(r, t) {
  return Za(this, arguments, function* (i, o, u = {}) {
    const { reliable: d, destinationIdentities: c, topic: m } = u;
    yield i.publishData(o, {
      destinationIdentities: c,
      topic: m,
      reliable: d
    });
  });
}
function _6(r, t, i) {
  const o = Array.isArray(t) ? t : [t], u = l6(r).pipe(
    zE(
      ([, , , m]) => t === void 0 || m !== void 0 && o.includes(m)
    ),
    gr(([m, g, , b]) => {
      const C = {
        payload: m,
        topic: b,
        from: g
      };
      return i == null || i(C), C;
    })
  );
  let d;
  const c = new Xr((m) => {
    d = m;
  });
  return { messageObservable: u, isSendingObservable: c, send: (m, ...g) => Za(this, [m, ...g], function* (b, C = {}) {
    d.next(!0);
    try {
      yield dE(r.localParticipant, b, gc({ topic: o[0] }, C));
    } finally {
      d.next(!1);
    }
  }) };
}
function x6(r) {
  return { chatObservable: u6(r), send: (t) => Za(this, null, function* () {
    return yield r.localParticipant.sendChatMessage(t);
  }), edit: (t, i) => Za(this, null, function* () {
    return yield r.localParticipant.editChatMessage(t, i);
  }) };
}
var P6 = new TextEncoder(), D6 = new TextDecoder(), N0 = /* @__PURE__ */ new Map(), O6 = (r) => P6.encode(JSON.stringify(r)), M6 = (r) => JSON.parse(D6.decode(r));
function N6(r, t) {
  var i, o;
  const u = new Ec(), d = () => {
    var he, pe, ye;
    return ((he = r.serverInfo) == null ? void 0 : he.edition) === 1 || !!((pe = r.serverInfo) != null && pe.version) && Ud((ye = r.serverInfo) == null ? void 0 : ye.version, "1.17.2") > 0;
  }, { messageDecoder: c, messageEncoder: m, channelTopic: g, updateChannelTopic: b } = t ?? {}, C = g ?? rP.CHAT, E = b ?? rP.CHAT_UPDATE;
  let x = !1;
  N0.has(r) || (x = !0);
  const O = (i = N0.get(r)) != null ? i : /* @__PURE__ */ new Map(), N = (o = O.get(C)) != null ? o : new Ec();
  if (O.set(C, N), N0.set(r, O), x) {
    const { messageObservable: he } = _6(r, [C, E]);
    he.pipe(Xx(u)).subscribe(N);
  }
  const { chatObservable: M, send: I } = x6(r), U = c ?? M6, ae = mj(
    N.pipe(
      gr((he) => {
        const pe = U(he.payload), ye = M0(gc({}, pe), { from: he.from });
        if (!L6(ye))
          return ye;
      })
    ),
    M.pipe(
      gr(([he, pe]) => M0(gc({}, he), { from: pe }))
    )
  ).pipe(
    Sj((he, pe) => {
      var ye;
      if (!pe)
        return he;
      if ("id" in pe && he.find((se) => {
        var Ee, Ne;
        return ((Ee = se.from) == null ? void 0 : Ee.identity) === ((Ne = pe.from) == null ? void 0 : Ne.identity) && se.id === pe.id;
      })) {
        const se = he.findIndex((Ee) => Ee.id === pe.id);
        if (se > -1) {
          const Ee = he[se];
          he[se] = M0(gc({}, pe), {
            timestamp: Ee.timestamp,
            editTimestamp: (ye = pe.editTimestamp) != null ? ye : pe.timestamp
          });
        }
        return [...he];
      }
      return [...he, pe];
    }, []),
    Xx(u)
  ), Z = new yO(!1), B = m ?? O6, F = (he) => Za(this, null, function* () {
    Z.next(!0);
    try {
      const pe = yield I(he), ye = B(M0(gc({}, pe), {
        ignore: d()
      }));
      return yield dE(r.localParticipant, ye, {
        reliable: !0,
        topic: C
      }), pe;
    } finally {
      Z.next(!1);
    }
  }), K = (he, pe) => Za(this, null, function* () {
    const ye = Date.now(), se = typeof pe == "string" ? { id: pe, message: "", timestamp: ye } : pe;
    Z.next(!0);
    try {
      const Ee = yield r.localParticipant.editChatMessage(he, se), Ne = B(Ee);
      return yield dE(r.localParticipant, Ne, {
        topic: E,
        reliable: !0
      }), Ee;
    } finally {
      Z.next(!1);
    }
  });
  function te() {
    u.next(), u.complete(), N0.delete(r);
  }
  return r.once(ne.Disconnected, te), {
    messageObservable: ae,
    isSendingObservable: Z,
    send: F,
    update: K
  };
}
function L6(r) {
  return r.ignore == !0;
}
function A6() {
  const r = (t) => Za(this, null, function* () {
    Ht.info("Start Audio for room: ", t), yield t.startAudio();
  });
  return { className: Fa("start-audio-button"), roomAudioPlaybackAllowedObservable: c6, handleStartAudioPlayback: r };
}
function I6() {
  const r = (t) => Za(this, null, function* () {
    Ht.info("Start Video for room: ", t), yield t.startVideo();
  });
  return { className: Fa("start-audio-button"), roomVideoPlaybackAllowedObservable: d6, handleStartVideoPlayback: r };
}
function U6() {
  return { className: [Fa("button"), Fa("chat-toggle")].join(" ") };
}
function F6() {
  return { className: [Fa("button"), Fa("focus-toggle-button")].join(" ") };
}
function j6() {
  return { className: "lk-room-container" };
}
function iP(r, t, i = !0) {
  const o = [r.localParticipant, ...Array.from(r.remoteParticipants.values())], u = [];
  return o.forEach((d) => {
    t.forEach((c) => {
      const m = Array.from(
        d.trackPublications.values()
      ).filter(
        (g) => g.source === c && // either return all or only the ones that are subscribed
        (!i || g.track)
      ).map((g) => ({
        participant: d,
        publication: g,
        source: g.source
      }));
      u.push(...m);
    });
  }), { trackReferences: u, participants: o };
}
function z6(r, t, i) {
  var o, u;
  const d = (o = i.additionalRoomEvents) != null ? o : Fj, c = (u = i.onlySubscribed) != null ? u : !0, m = Array.from(
    (/* @__PURE__ */ new Set([
      ne.ParticipantConnected,
      ne.ParticipantDisconnected,
      ne.ConnectionStateChanged,
      ne.LocalTrackPublished,
      ne.LocalTrackUnpublished,
      ne.TrackPublished,
      ne.TrackUnpublished,
      ne.TrackSubscriptionStatusChanged,
      ...d
    ])).values()
  );
  return VE(r, ...m).pipe(
    gr((g) => {
      const b = iP(g, t, c);
      return Ht.debug(`TrackReference[] was updated. (length ${b.trackReferences.length})`, b), b;
    }),
    wo(iP(r, t, c))
  );
}
function V6(r, t = 1e3) {
  if (r === null)
    return Qx(!1);
  const i = oE(r, "mousemove", { passive: !0 }).pipe(gr(() => !0)), o = i.pipe(
    nj({
      each: t,
      with: () => sb(Qx(!1), o.pipe(Cj(i)))
    }),
    gj()
  );
  return o;
}
function B6(r, t) {
  if (typeof localStorage > "u") {
    Ht.error("Local storage is not available.");
    return;
  }
  try {
    if (t) {
      const i = Object.fromEntries(
        Object.entries(t).filter(([, o]) => o !== "")
      );
      localStorage.setItem(r, JSON.stringify(i));
    }
  } catch (i) {
    Ht.error(`Error setting item to local storage: ${i}`);
  }
}
function H6(r) {
  if (typeof localStorage > "u") {
    Ht.error("Local storage is not available.");
    return;
  }
  try {
    const t = localStorage.getItem(r);
    if (!t) {
      Ht.warn(`Item with key ${r} does not exist in local storage.`);
      return;
    }
    return JSON.parse(t);
  } catch (t) {
    Ht.error(`Error getting item from local storage: ${t}`);
    return;
  }
}
function $6(r) {
  return {
    load: () => H6(r),
    save: (t) => B6(r, t)
  };
}
var q6 = `${NO}-user-choices`, Ip = {
  videoEnabled: !0,
  audioEnabled: !0,
  videoDeviceId: "",
  audioDeviceId: "",
  username: ""
}, { load: W6, save: G6 } = $6(q6);
function Y6(r, t = !1) {
  t !== !0 && G6(r);
}
function K6(r, t = !1) {
  var i, o, u, d, c;
  const m = {
    videoEnabled: (i = r == null ? void 0 : r.videoEnabled) != null ? i : Ip.videoEnabled,
    audioEnabled: (o = r == null ? void 0 : r.audioEnabled) != null ? o : Ip.audioEnabled,
    videoDeviceId: (u = r == null ? void 0 : r.videoDeviceId) != null ? u : Ip.videoDeviceId,
    audioDeviceId: (d = r == null ? void 0 : r.audioDeviceId) != null ? d : Ip.audioDeviceId,
    username: (c = r == null ? void 0 : r.username) != null ? c : Ip.username
  };
  if (t)
    return m;
  {
    const g = W6();
    return gc(gc({}, m), g ?? {});
  }
}
function BO(r, t) {
  if (t.msg === "show_chat")
    return { ...r, showChat: !0, unreadMessages: 0 };
  if (t.msg === "hide_chat")
    return { ...r, showChat: !1 };
  if (t.msg === "toggle_chat") {
    const i = { ...r, showChat: !r.showChat };
    return i.showChat === !0 && (i.unreadMessages = 0), i;
  } else
    return t.msg === "unread_msg" ? { ...r, unreadMessages: t.count } : t.msg === "toggle_settings" ? { ...r, showSettings: !r.showSettings } : { ...r };
}
function HO(r, t) {
  return t.msg === "set_pin" ? [t.trackReference] : t.msg === "clear_pin" ? [] : { ...r };
}
const wb = R.createContext(void 0);
function $O() {
  const r = R.useContext(wb);
  if (!r)
    throw Error("Tried to access LayoutContext context outside a LayoutContextProvider provider.");
  return r;
}
function Q6(r) {
  const t = Lv();
  if (r ?? (r = t), !r)
    throw Error("Tried to access LayoutContext context outside a LayoutContextProvider provider.");
  return r;
}
function J6() {
  const [r, t] = R.useReducer(HO, IO), [i, o] = R.useReducer(BO, UO);
  return {
    pin: { dispatch: t, state: r },
    widget: { dispatch: o, state: i }
  };
}
function X6(r) {
  const [t, i] = R.useReducer(HO, IO), [o, u] = R.useReducer(BO, UO);
  return r ?? {
    pin: { dispatch: i, state: t },
    widget: { dispatch: u, state: o }
  };
}
function Lv() {
  return R.useContext(wb);
}
const $E = R.createContext(
  void 0
);
function Rb() {
  return R.useContext($E);
}
function nh(r) {
  const t = Rb(), i = r ?? t;
  if (!i)
    throw new Error(
      "No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly"
    );
  return i;
}
const qO = R.createContext(void 0);
function WO() {
  return R.useContext(qO);
}
function Av(r) {
  const t = WO(), i = Rb(), o = r ?? t ?? (i == null ? void 0 : i.participant);
  if (!o)
    throw new Error(
      "No participant provided, make sure you are inside a participant context or pass the participant explicitly"
    );
  return o;
}
const qE = R.createContext(void 0);
function Iv() {
  const r = R.useContext(qE);
  if (!r)
    throw Error("tried to access room context outside of livekit room component");
  return r;
}
function _b() {
  return R.useContext(qE);
}
function rh(r) {
  const t = _b(), i = r ?? t;
  if (!i)
    throw new Error(
      "No room provided, make sure you are inside a Room context or pass the room explicitly"
    );
  return i;
}
const GO = R.createContext(void 0);
function Z6(r) {
  const t = R.useContext(GO);
  if (r === !0) {
    if (t)
      return t;
    throw Error("tried to access feature context, but none is present");
  }
  return t;
}
function YO(r) {
  var t, i, o = "";
  if (typeof r == "string" || typeof r == "number")
    o += r;
  else if (typeof r == "object")
    if (Array.isArray(r)) {
      var u = r.length;
      for (t = 0; t < u; t++)
        r[t] && (i = YO(r[t])) && (o && (o += " "), o += i);
    } else
      for (i in r)
        r[i] && (o && (o += " "), o += i);
  return o;
}
function KO() {
  for (var r, t, i = 0, o = "", u = arguments.length; i < u; i++)
    (r = arguments[i]) && (t = YO(r)) && (o && (o += " "), o += t);
  return o;
}
function ez(...r) {
  return (...t) => {
    for (const i of r)
      if (typeof i == "function")
        try {
          i(...t);
        } catch (o) {
          console.error(o);
        }
  };
}
function al(...r) {
  const t = { ...r[0] };
  for (let i = 1; i < r.length; i++) {
    const o = r[i];
    for (const u in o) {
      const d = t[u], c = o[u];
      typeof d == "function" && typeof c == "function" && // This is a lot faster than a regex.
      u[0] === "o" && u[1] === "n" && u.charCodeAt(2) >= /* 'A' */
      65 && u.charCodeAt(2) <= /* 'Z' */
      90 ? t[u] = ez(d, c) : (u === "className" || u === "UNSAFE_className") && typeof d == "string" && typeof c == "string" ? t[u] = KO(d, c) : t[u] = c !== void 0 ? c : d;
    }
  }
  return t;
}
function tz(r) {
  return r !== void 0;
}
function Zl(...r) {
  return al(...r.filter(tz));
}
function QO(r, t, i) {
  return R.Children.map(r, (o) => R.isValidElement(o) && R.Children.only(r) ? (o.props.class && (t ?? (t = {}), t.class = KO(o.props.class, t.class), t.style = { ...o.props.style, ...t.style }), R.cloneElement(o, { ...t, key: i })) : o);
}
function nz(r) {
  var t, i;
  if (typeof window < "u" && typeof process < "u" && // eslint-disable-next-line turbo/no-undeclared-env-vars
  (((t = process == null ? void 0 : process.env) == null ? void 0 : t.NODE_ENV) === "dev" || // eslint-disable-next-line turbo/no-undeclared-env-vars
  ((i = process == null ? void 0 : process.env) == null ? void 0 : i.NODE_ENV) === "development")) {
    const o = document.querySelector(".lk-room-container");
    o && !getComputedStyle(o).getPropertyValue("--lk-has-imported-styles") && Ht.warn(
      "It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page."
    );
  }
}
function JO(r, t) {
  return r === "processor" && t && typeof t == "object" && "name" in t ? t.name : r === "e2ee" && t ? "e2ee-enabled" : t;
}
const rz = {
  connect: !0,
  audio: !1,
  video: !1
};
function iz(r) {
  const {
    token: t,
    serverUrl: i,
    options: o,
    room: u,
    connectOptions: d,
    connect: c,
    audio: m,
    video: g,
    screen: b,
    onConnected: C,
    onDisconnected: E,
    onError: x,
    onMediaDeviceFailure: O,
    onEncryptionError: N,
    simulateParticipants: M,
    ...I
  } = { ...rz, ...r };
  o && u && Ht.warn(
    "when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead."
  );
  const [U, ae] = R.useState(), Z = R.useRef(c);
  R.useEffect(() => {
    ae(u ?? new Ql(o));
  }, [u, JSON.stringify(o, JO)]);
  const B = R.useMemo(() => {
    const { className: F } = j6();
    return al(I, { className: F });
  }, [I]);
  return R.useEffect(() => {
    if (!U)
      return;
    const F = () => {
      const ye = U.localParticipant;
      Ht.debug("trying to publish local tracks"), Promise.all([
        ye.setMicrophoneEnabled(!!m, typeof m != "boolean" ? m : void 0),
        ye.setCameraEnabled(!!g, typeof g != "boolean" ? g : void 0),
        ye.setScreenShareEnabled(!!b, typeof b != "boolean" ? b : void 0)
      ]).catch((se) => {
        Ht.warn(se), x == null || x(se);
      });
    }, K = (ye) => {
      const se = Rv.getFailure(ye);
      O == null || O(se);
    }, te = (ye) => {
      N == null || N(ye);
    }, he = (ye) => {
      E == null || E(ye);
    }, pe = () => {
      C == null || C();
    };
    return U.on(ne.SignalConnected, F).on(ne.MediaDevicesError, K).on(ne.EncryptionError, te).on(ne.Disconnected, he).on(ne.Connected, pe), () => {
      U.off(ne.SignalConnected, F).off(ne.MediaDevicesError, K).off(ne.EncryptionError, te).off(ne.Disconnected, he).off(ne.Connected, pe);
    };
  }, [
    U,
    m,
    g,
    b,
    x,
    N,
    O,
    C,
    E
  ]), R.useEffect(() => {
    if (U) {
      if (M) {
        U.simulateParticipants({
          participants: {
            count: M
          },
          publish: {
            audio: !0,
            useRealTracks: !0
          }
        });
        return;
      }
      if (c) {
        if (Z.current = !0, Ht.debug("connecting"), !t) {
          Ht.debug("no token yet");
          return;
        }
        if (!i) {
          Ht.warn("no livekit url provided"), x == null || x(Error("no livekit url provided"));
          return;
        }
        U.connect(i, t, d).catch((F) => {
          Ht.warn(F), Z.current === !0 && (x == null || x(F));
        });
      } else
        Ht.debug("disconnecting because connect is false"), Z.current = !1, U.disconnect();
    }
  }, [
    c,
    t,
    JSON.stringify(d),
    U,
    x,
    i,
    M
  ]), R.useEffect(() => {
    if (U)
      return () => {
        Ht.info("disconnecting on onmount"), U.disconnect();
      };
  }, [U]), { room: U, htmlProps: B };
}
const az = /* @__PURE__ */ R.forwardRef(function(r, t) {
  const { room: i, htmlProps: o } = iz(r);
  return /* @__PURE__ */ R.createElement("div", { ref: t, ...o }, i && /* @__PURE__ */ R.createElement(qE.Provider, { value: i }, /* @__PURE__ */ R.createElement(GO.Provider, { value: r.featureFlags }, r.children)));
}), oz = (r) => {
  const t = R.useRef(r);
  return R.useEffect(() => {
    t.current = r;
  }), t;
};
function sz(r, t) {
  const i = uz(), o = oz(t);
  return R.useLayoutEffect(() => {
    let u = !1;
    const d = r.current;
    if (!d)
      return;
    function c(m, g) {
      u || o.current(m, g);
    }
    return i == null || i.subscribe(d, c), () => {
      u = !0, i == null || i.unsubscribe(d, c);
    };
  }, [r.current, i, o]), i == null ? void 0 : i.observer;
}
function lz() {
  let r = !1, t = [];
  const i = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const o = new ResizeObserver((u, d) => {
    t = t.concat(u), r || window.requestAnimationFrame(() => {
      const c = /* @__PURE__ */ new Set();
      for (let m = 0; m < t.length; m++) {
        if (c.has(t[m].target))
          continue;
        c.add(t[m].target);
        const g = i.get(t[m].target);
        g == null || g.forEach((b) => b(t[m], d));
      }
      t = [], r = !1;
    }), r = !0;
  });
  return {
    observer: o,
    subscribe(u, d) {
      o.observe(u);
      const c = i.get(u) ?? [];
      c.push(d), i.set(u, c);
    },
    unsubscribe(u, d) {
      const c = i.get(u) ?? [];
      if (c.length === 1) {
        o.unobserve(u), i.delete(u);
        return;
      }
      const m = c.indexOf(d);
      m !== -1 && c.splice(m, 1), i.set(u, c);
    }
  };
}
let aP;
const uz = () => aP || (aP = lz()), XO = (r) => {
  const [t, i] = R.useState({ width: 0, height: 0 });
  R.useLayoutEffect(() => {
    if (r.current) {
      const { width: u, height: d } = r.current.getBoundingClientRect();
      i({ width: u, height: d });
    }
  }, [r.current]);
  const o = R.useCallback(
    (u) => i(u.contentRect),
    []
  );
  return sz(r, o), t;
};
function sa(r, t, i = !0) {
  const [o, u] = R.useState(t);
  return R.useEffect(() => {
    if (i && u(t), typeof window > "u" || !r)
      return;
    const d = r.subscribe(u);
    return () => d.unsubscribe();
  }, [r, i]), o;
}
function cz(r) {
  const t = (d) => typeof window < "u" ? window.matchMedia(d).matches : !1, [i, o] = R.useState(t(r));
  function u() {
    o(t(r));
  }
  return R.useEffect(() => {
    const d = window.matchMedia(r);
    return u(), d.addListener ? d.addListener(u) : d.addEventListener("change", u), () => {
      d.removeListener ? d.removeListener(u) : d.removeEventListener("change", u);
    };
  }, [r]), i;
}
function dz(r = {}) {
  const t = Av(r.participant), { className: i, connectionQualityObserver: o } = R.useMemo(
    () => T6(t),
    [t]
  ), u = sa(o, ko.Unknown);
  return { className: i, quality: u };
}
function xb(r) {
  const t = rh(r), i = R.useMemo(() => o6(t), [t]);
  return sa(i, t.state);
}
function fz(r) {
  const t = Iv(), i = xb(t);
  return { buttonProps: R.useMemo(() => {
    const { className: o, disconnect: u } = k6(t);
    return al(r, {
      className: o,
      onClick: () => u(r.stopTracks ?? !0),
      disabled: i === Yt.Disconnected
    });
  }, [t, r, i]) };
}
function pz(r) {
  if (r.publication instanceof _v) {
    const t = r.publication.track;
    if (t) {
      const { facingMode: i } = ZD(t);
      return i;
    }
  }
  return "undefined";
}
function hz({ trackRef: r, props: t }) {
  const i = nh(r), o = Lv(), { className: u } = R.useMemo(() => F6(), []), d = R.useMemo(() => LO(i, o == null ? void 0 : o.pin.state), [i, o == null ? void 0 : o.pin.state]);
  return { mergedProps: R.useMemo(
    () => al(t, {
      className: u,
      onClick: (c) => {
        var m, g, b, C, E;
        (m = t.onClick) == null || m.call(t, c), d ? (b = o == null ? void 0 : (g = o.pin).dispatch) == null || b.call(g, {
          msg: "clear_pin"
        }) : (E = o == null ? void 0 : (C = o.pin).dispatch) == null || E.call(C, {
          msg: "set_pin",
          trackReference: i
        });
      }
    }),
    [t, u, i, d, o == null ? void 0 : o.pin]
  ), inFocus: d };
}
function mz(r, t, i = {}) {
  const o = i.gridLayouts ?? zj, { width: u, height: d } = XO(r), c = AO(o, t, u, d);
  return R.useEffect(() => {
    r.current && c && (r.current.style.setProperty("--lk-col-count", c == null ? void 0 : c.columns.toString()), r.current.style.setProperty("--lk-row-count", c == null ? void 0 : c.rows.toString()));
  }, [r, c]), {
    layout: c,
    containerWidth: u,
    containerHeight: d
  };
}
function oP(r, t = {}) {
  var i, o;
  const u = typeof r == "string" ? t.participant : r.participant, d = Av(u), c = typeof r == "string" ? { participant: d, source: r } : r, [m, g] = R.useState(
    !!((i = c.publication) != null && i.isMuted || (o = d.getTrackPublication(c.source)) != null && o.isMuted)
  );
  return R.useEffect(() => {
    const b = VO(c).subscribe(g);
    return () => b.unsubscribe();
  }, [$i(c)]), m;
}
function vz(r) {
  const t = Av(r), i = R.useMemo(() => g6(t), [t]);
  return sa(i, t.isSpeaking);
}
function gz() {
  const r = Iv(), t = R.useMemo(
    () => y6(r.localParticipant),
    [r]
  );
  return sa(t, r.localParticipant.permissions);
}
function yz({
  kind: r,
  room: t,
  track: i,
  requestPermissions: o,
  onError: u
}) {
  const d = _b(), c = R.useMemo(
    () => s6(r, u, o),
    [r, o, u]
  ), m = sa(c, []), [g, b] = R.useState(
    (d == null ? void 0 : d.getActiveDevice(r)) ?? ""
  ), { className: C, activeDeviceObservable: E, setActiveMediaDevice: x } = R.useMemo(
    () => C6(r, t ?? d, i),
    [r, t, d, i]
  );
  return R.useEffect(() => {
    const O = E.subscribe((N) => {
      N && N !== g && (Ht.info("setCurrentDeviceId", N), b(N));
    });
    return () => {
      O == null || O.unsubscribe();
    };
  }, [E]), { devices: m, className: C, activeDeviceId: g, setActiveMediaDevice: x };
}
function ZO(r, t, i = {}) {
  const o = R.useRef([]), u = R.useRef(-1), d = t !== u.current, c = typeof i.customSortFunction == "function" ? i.customSortFunction(r) : Yj(r);
  let m = [...c];
  if (d === !1)
    try {
      m = r6(o.current, c, t);
    } catch (g) {
      Ht.error("Error while running updatePages(): ", g);
    }
  return d ? o.current = c : o.current = m, u.current = t, m;
}
function bz(r, t) {
  const [i, o] = R.useState(1), u = Math.max(Math.ceil(t.length / r), 1);
  i > u && o(u);
  const d = i * r, c = d - r, m = (C) => {
    o((E) => C === "next" ? E === u ? E : E + 1 : E === 1 ? E : E - 1);
  }, g = (C) => {
    C > u ? o(u) : C < 1 ? o(1) : o(C);
  }, b = ZO(t, r).slice(c, d);
  return {
    totalPageCount: u,
    nextPage: () => m("next"),
    prevPage: () => m("previous"),
    setPage: g,
    firstItemIndex: c,
    lastItemIndex: d,
    tracks: b,
    currentPage: i
  };
}
function Sz({
  trackRef: r,
  onParticipantClick: t,
  disableSpeakingIndicator: i,
  htmlProps: o
}) {
  const u = nh(r), d = R.useMemo(() => {
    const { className: x } = R6();
    return al(o, {
      className: x,
      onClick: (O) => {
        var N;
        if ((N = o.onClick) == null || N.call(o, O), typeof t == "function") {
          const M = u.publication ?? u.participant.getTrackPublication(u.source);
          t({ participant: u.participant, track: M });
        }
      }
    });
  }, [
    o,
    t,
    u.publication,
    u.source,
    u.participant
  ]), c = u.participant.getTrackPublication(ue.Source.Microphone), m = R.useMemo(() => ({
    participant: u.participant,
    source: ue.Source.Microphone,
    publication: c
  }), [c, u.participant]), g = oP(u), b = oP(m), C = vz(u.participant), E = pz(u);
  return {
    elementProps: {
      "data-lk-audio-muted": b,
      "data-lk-video-muted": g,
      "data-lk-speaking": i === !0 ? !1 : C,
      "data-lk-local-participant": u.participant.isLocal,
      "data-lk-source": u.source,
      "data-lk-facing-mode": E,
      ...d
    }
  };
}
function Cz(r) {
  return r = Q6(r), R.useMemo(() => (r == null ? void 0 : r.pin.state) !== void 0 && r.pin.state.length >= 1 ? r.pin.state : [], [r.pin.state]);
}
function kz({ room: r, props: t }) {
  const i = rh(r), { className: o, roomAudioPlaybackAllowedObservable: u, handleStartAudioPlayback: d } = R.useMemo(
    () => A6(),
    []
  ), c = R.useMemo(
    () => u(i),
    [i, u]
  ), { canPlayAudio: m } = sa(c, {
    canPlayAudio: i.canPlaybackAudio
  });
  return { mergedProps: R.useMemo(
    () => al(t, {
      className: o,
      onClick: () => {
        d(i);
      },
      style: { display: m ? "none" : "block" }
    }),
    [t, o, m, d, i]
  ), canPlayAudio: m };
}
function Tz({ room: r, props: t }) {
  const i = rh(r), { className: o, roomVideoPlaybackAllowedObservable: u, handleStartVideoPlayback: d } = R.useMemo(
    () => I6(),
    []
  ), c = R.useMemo(
    () => u(i),
    [i, u]
  ), { canPlayVideo: m } = sa(c, {
    canPlayVideo: i.canPlaybackVideo
  });
  return { mergedProps: R.useMemo(
    () => al(t, {
      className: o,
      onClick: () => {
        d(i);
      },
      style: { display: m ? "none" : "block" }
    }),
    [t, o, m, d, i]
  ), canPlayVideo: m };
}
function Ez(r, t = {}) {
  const i = R.useRef(null), o = R.useRef(null), u = t.minSwipeDistance ?? 50, d = (g) => {
    o.current = null, i.current = g.targetTouches[0].clientX;
  }, c = (g) => {
    o.current = g.targetTouches[0].clientX;
  }, m = R.useCallback(() => {
    if (!i.current || !o.current)
      return;
    const g = i.current - o.current, b = g > u, C = g < -u;
    b && t.onLeftSwipe && t.onLeftSwipe(), C && t.onRightSwipe && t.onRightSwipe();
  }, [u, t]);
  R.useEffect(() => {
    const g = r.current;
    return g && (g.addEventListener("touchstart", d, { passive: !0 }), g.addEventListener("touchmove", c, { passive: !0 }), g.addEventListener("touchend", m, { passive: !0 })), () => {
      g && (g.removeEventListener("touchstart", d), g.removeEventListener("touchmove", c), g.removeEventListener("touchend", m));
    };
  }, [r, m]);
}
function wz({ props: r }) {
  const { dispatch: t, state: i } = $O().widget, { className: o } = R.useMemo(() => U6(), []);
  return { mergedProps: R.useMemo(() => al(r, {
    className: o,
    onClick: () => {
      t && t({ msg: "toggle_chat" });
    },
    "aria-pressed": i != null && i.showChat ? "true" : "false",
    "data-lk-unread-msgs": i ? i.unreadMessages < 10 ? i.unreadMessages.toFixed(0) : "9+" : "0"
  }), [r, o, t, i]) };
}
function Rz(r) {
  var t, i;
  const o = nh(r), { className: u, mediaMutedObserver: d } = R.useMemo(
    () => E6(o),
    [$i(o)]
  );
  return { isMuted: sa(
    d,
    !!((t = o.publication) != null && t.isMuted || (i = o.participant.getTrackPublication(o.source)) != null && i.isMuted)
  ), className: u };
}
function _z({
  source: r,
  onChange: t,
  initialState: i,
  captureOptions: o,
  publishOptions: u,
  onDeviceError: d,
  ...c
}) {
  var m;
  const g = _b(), b = (m = g == null ? void 0 : g.localParticipant) == null ? void 0 : m.getTrackPublication(r), C = R.useRef(!1), { toggle: E, className: x, pendingObserver: O, enabledObserver: N } = R.useMemo(
    () => g ? b6(r, g, o, u, d) : S6(),
    [g, r, JSON.stringify(o), u]
  ), M = sa(O, !1), I = sa(N, i ?? !!(b != null && b.isEnabled));
  R.useEffect(() => {
    t == null || t(I, C.current), C.current = !1;
  }, [I, t]), R.useEffect(() => {
    i !== void 0 && (Ht.debug("forcing initial toggle state", r, i), E(i));
  }, []);
  const U = R.useMemo(() => al(c, { className: x }), [c, x]), ae = R.useCallback(
    (Z) => {
      var B;
      C.current = !0, E().catch(() => C.current = !1), (B = c.onClick) == null || B.call(c, Z);
    },
    [c, E]
  );
  return {
    toggle: E,
    enabled: I,
    pending: M,
    track: b,
    buttonProps: {
      ...U,
      "aria-pressed": I,
      "data-lk-source": r,
      "data-lk-enabled": I,
      disabled: M,
      onClick: ae
    }
  };
}
function eM(r = [
  ue.Source.Camera,
  ue.Source.Microphone,
  ue.Source.ScreenShare,
  ue.Source.ScreenShareAudio,
  ue.Source.Unknown
], t = {}) {
  const i = rh(t.room), [o, u] = R.useState([]), [d, c] = R.useState([]), m = R.useMemo(() => r.map((g) => FO(g) ? g.source : g), [JSON.stringify(r)]);
  return R.useEffect(() => {
    const g = z6(i, m, {
      additionalRoomEvents: t.updateOnlyOn,
      onlySubscribed: t.onlySubscribed
    }).subscribe(({ trackReferences: b, participants: C }) => {
      Ht.debug("setting track bundles", b, C), u(b), c(C);
    });
    return () => g.unsubscribe();
  }, [
    i,
    JSON.stringify(t.onlySubscribed),
    JSON.stringify(t.updateOnlyOn),
    JSON.stringify(r)
  ]), R.useMemo(() => {
    if (jO(r)) {
      const g = Pz(r, d), b = Array.from(o);
      return d.forEach((C) => {
        g.has(C.identity) && (g.get(C.identity) ?? []).forEach((E) => {
          if (o.find(
            ({ participant: O, publication: N }) => C.identity === O.identity && N.source === E
          ))
            return;
          Ht.debug(
            `Add ${E} placeholder for participant ${C.identity}.`
          );
          const x = {
            participant: C,
            source: E
          };
          b.push(x);
        });
      }), b;
    } else
      return o;
  }, [o, d, r]);
}
function xz(r, t) {
  const i = new Set(r);
  for (const o of t)
    i.delete(o);
  return i;
}
function Pz(r, t) {
  const i = /* @__PURE__ */ new Map();
  if (jO(r)) {
    const o = r.filter((u) => u.withPlaceholder).map((u) => u.source);
    t.forEach((u) => {
      const d = u.getTrackPublications().map((m) => {
        var g;
        return (g = m.track) == null ? void 0 : g.source;
      }).filter((m) => m !== void 0), c = Array.from(
        xz(new Set(o), new Set(d))
      );
      c.length > 0 && i.set(u.identity, c);
    });
  }
  return i;
}
function Dz(r) {
  const t = Iv(), i = xb(t), o = R.useMemo(
    () => i === Yt.Disconnected,
    [i]
  ), u = R.useMemo(
    () => N6(t, r),
    [t, r, o]
  ), d = sa(u.isSendingObservable, !1), c = sa(u.messageObservable, []);
  return { send: u.send, update: u.update, chatMessages: c, isSending: d };
}
function tM(r = {}) {
  const [t, i] = R.useState(
    K6(r.defaults, r.preventLoad ?? !1)
  ), o = R.useCallback((g) => {
    i((b) => ({ ...b, audioEnabled: g }));
  }, []), u = R.useCallback((g) => {
    i((b) => ({ ...b, videoEnabled: g }));
  }, []), d = R.useCallback((g) => {
    i((b) => ({ ...b, audioDeviceId: g }));
  }, []), c = R.useCallback((g) => {
    i((b) => ({ ...b, videoDeviceId: g }));
  }, []), m = R.useCallback((g) => {
    i((b) => ({ ...b, username: g }));
  }, []);
  return R.useEffect(() => {
    Y6(t, r.preventSave ?? !1);
  }, [t, r.preventSave]), {
    userChoices: t,
    saveAudioInputEnabled: o,
    saveVideoInputEnabled: u,
    saveAudioInputDeviceId: d,
    saveVideoInputDeviceId: c,
    saveUsername: m
  };
}
function Oz(r, t = {}) {
  const i = Av(r), o = rh(t.room), u = R.useMemo(() => p6(o, i), [o, i]);
  return sa(
    u,
    i.isLocal ? i.isE2EEEnabled : !!(i != null && i.isEncrypted)
  );
}
function Mz(r) {
  const t = rh(r), i = xb(t), o = R.useMemo(() => h6(t), [t, i]);
  return sa(o, t.isRecording);
}
const nM = /* @__PURE__ */ R.forwardRef(
  function(r, t) {
    const { mergedProps: i } = wz({ props: r });
    return /* @__PURE__ */ R.createElement("button", { ref: t, ...i }, r.children);
  }
), Nz = /* @__PURE__ */ R.forwardRef(
  function(r, t) {
    const { buttonProps: i } = fz(r);
    return /* @__PURE__ */ R.createElement("button", { ref: t, ...i }, r.children);
  }
), Lz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708L11 10.293V4.5A1.5 1.5 0 0 0 9.5 3H3.707zM0 4.5a1.5 1.5 0 0 1 .943-1.393l9.532 9.533c-.262.224-.603.36-.975.36h-8A1.5 1.5 0 0 1 0 11.5z" }), /* @__PURE__ */ R.createElement("path", { d: "m15.2 3.6-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z" })), Az = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M0 4.5A1.5 1.5 0 0 1 1.5 3h8A1.5 1.5 0 0 1 11 4.5v7A1.5 1.5 0 0 1 9.5 13h-8A1.5 1.5 0 0 1 0 11.5zM15.2 3.6l-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z" })), Iz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 24 24", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "#FFF",
    d: "M4.99 3.99a1 1 0 0 0-.697 1.717L10.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414L12 13.414l6.293 6.293a1 1 0 1 0 1.414-1.414L13.414 12l6.293-6.293a1 1 0 0 0-.727-1.717 1 1 0 0 0-.687.303L12 10.586 5.707 4.293a1 1 0 0 0-.717-.303z"
  }
)), Uz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 18, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M0 2.75A2.75 2.75 0 0 1 2.75 0h10.5A2.75 2.75 0 0 1 16 2.75v13.594a.75.75 0 0 1-1.234.572l-3.691-3.12a1.25 1.25 0 0 0-.807-.296H2.75A2.75 2.75 0 0 1 0 10.75v-8ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v8c0 .69.56 1.25 1.25 1.25h7.518c.65 0 1.279.23 1.775.65l2.457 2.077V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z",
    clipRule: "evenodd"
  }
)), sP = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M5.293 2.293a1 1 0 0 1 1.414 0l4.823 4.823a1.25 1.25 0 0 1 0 1.768l-4.823 4.823a1 1 0 0 1-1.414-1.414L9.586 8 5.293 3.707a1 1 0 0 1 0-1.414z",
    clipRule: "evenodd"
  }
)), rM = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5 }, /* @__PURE__ */ R.createElement("path", { d: "M10 1.75h4.25m0 0V6m0-4.25L9 7M6 14.25H1.75m0 0V10m0 4.25L7 9" }))), Fz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M8.961.894C8.875-.298 7.125-.298 7.04.894c-.066.912-1.246 1.228-1.76.472-.67-.99-2.186-.115-1.664.96.399.824-.465 1.688-1.288 1.289-1.076-.522-1.95.994-.961 1.665.756.513.44 1.693-.472 1.759-1.192.086-1.192 1.836 0 1.922.912.066 1.228 1.246.472 1.76-.99.67-.115 2.186.96 1.664.824-.399 1.688.465 1.289 1.288-.522 1.076.994 1.95 1.665.961.513-.756 1.693-.44 1.759.472.086 1.192 1.836 1.192 1.922 0 .066-.912 1.246-1.228 1.76-.472.67.99 2.186.115 1.664-.96-.399-.824.465-1.688 1.288-1.289 1.076.522 1.95-.994.961-1.665-.756-.513-.44-1.693.472-1.759 1.192-.086 1.192-1.836 0-1.922-.912-.066-1.228-1.246-.472-1.76.99-.67.115-2.186-.96-1.664-.824.399-1.688-.465-1.289-1.288.522-1.076-.994-1.95-1.665-.961-.513.756-1.693.44-1.759-.472ZM8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10Z",
    clipRule: "evenodd"
  }
)), iM = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M2 2.75A2.75 2.75 0 0 1 4.75 0h6.5A2.75 2.75 0 0 1 14 2.75v10.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-.5a.75.75 0 0 1 1.5 0v.5c0 .69.56 1.25 1.25 1.25h6.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25h-6.5c-.69 0-1.25.56-1.25 1.25v.5a.75.75 0 0 1-1.5 0v-.5Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8.78 7.47a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 1 1-1.06-1.06l.97-.97H1.75a.75.75 0 0 1 0-1.5h4.69l-.97-.97a.75.75 0 0 1 1.06-1.06l2.25 2.25Z",
    clipRule: "evenodd"
  }
)), jz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M4 6.104V4a4 4 0 1 1 8 0v2.104c1.154.326 2 1.387 2 2.646v4.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-4.5c0-1.259.846-2.32 2-2.646ZM5.5 4a2.5 2.5 0 0 1 5 0v2h-5V4Z",
    clipRule: "evenodd"
  }
)), zz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M12.227 11.52a5.477 5.477 0 0 0 1.246-2.97.5.5 0 0 0-.995-.1 4.478 4.478 0 0 1-.962 2.359l-1.07-1.07C10.794 9.247 11 8.647 11 8V3a3 3 0 0 0-6 0v1.293L1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708zM8 12.5c.683 0 1.33-.152 1.911-.425l.743.743c-.649.359-1.378.59-2.154.66V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .995-.098A4.5 4.5 0 0 0 8 12.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M8.743 10.907 5 7.164V8a3 3 0 0 0 3.743 2.907z" })), Vz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fillRule: "evenodd",
    d: "M2.975 8.002a.5.5 0 0 1 .547.449 4.5 4.5 0 0 0 8.956 0 .5.5 0 1 1 .995.098A5.502 5.502 0 0 1 8.5 13.478V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .448-.547z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement("path", { d: "M5 3a3 3 0 1 1 6 0v5a3 3 0 0 1-6 0z" })), Bz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" })), Hz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ R.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }))), $z = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor", ...r }, /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ R.createElement("path", { d: "M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ R.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }))), qz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor", ...r }, /* @__PURE__ */ R.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z" }), /* @__PURE__ */ R.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z" }))), aM = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M0 2.75A2.75 2.75 0 0 1 2.75 0h14.5A2.75 2.75 0 0 1 20 2.75v10.5A2.75 2.75 0 0 1 17.25 16H2.75A2.75 2.75 0 0 1 0 13.25V2.75ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h14.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M9.47 4.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1-1.06 1.06l-.97-.97v4.69a.75.75 0 0 1-1.5 0V6.56l-.97.97a.75.75 0 0 1-1.06-1.06l2.25-2.25Z",
    clipRule: "evenodd"
  }
)), Wz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement("g", { fill: "currentColor" }, /* @__PURE__ */ R.createElement("path", { d: "M7.28 4.22a.75.75 0 0 0-1.06 1.06L8.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L10 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L11.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L10 6.94z" }), /* @__PURE__ */ R.createElement(
  "path",
  {
    fillRule: "evenodd",
    d: "M2.75 0A2.75 2.75 0 0 0 0 2.75v10.5A2.75 2.75 0 0 0 2.75 16h14.5A2.75 2.75 0 0 0 20 13.25V2.75A2.75 2.75 0 0 0 17.25 0zM1.5 2.75c0-.69.56-1.25 1.25-1.25h14.5c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H2.75c-.69 0-1.25-.56-1.25-1.25z",
    clipRule: "evenodd"
  }
))), lP = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8 0Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8 12a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 8 12Z",
    clipRule: "evenodd",
    opacity: 0.7
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M12 1.072a.75.75 0 0 1 .274 1.024l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 12 1.072Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M6 11.464a.75.75 0 0 1 .274 1.025l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 6 11.464Z",
    clipRule: "evenodd",
    opacity: 0.6
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M14.928 4a.75.75 0 0 1-.274 1.025l-2.165 1.25a.75.75 0 1 1-.75-1.3l2.165-1.25A.75.75 0 0 1 14.928 4Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4.536 10a.75.75 0 0 1-.275 1.024l-2.165 1.25a.75.75 0 0 1-.75-1.298l2.165-1.25A.75.75 0 0 1 4.536 10Z",
    clipRule: "evenodd",
    opacity: 0.5
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M16 8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 16 8Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4 8a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 8Z",
    clipRule: "evenodd",
    opacity: 0.4
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M14.928 12a.75.75 0 0 1-1.024.274l-2.165-1.25a.75.75 0 0 1 .75-1.299l2.165 1.25A.75.75 0 0 1 14.928 12Z",
    clipRule: "evenodd",
    opacity: 0.9
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4.536 6a.75.75 0 0 1-1.025.275l-2.165-1.25a.75.75 0 1 1 .75-1.3l2.165 1.25A.75.75 0 0 1 4.536 6Z",
    clipRule: "evenodd",
    opacity: 0.3
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M12 14.928a.75.75 0 0 1-1.024-.274l-1.25-2.165a.75.75 0 0 1 1.298-.75l1.25 2.165A.75.75 0 0 1 12 14.928Z",
    clipRule: "evenodd",
    opacity: 0.8
  }
), /* @__PURE__ */ R.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M6 4.536a.75.75 0 0 1-1.024-.275l-1.25-2.165a.75.75 0 1 1 1.299-.75l1.25 2.165A.75.75 0 0 1 6 4.536Z",
    clipRule: "evenodd",
    opacity: 0.2
  }
)), Gz = (r) => /* @__PURE__ */ R.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", ...r }, /* @__PURE__ */ R.createElement("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5 }, /* @__PURE__ */ R.createElement("path", { d: "M13.25 7H9m0 0V2.75M9 7l5.25-5.25M2.75 9H7m0 0v4.25M7 9l-5.25 5.25" }))), Yz = /* @__PURE__ */ R.forwardRef(
  function({ trackRef: r, ...t }, i) {
    const o = Rb(), { mergedProps: u, inFocus: d } = hz({
      trackRef: r ?? o,
      props: t
    });
    return /* @__PURE__ */ R.createElement(wb.Consumer, null, (c) => c !== void 0 && /* @__PURE__ */ R.createElement("button", { ref: i, ...u }, t.children ? t.children : d ? /* @__PURE__ */ R.createElement(Gz, null) : /* @__PURE__ */ R.createElement(rM, null)));
  }
), ST = /* @__PURE__ */ R.forwardRef(
  function({
    kind: r,
    initialSelection: t,
    onActiveDeviceChange: i,
    onDeviceListChange: o,
    onDeviceSelectError: u,
    exactMatch: d,
    track: c,
    requestPermissions: m,
    onError: g,
    ...b
  }, C) {
    const E = _b(), x = R.useCallback(
      (B) => {
        E && E.emit(ne.MediaDevicesError, B), g == null || g(B);
      },
      [E, g]
    ), { devices: O, activeDeviceId: N, setActiveMediaDevice: M, className: I } = yz({
      kind: r,
      room: E,
      track: c,
      requestPermissions: m,
      onError: x
    });
    R.useEffect(() => {
      t !== void 0 && M(t);
    }, [M]), R.useEffect(() => {
      typeof o == "function" && o(O);
    }, [o, O]), R.useEffect(() => {
      N && N !== "" && (i == null || i(N));
    }, [N]);
    const U = async (B) => {
      try {
        await M(B, { exact: d });
      } catch (F) {
        if (F instanceof Error)
          u == null || u(F);
        else
          throw F;
      }
    }, ae = R.useMemo(
      () => Zl(b, { className: I }, { className: "lk-list" }),
      [I, b]
    );
    function Z(B, F, K) {
      return B === F || K === 0 && F === "default";
    }
    return /* @__PURE__ */ R.createElement("ul", { ref: C, ...ae }, O.map((B, F) => /* @__PURE__ */ R.createElement(
      "li",
      {
        key: B.deviceId,
        id: B.deviceId,
        "data-lk-active": Z(B.deviceId, N, F),
        "aria-selected": Z(B.deviceId, N, F),
        role: "option"
      },
      /* @__PURE__ */ R.createElement("button", { className: "lk-button", onClick: () => U(B.deviceId) }, B.label)
    )));
  }
), Kz = /* @__PURE__ */ R.forwardRef(
  function({ label: r, ...t }, i) {
    const o = Iv(), { mergedProps: u, canPlayAudio: d } = kz({ room: o, props: t }), { mergedProps: c, canPlayVideo: m } = Tz({ room: o, props: u }), { style: g, ...b } = c;
    return g.display = d && m ? "none" : "block", /* @__PURE__ */ R.createElement("button", { ref: i, style: g, ...b }, r ?? `Start ${d ? "Video" : "Audio"}`);
  }
);
function oM(r, t) {
  switch (r) {
    case ue.Source.Microphone:
      return t ? /* @__PURE__ */ R.createElement(Vz, null) : /* @__PURE__ */ R.createElement(zz, null);
    case ue.Source.Camera:
      return t ? /* @__PURE__ */ R.createElement(Az, null) : /* @__PURE__ */ R.createElement(Lz, null);
    case ue.Source.ScreenShare:
      return t ? /* @__PURE__ */ R.createElement(Wz, null) : /* @__PURE__ */ R.createElement(aM, null);
    default:
      return;
  }
}
function Qz(r) {
  switch (r) {
    case ko.Excellent:
      return /* @__PURE__ */ R.createElement(Bz, null);
    case ko.Good:
      return /* @__PURE__ */ R.createElement(Hz, null);
    case ko.Poor:
      return /* @__PURE__ */ R.createElement($z, null);
    default:
      return /* @__PURE__ */ R.createElement(qz, null);
  }
}
const Ad = /* @__PURE__ */ R.forwardRef(function({ showIcon: r, ...t }, i) {
  const { buttonProps: o, enabled: u } = _z(t);
  return /* @__PURE__ */ R.createElement("button", { ref: i, ...o }, (r ?? !0) && oM(t.source, u), t.children);
}), Jz = /* @__PURE__ */ R.forwardRef(function(r, t) {
  const { className: i, quality: o } = dz(r), u = R.useMemo(() => ({ ...Zl(r, { className: i }), "data-lk-quality": o }), [o, r, i]);
  return /* @__PURE__ */ R.createElement("div", { ref: t, ...u }, r.children ?? Qz(o));
}), uP = /* @__PURE__ */ R.forwardRef(
  function({ participant: r, ...t }, i) {
    const o = Av(r), { className: u, infoObserver: d } = R.useMemo(() => w6(o), [o]), { identity: c, name: m } = sa(d, {
      name: o.name,
      identity: o.identity,
      metadata: o.metadata
    }), g = R.useMemo(() => Zl(t, { className: u, "data-lk-participant-name": m }), [t, u, m]);
    return /* @__PURE__ */ R.createElement("span", { ref: i, ...g }, m !== "" ? m : c, t.children);
  }
), Xz = /* @__PURE__ */ R.forwardRef(
  function({ trackRef: r, show: t = "always", ...i }, o) {
    const { className: u, isMuted: d } = Rz(r), c = t === "always" || t === "muted" && d || t === "unmuted" && !d, m = R.useMemo(
      () => Zl(i, {
        className: u
      }),
      [u, i]
    );
    return c ? /* @__PURE__ */ R.createElement("div", { ref: o, ...m, "data-lk-muted": d }, i.children ?? oM(r.source, !d)) : null;
  }
), sM = (r) => /* @__PURE__ */ R.createElement(
  "svg",
  {
    width: 320,
    height: 320,
    viewBox: "0 0 320 320",
    preserveAspectRatio: "xMidYMid meet",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...r
  },
  /* @__PURE__ */ R.createElement(
    "path",
    {
      d: "M160 180C204.182 180 240 144.183 240 100C240 55.8172 204.182 20 160 20C115.817 20 79.9997 55.8172 79.9997 100C79.9997 144.183 115.817 180 160 180Z",
      fill: "white",
      fillOpacity: 0.25
    }
  ),
  /* @__PURE__ */ R.createElement(
    "path",
    {
      d: "M97.6542 194.614C103.267 191.818 109.841 192.481 115.519 195.141C129.025 201.466 144.1 205 159.999 205C175.899 205 190.973 201.466 204.48 195.141C210.158 192.481 216.732 191.818 222.345 194.614C262.703 214.719 291.985 253.736 298.591 300.062C300.15 310.997 291.045 320 280 320H39.9997C28.954 320 19.8495 310.997 21.4087 300.062C28.014 253.736 57.2966 214.72 97.6542 194.614Z",
      fill: "white",
      fillOpacity: 0.25
    }
  )
);
function lM(r, t = {}) {
  const [i, o] = R.useState(cE(r)), [u, d] = R.useState(i == null ? void 0 : i.isMuted), [c, m] = R.useState(i == null ? void 0 : i.isSubscribed), [g, b] = R.useState(i == null ? void 0 : i.track), [C, E] = R.useState("landscape"), x = R.useRef(), { className: O, trackObserver: N } = R.useMemo(() => a6(r), [
    r.participant.sid ?? r.participant.identity,
    r.source,
    Ua(r) && r.publication.trackSid
  ]);
  return R.useEffect(() => {
    const M = N.subscribe((I) => {
      Ht.debug("update track", I), o(I), d(I == null ? void 0 : I.isMuted), m(I == null ? void 0 : I.isSubscribed), b(I == null ? void 0 : I.track);
    });
    return () => M == null ? void 0 : M.unsubscribe();
  }, [N]), R.useEffect(() => {
    var M, I;
    return g && (x.current && g.detach(x.current), (M = t.element) != null && M.current && !(r.participant.isLocal && (g == null ? void 0 : g.kind) === "audio") && g.attach(t.element.current)), x.current = (I = t.element) == null ? void 0 : I.current, () => {
      x.current && (g == null || g.detach(x.current));
    };
  }, [g, t.element]), R.useEffect(() => {
    var M, I;
    if (typeof ((M = i == null ? void 0 : i.dimensions) == null ? void 0 : M.width) == "number" && typeof ((I = i == null ? void 0 : i.dimensions) == null ? void 0 : I.height) == "number") {
      const U = i.dimensions.width > i.dimensions.height ? "landscape" : "portrait";
      E(U);
    }
  }, [i]), {
    publication: i,
    isMuted: u,
    isSubscribed: c,
    track: g,
    elementProps: Zl(t.props, {
      className: O,
      "data-lk-local-participant": r.participant.isLocal,
      "data-lk-source": i == null ? void 0 : i.source,
      ...(i == null ? void 0 : i.kind) === "video" && { "data-lk-orientation": C }
    })
  };
}
var Zz = "Expected a function", cP = NaN, eV = "[object Symbol]", tV = /^\s+|\s+$/g, nV = /^[-+]0x[0-9a-f]+$/i, rV = /^0b[01]+$/i, iV = /^0o[0-7]+$/i, aV = parseInt, oV = typeof yv == "object" && yv && yv.Object === Object && yv, sV = typeof self == "object" && self && self.Object === Object && self, lV = oV || sV || Function("return this")(), uV = Object.prototype, cV = uV.toString, dV = Math.max, fV = Math.min, CT = function() {
  return lV.Date.now();
};
function pV(r, t, i) {
  var o, u, d, c, m, g, b = 0, C = !1, E = !1, x = !0;
  if (typeof r != "function")
    throw new TypeError(Zz);
  t = dP(t) || 0, fE(i) && (C = !!i.leading, E = "maxWait" in i, d = E ? dV(dP(i.maxWait) || 0, t) : d, x = "trailing" in i ? !!i.trailing : x);
  function O(K) {
    var te = o, he = u;
    return o = u = void 0, b = K, c = r.apply(he, te), c;
  }
  function N(K) {
    return b = K, m = setTimeout(U, t), C ? O(K) : c;
  }
  function M(K) {
    var te = K - g, he = K - b, pe = t - te;
    return E ? fV(pe, d - he) : pe;
  }
  function I(K) {
    var te = K - g, he = K - b;
    return g === void 0 || te >= t || te < 0 || E && he >= d;
  }
  function U() {
    var K = CT();
    if (I(K))
      return ae(K);
    m = setTimeout(U, M(K));
  }
  function ae(K) {
    return m = void 0, x && o ? O(K) : (o = u = void 0, c);
  }
  function Z() {
    m !== void 0 && clearTimeout(m), b = 0, o = g = u = m = void 0;
  }
  function B() {
    return m === void 0 ? c : ae(CT());
  }
  function F() {
    var K = CT(), te = I(K);
    if (o = arguments, u = this, g = K, te) {
      if (m === void 0)
        return N(g);
      if (E)
        return m = setTimeout(U, t), O(g);
    }
    return m === void 0 && (m = setTimeout(U, t)), c;
  }
  return F.cancel = Z, F.flush = B, F;
}
function fE(r) {
  var t = typeof r;
  return !!r && (t == "object" || t == "function");
}
function hV(r) {
  return !!r && typeof r == "object";
}
function mV(r) {
  return typeof r == "symbol" || hV(r) && cV.call(r) == eV;
}
function dP(r) {
  if (typeof r == "number")
    return r;
  if (mV(r))
    return cP;
  if (fE(r)) {
    var t = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = fE(t) ? t + "" : t;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = r.replace(tV, "");
  var i = rV.test(r);
  return i || iV.test(r) ? aV(r.slice(2), i ? 2 : 8) : nV.test(r) ? cP : +r;
}
var vV = pV;
const fP = /* @__PURE__ */ dO(vV);
function gV(r) {
  const t = R.useRef(r);
  t.current = r, R.useEffect(
    () => () => {
      t.current();
    },
    []
  );
}
function yV(r, t = 500, i) {
  const o = R.useRef();
  gV(() => {
    o.current && o.current.cancel();
  });
  const u = R.useMemo(() => {
    const d = fP(r, t, i), c = (...m) => d(...m);
    return c.cancel = () => {
      d.cancel();
    }, c.isPending = () => !!o.current, c.flush = () => d.flush(), c;
  }, [r, t, i]);
  return R.useEffect(() => {
    o.current = fP(r, t, i);
  }, [r, t, i]), u;
}
function bV(r, t, i) {
  const o = (b, C) => b === C, u = r instanceof Function ? r() : r, [d, c] = R.useState(u), m = R.useRef(u), g = yV(
    c,
    t,
    i
  );
  return o(m.current, u) || (g(u), m.current = u), [d, g];
}
function SV({
  threshold: r = 0,
  root: t = null,
  rootMargin: i = "0%",
  freezeOnceVisible: o = !1,
  initialIsIntersecting: u = !1,
  onChange: d
} = {}) {
  var c;
  const [m, g] = R.useState(null), [b, C] = R.useState(() => ({
    isIntersecting: u,
    entry: void 0
  })), E = R.useRef();
  E.current = d;
  const x = ((c = b.entry) == null ? void 0 : c.isIntersecting) && o;
  R.useEffect(() => {
    if (!m || !("IntersectionObserver" in window) || x)
      return;
    let M;
    const I = new IntersectionObserver(
      (U) => {
        const ae = Array.isArray(I.thresholds) ? I.thresholds : [I.thresholds];
        U.forEach((Z) => {
          const B = Z.isIntersecting && ae.some((F) => Z.intersectionRatio >= F);
          C({ isIntersecting: B, entry: Z }), E.current && E.current(B, Z), B && o && M && (M(), M = void 0);
        });
      },
      { threshold: r, root: t, rootMargin: i }
    );
    return I.observe(m), () => {
      I.disconnect();
    };
  }, [
    m,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    JSON.stringify(r),
    t,
    i,
    x,
    o
  ]);
  const O = R.useRef(null);
  R.useEffect(() => {
    var M;
    !m && (M = b.entry) != null && M.target && !o && !x && O.current !== b.entry.target && (O.current = b.entry.target, C({ isIntersecting: u, entry: void 0 }));
  }, [m, b.entry, o, x, u]);
  const N = [
    g,
    !!b.isIntersecting,
    b.entry
  ];
  return N.ref = N[0], N.isIntersecting = N[1], N.entry = N[2], N;
}
const CV = /* @__PURE__ */ R.forwardRef(
  function({
    onTrackClick: r,
    onClick: t,
    onSubscriptionStatusChanged: i,
    trackRef: o,
    manageSubscription: u,
    ...d
  }, c) {
    const m = nh(o), g = R.useRef(null);
    R.useImperativeHandle(c, () => g.current);
    const b = SV({ root: g.current }), [C] = bV(b, 3e3);
    R.useEffect(() => {
      u && m.publication instanceof xv && (C == null ? void 0 : C.isIntersecting) === !1 && (b == null ? void 0 : b.isIntersecting) === !1 && m.publication.setSubscribed(!1);
    }, [C, m, u]), R.useEffect(() => {
      u && m.publication instanceof xv && (b == null ? void 0 : b.isIntersecting) === !0 && m.publication.setSubscribed(!0);
    }, [b, m, u]);
    const {
      elementProps: E,
      publication: x,
      isSubscribed: O
    } = lM(m, {
      element: g,
      props: d
    });
    R.useEffect(() => {
      i == null || i(!!O);
    }, [O, i]);
    const N = (M) => {
      t == null || t(M), r == null || r({ participant: m == null ? void 0 : m.participant, track: x });
    };
    return /* @__PURE__ */ R.createElement("video", { ref: g, ...E, muted: !0, onClick: N });
  }
), uM = /* @__PURE__ */ R.forwardRef(
  function({ trackRef: r, onSubscriptionStatusChanged: t, volume: i, muted: o, ...u }, d) {
    const c = nh(r), m = R.useRef(null);
    R.useImperativeHandle(d, () => m.current);
    const {
      elementProps: g,
      isSubscribed: b,
      track: C,
      publication: E
    } = lM(c, {
      element: m,
      props: u
    });
    return R.useEffect(() => {
      t == null || t(!!b);
    }, [b, t]), R.useEffect(() => {
      C === void 0 || i === void 0 || (C instanceof Hp ? C.setVolume(i) : Ht.warn("Volume can only be set on remote audio tracks."));
    }, [i, C]), R.useEffect(() => {
      E === void 0 || o === void 0 || (E instanceof xv ? E.setEnabled(!o) : Ht.warn("Can only call setEnabled on remote track publications."));
    }, [o, E, C]), /* @__PURE__ */ R.createElement("audio", { ref: m, ...g });
  }
);
function kV(r) {
  const t = !!WO();
  return r.participant && !t ? /* @__PURE__ */ R.createElement(qO.Provider, { value: r.participant }, r.children) : /* @__PURE__ */ R.createElement(R.Fragment, null, r.children);
}
function TV(r) {
  const t = !!Rb();
  return r.trackRef && !t ? /* @__PURE__ */ R.createElement($E.Provider, { value: r.trackRef }, r.children) : /* @__PURE__ */ R.createElement(R.Fragment, null, r.children);
}
const pE = /* @__PURE__ */ R.forwardRef(
  function({
    trackRef: r,
    children: t,
    onParticipantClick: i,
    disableSpeakingIndicator: o,
    ...u
  }, d) {
    var c, m;
    const g = nh(r), { elementProps: b } = Sz({
      htmlProps: u,
      disableSpeakingIndicator: o,
      onParticipantClick: i,
      trackRef: g
    }), C = Oz(g.participant), E = Lv(), x = (c = Z6()) == null ? void 0 : c.autoSubscription, O = R.useCallback(
      (N) => {
        g.source && !N && E && E.pin.dispatch && LO(g, E.pin.state) && E.pin.dispatch({ msg: "clear_pin" });
      },
      [g, E]
    );
    return /* @__PURE__ */ R.createElement("div", { ref: d, style: { position: "relative" }, ...b }, /* @__PURE__ */ R.createElement(TV, { trackRef: g }, /* @__PURE__ */ R.createElement(kV, { participant: g.participant }, t ?? /* @__PURE__ */ R.createElement(R.Fragment, null, Ua(g) && (((m = g.publication) == null ? void 0 : m.kind) === "video" || g.source === ue.Source.Camera || g.source === ue.Source.ScreenShare) ? /* @__PURE__ */ R.createElement(
      CV,
      {
        trackRef: g,
        onSubscriptionStatusChanged: O,
        manageSubscription: x
      }
    ) : Ua(g) && /* @__PURE__ */ R.createElement(
      uM,
      {
        trackRef: g,
        onSubscriptionStatusChanged: O
      }
    ), /* @__PURE__ */ R.createElement("div", { className: "lk-participant-placeholder" }, /* @__PURE__ */ R.createElement(sM, null)), /* @__PURE__ */ R.createElement("div", { className: "lk-participant-metadata" }, /* @__PURE__ */ R.createElement("div", { className: "lk-participant-metadata-item" }, g.source === ue.Source.Camera ? /* @__PURE__ */ R.createElement(R.Fragment, null, C && /* @__PURE__ */ R.createElement(jz, { style: { marginRight: "0.25rem" } }), /* @__PURE__ */ R.createElement(
      Xz,
      {
        trackRef: {
          participant: g.participant,
          source: ue.Source.Microphone
        },
        show: "muted"
      }
    ), /* @__PURE__ */ R.createElement(uP, null)) : /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement(aM, { style: { marginRight: "0.25rem" } }), /* @__PURE__ */ R.createElement(uP, null, "'s screen"))), /* @__PURE__ */ R.createElement(Jz, { className: "lk-participant-metadata-item" }))), /* @__PURE__ */ R.createElement(Yz, { trackRef: g }))));
  }
);
function EV(r) {
  const t = Zl(r, { className: "lk-focus-layout" });
  return /* @__PURE__ */ R.createElement("div", { ...t }, r.children);
}
function pP({ trackRef: r, ...t }) {
  return /* @__PURE__ */ R.createElement(pE, { trackRef: r, ...t });
}
function cM({ tracks: r, ...t }) {
  return /* @__PURE__ */ R.createElement(R.Fragment, null, r.map((i) => /* @__PURE__ */ R.createElement(
    $E.Provider,
    {
      value: i,
      key: $i(i)
    },
    QO(t.children)
  )));
}
function wV({
  totalPageCount: r,
  nextPage: t,
  prevPage: i,
  currentPage: o,
  pagesContainer: u
}) {
  const [d, c] = R.useState(!1);
  return R.useEffect(() => {
    let m;
    return u && (m = V6(u.current, 2e3).subscribe(
      c
    )), () => {
      m && m.unsubscribe();
    };
  }, [u]), /* @__PURE__ */ R.createElement("div", { className: "lk-pagination-control", "data-lk-user-interaction": d }, /* @__PURE__ */ R.createElement("button", { className: "lk-button", onClick: i }, /* @__PURE__ */ R.createElement(sP, null)), /* @__PURE__ */ R.createElement("span", { className: "lk-pagination-count" }, `${o} of ${r}`), /* @__PURE__ */ R.createElement("button", { className: "lk-button", onClick: t }, /* @__PURE__ */ R.createElement(sP, null)));
}
const RV = /* @__PURE__ */ R.forwardRef(
  function({ totalPageCount: r, currentPage: t }, i) {
    const o = new Array(r).fill("").map((u, d) => d + 1 === t ? /* @__PURE__ */ R.createElement("span", { "data-lk-active": !0, key: d }) : /* @__PURE__ */ R.createElement("span", { key: d }));
    return /* @__PURE__ */ R.createElement("div", { ref: i, className: "lk-pagination-indicator" }, o);
  }
);
function _V({ tracks: r, ...t }) {
  const i = R.createRef(), o = R.useMemo(
    () => Zl(t, { className: "lk-grid-layout" }),
    [t]
  ), { layout: u } = mz(i, r.length), d = bz(u.maxTiles, r);
  return Ez(i, {
    onLeftSwipe: d.nextPage,
    onRightSwipe: d.prevPage
  }), /* @__PURE__ */ R.createElement("div", { ref: i, "data-lk-pagination": d.totalPageCount > 1, ...o }, /* @__PURE__ */ R.createElement(cM, { tracks: d.tracks }, t.children), r.length > u.maxTiles && /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement(
    RV,
    {
      totalPageCount: d.totalPageCount,
      currentPage: d.currentPage
    }
  ), /* @__PURE__ */ R.createElement(wV, { pagesContainer: i, ...d })));
}
const xV = 130, PV = 140, DV = 1, dM = 16 / 10, OV = (1 - dM) * -1;
function MV({ tracks: r, orientation: t, ...i }) {
  const o = R.useRef(null), [u, d] = R.useState(0), { width: c, height: m } = XO(o), g = t || (m >= c ? "vertical" : "horizontal"), b = g === "vertical" ? Math.max(c * OV, xV) : Math.max(m * dM, PV), C = Dj(), E = Math.max(g === "vertical" ? (m - C) / b : (c - C) / b, DV);
  let x = Math.round(E);
  Math.abs(E - u) < 0.5 ? x = Math.round(u) : u !== E && d(E);
  const O = ZO(r, x);
  return R.useLayoutEffect(() => {
    o.current && (o.current.dataset.lkOrientation = g, o.current.style.setProperty("--lk-max-visible-tiles", x.toString()));
  }, [x, g]), /* @__PURE__ */ R.createElement("aside", { key: g, className: "lk-carousel", ref: o, ...i }, /* @__PURE__ */ R.createElement(cM, { tracks: O }, i.children));
}
function NV({
  value: r,
  onPinChange: t,
  onWidgetChange: i,
  children: o
}) {
  const u = X6(r);
  return R.useEffect(() => {
    Ht.debug("PinState Updated", { state: u.pin.state }), t && u.pin.state && t(u.pin.state);
  }, [u.pin.state, t]), R.useEffect(() => {
    Ht.debug("Widget Updated", { widgetState: u.widget.state }), i && u.widget.state && i(u.widget.state);
  }, [i, u.widget.state]), /* @__PURE__ */ R.createElement(wb.Provider, { value: u }, o);
}
function LV({ volume: r, muted: t }) {
  const i = eM(
    [ue.Source.Microphone, ue.Source.ScreenShareAudio, ue.Source.Unknown],
    {
      updateOnlyOn: [],
      onlySubscribed: !0
    }
  ).filter((o) => !o.participant.isLocal && o.publication.kind === ue.Kind.Audio);
  return /* @__PURE__ */ R.createElement("div", { style: { display: "none" } }, i.map((o) => /* @__PURE__ */ R.createElement(
    uM,
    {
      key: $i(o),
      trackRef: o,
      volume: r,
      muted: t
    }
  )));
}
function AV(r) {
  const t = R.useMemo(() => Zl(r, { className: "lk-toast" }), [r]);
  return /* @__PURE__ */ R.createElement("div", { ...t }, r.children);
}
function IV(r) {
  const [t, i] = R.useState(void 0), o = xb(r.room);
  return R.useEffect(() => {
    switch (o) {
      case Yt.Reconnecting:
        i(
          /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement(lP, { className: "lk-spinner" }), " Reconnecting")
        );
        break;
      case Yt.Connecting:
        i(
          /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement(lP, { className: "lk-spinner" }), " Connecting")
        );
        break;
      case Yt.Disconnected:
        i(/* @__PURE__ */ R.createElement(R.Fragment, null, "Disconnected"));
        break;
      default:
        i(void 0);
        break;
    }
  }, [o]), t ? /* @__PURE__ */ R.createElement(AV, { className: "lk-toast-connection-state" }, t) : /* @__PURE__ */ R.createElement(R.Fragment, null);
}
const UV = /* @__PURE__ */ R.forwardRef(
  function({ entry: r, hideName: t = !1, hideTimestamp: i = !1, messageFormatter: o, ...u }, d) {
    var c, m, g;
    const b = R.useMemo(() => o ? o(r.message) : r.message, [r.message, o]), C = !!r.editTimestamp, E = new Date(r.timestamp), x = navigator ? navigator.language : "en-US";
    return /* @__PURE__ */ R.createElement(
      "li",
      {
        ref: d,
        className: "lk-chat-entry",
        title: E.toLocaleTimeString(x, { timeStyle: "full" }),
        "data-lk-message-origin": (c = r.from) != null && c.isLocal ? "local" : "remote",
        ...u
      },
      (!i || !t || C) && /* @__PURE__ */ R.createElement("span", { className: "lk-meta-data" }, !t && /* @__PURE__ */ R.createElement("strong", { className: "lk-participant-name" }, ((m = r.from) == null ? void 0 : m.name) ?? ((g = r.from) == null ? void 0 : g.identity)), (!i || C) && /* @__PURE__ */ R.createElement("span", { className: "lk-timestamp" }, C && "edited ", E.toLocaleTimeString(x, { timeStyle: "short" }))),
      /* @__PURE__ */ R.createElement("span", { className: "lk-message-body" }, b)
    );
  }
);
function FV(r) {
  return Ij(r, Aj()).map((t, i) => {
    if (typeof t == "string")
      return t;
    {
      const o = t.content.toString(), u = t.type === "url" ? /^http(s?):\/\//.test(o) ? o : `https://${o}` : `mailto:${o}`;
      return /* @__PURE__ */ R.createElement("a", { className: "lk-chat-link", key: i, href: u, target: "_blank", rel: "noreferrer" }, o);
    }
  });
}
function jV({
  messageFormatter: r,
  messageDecoder: t,
  messageEncoder: i,
  channelTopic: o,
  ...u
}) {
  const d = R.useRef(null), c = R.useRef(null), m = R.useMemo(() => ({ messageDecoder: t, messageEncoder: i, channelTopic: o }), [t, i, o]), { send: g, chatMessages: b, isSending: C } = Dz(m), E = Lv(), x = R.useRef(0);
  async function O(N) {
    N.preventDefault(), d.current && d.current.value.trim() !== "" && g && (await g(d.current.value), d.current.value = "", d.current.focus());
  }
  return R.useEffect(() => {
    var N;
    c && ((N = c.current) == null || N.scrollTo({ top: c.current.scrollHeight }));
  }, [c, b]), R.useEffect(() => {
    var N, M, I, U, ae;
    if (!E || b.length === 0)
      return;
    if ((N = E.widget.state) != null && N.showChat && b.length > 0 && x.current !== ((M = b[b.length - 1]) == null ? void 0 : M.timestamp)) {
      x.current = (I = b[b.length - 1]) == null ? void 0 : I.timestamp;
      return;
    }
    const Z = b.filter(
      (F) => !x.current || F.timestamp > x.current
    ).length, { widget: B } = E;
    Z > 0 && ((U = B.state) == null ? void 0 : U.unreadMessages) !== Z && ((ae = B.dispatch) == null || ae.call(B, { msg: "unread_msg", count: Z }));
  }, [b, E == null ? void 0 : E.widget]), /* @__PURE__ */ R.createElement("div", { ...u, className: "lk-chat" }, /* @__PURE__ */ R.createElement("div", { className: "lk-chat-header" }, "Messages", E && /* @__PURE__ */ R.createElement(nM, { className: "lk-close-button" }, /* @__PURE__ */ R.createElement(Iz, null))), /* @__PURE__ */ R.createElement("ul", { className: "lk-list lk-chat-messages", ref: c }, u.children ? b.map(
    (N, M) => QO(u.children, {
      entry: N,
      key: N.id ?? M,
      messageFormatter: r
    })
  ) : b.map((N, M, I) => {
    const U = M >= 1 && I[M - 1].from === N.from, ae = M >= 1 && N.timestamp - I[M - 1].timestamp < 6e4;
    return /* @__PURE__ */ R.createElement(
      UV,
      {
        key: N.id ?? M,
        hideName: U,
        hideTimestamp: U === !1 ? !1 : ae,
        entry: N,
        messageFormatter: r
      }
    );
  })), /* @__PURE__ */ R.createElement("form", { className: "lk-chat-form", onSubmit: O }, /* @__PURE__ */ R.createElement(
    "input",
    {
      className: "lk-form-control lk-chat-form-input",
      disabled: C,
      ref: d,
      type: "text",
      placeholder: "Enter a message...",
      onInput: (N) => N.stopPropagation(),
      onKeyDown: (N) => N.stopPropagation(),
      onKeyUp: (N) => N.stopPropagation()
    }
  ), /* @__PURE__ */ R.createElement("button", { type: "submit", className: "lk-button lk-chat-form-button", disabled: C }, "Send")));
}
function ub({
  kind: r,
  initialSelection: t,
  onActiveDeviceChange: i,
  tracks: o,
  requestPermissions: u = !1,
  ...d
}) {
  const [c, m] = R.useState(!1), [g, b] = R.useState([]), [C, E] = R.useState(!0), [x, O] = R.useState(u), N = (ae, Z) => {
    Ht.debug("handle device change"), m(!1), i == null || i(ae, Z);
  }, M = R.useRef(null), I = R.useRef(null);
  R.useLayoutEffect(() => {
    c && O(!0);
  }, [c]), R.useLayoutEffect(() => {
    M.current && I.current && (g || C) && Nj(M.current, I.current).then(({ x: ae, y: Z }) => {
      I.current && Object.assign(I.current.style, { left: `${ae}px`, top: `${Z}px` });
    }), E(!1);
  }, [M, I, g, C]);
  const U = R.useCallback(
    (ae) => {
      I.current && ae.target !== M.current && c && Lj(I.current, ae) && m(!1);
    },
    [c, I, M]
  );
  return R.useEffect(() => (document.addEventListener("click", U), window.addEventListener("resize", () => E(!0)), () => {
    document.removeEventListener("click", U), window.removeEventListener("resize", () => E(!0));
  }), [U, E]), /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement(
    "button",
    {
      className: "lk-button lk-button-menu",
      "aria-pressed": c,
      ...d,
      onClick: () => m(!c),
      ref: M
    },
    d.children
  ), !d.disabled && /* @__PURE__ */ R.createElement(
    "div",
    {
      className: "lk-device-menu",
      ref: I,
      style: { visibility: c ? "visible" : "hidden" }
    },
    r ? /* @__PURE__ */ R.createElement(
      ST,
      {
        initialSelection: t,
        onActiveDeviceChange: (ae) => N(r, ae),
        onDeviceListChange: b,
        kind: r,
        track: o == null ? void 0 : o[r],
        requestPermissions: x
      }
    ) : /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement("div", { className: "lk-device-menu-heading" }, "Audio inputs"), /* @__PURE__ */ R.createElement(
      ST,
      {
        kind: "audioinput",
        onActiveDeviceChange: (ae) => N("audioinput", ae),
        onDeviceListChange: b,
        track: o == null ? void 0 : o.audioinput,
        requestPermissions: x
      }
    ), /* @__PURE__ */ R.createElement("div", { className: "lk-device-menu-heading" }, "Video inputs"), /* @__PURE__ */ R.createElement(
      ST,
      {
        kind: "videoinput",
        onActiveDeviceChange: (ae) => N("videoinput", ae),
        onDeviceListChange: b,
        track: o == null ? void 0 : o.videoinput,
        requestPermissions: x
      }
    ))
  ));
}
function zV() {
  R.useEffect(() => {
    nz();
  }, []);
}
function VV(r, t) {
  const [i, o] = R.useState(), u = R.useMemo(() => new Aa(), []);
  return R.useEffect(() => {
    let d = !1, c = [];
    return u.lock().then(async (m) => {
      try {
        (r.audio || r.video) && (c = await DE(r), d ? c.forEach((g) => g.stop()) : o(c));
      } catch (g) {
        t && g instanceof Error ? t(g) : Ht.error(g);
      } finally {
        m();
      }
    }), () => {
      d = !0, c.forEach((m) => {
        m.stop();
      });
    };
  }, [JSON.stringify(r, JO), t, u]), i;
}
function BV({
  defaults: r = {},
  onValidate: t,
  onSubmit: i,
  onError: o,
  debug: u,
  joinLabel: d = "Join Room",
  micLabel: c = "Microphone",
  camLabel: m = "Camera",
  userLabel: g = "Username",
  persistUserChoices: b = !0,
  videoProcessor: C,
  ...E
}) {
  const [x, O] = R.useState(Ip), N = {
    ...r.audioDeviceId !== void 0 && { audioDeviceId: r.audioDeviceId },
    ...r.videoDeviceId !== void 0 && { videoDeviceId: r.videoDeviceId },
    ...r.audioEnabled !== void 0 && { audioEnabled: r.audioEnabled },
    ...r.videoEnabled !== void 0 && { videoEnabled: r.videoEnabled },
    ...r.username !== void 0 && { username: r.username }
  }, {
    userChoices: M,
    saveAudioInputDeviceId: I,
    saveAudioInputEnabled: U,
    saveVideoInputDeviceId: ae,
    saveVideoInputEnabled: Z,
    saveUsername: B
  } = tM({
    defaults: N,
    preventSave: !b,
    preventLoad: !b
  }), [F, K] = R.useState(M.audioEnabled), [te, he] = R.useState(M.videoEnabled), [pe, ye] = R.useState(
    M.audioDeviceId
  ), [se, Ee] = R.useState(
    M.videoDeviceId
  ), [Ne, Je] = R.useState(M.username);
  R.useEffect(() => {
    U(F);
  }, [F, U]), R.useEffect(() => {
    Z(te);
  }, [te, Z]), R.useEffect(() => {
    I(pe);
  }, [pe, I]), R.useEffect(() => {
    ae(se);
  }, [se, ae]), R.useEffect(() => {
    B(Ne);
  }, [Ne, B]);
  const vt = VV(
    {
      audio: F ? { deviceId: M.audioDeviceId } : !1,
      video: te ? { deviceId: M.videoDeviceId, processor: C } : !1
    },
    o
  ), Ct = R.useRef(null), Me = R.useMemo(
    () => vt == null ? void 0 : vt.filter((Be) => Be.kind === ue.Kind.Video)[0],
    [vt]
  ), Pe = R.useMemo(() => {
    if (Me) {
      const { facingMode: Be } = ZD(Me);
      return Be;
    } else
      return "undefined";
  }, [Me]), Ze = R.useMemo(
    () => vt == null ? void 0 : vt.filter((Be) => Be.kind === ue.Kind.Audio)[0],
    [vt]
  );
  R.useEffect(() => (Ct.current && Me && (Me.unmute(), Me.attach(Ct.current)), () => {
    Me == null || Me.detach();
  }), [Me]);
  const [Ie, Y] = R.useState(), ge = R.useCallback(
    (Be) => typeof t == "function" ? t(Be) : Be.username !== "",
    [t]
  );
  R.useEffect(() => {
    const Be = {
      username: Ne,
      videoEnabled: te,
      videoDeviceId: se,
      audioEnabled: F,
      audioDeviceId: pe
    };
    O(Be), Y(ge(Be));
  }, [Ne, te, ge, F, pe, se]);
  function lt(Be) {
    Be.preventDefault(), ge(x) ? typeof i == "function" && i(x) : Ht.warn("Validation failed with: ", x);
  }
  return zV(), /* @__PURE__ */ R.createElement("div", { className: "lk-prejoin", ...E }, /* @__PURE__ */ R.createElement("div", { className: "lk-video-container" }, Me && /* @__PURE__ */ R.createElement("video", { ref: Ct, width: "1280", height: "720", "data-lk-facing-mode": Pe }), (!Me || !te) && /* @__PURE__ */ R.createElement("div", { className: "lk-camera-off-note" }, /* @__PURE__ */ R.createElement(sM, null))), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group-container" }, /* @__PURE__ */ R.createElement("div", { className: "lk-button-group audio" }, /* @__PURE__ */ R.createElement(
    Ad,
    {
      initialState: F,
      source: ue.Source.Microphone,
      onChange: (Be) => K(Be)
    },
    c
  ), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ R.createElement(
    ub,
    {
      initialSelection: pe,
      kind: "audioinput",
      disabled: !Ze,
      tracks: { audioinput: Ze },
      onActiveDeviceChange: (Be, kt) => ye(kt)
    }
  ))), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group video" }, /* @__PURE__ */ R.createElement(
    Ad,
    {
      initialState: te,
      source: ue.Source.Camera,
      onChange: (Be) => he(Be)
    },
    m
  ), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ R.createElement(
    ub,
    {
      initialSelection: se,
      kind: "videoinput",
      disabled: !Me,
      tracks: { videoinput: Me },
      onActiveDeviceChange: (Be, kt) => Ee(kt)
    }
  )))), /* @__PURE__ */ R.createElement("form", { className: "lk-username-container" }, /* @__PURE__ */ R.createElement(
    "input",
    {
      className: "lk-form-control",
      id: "username",
      name: "username",
      type: "text",
      defaultValue: Ne,
      placeholder: g,
      onChange: (Be) => Je(Be.target.value),
      autoComplete: "off"
    }
  ), /* @__PURE__ */ R.createElement(
    "button",
    {
      className: "lk-button lk-join-button",
      type: "submit",
      onClick: lt,
      disabled: !Ie
    },
    d
  )), u && /* @__PURE__ */ R.createElement(R.Fragment, null, /* @__PURE__ */ R.createElement("strong", null, "User Choices:"), /* @__PURE__ */ R.createElement("ul", { className: "lk-list", style: { overflow: "hidden", maxWidth: "15rem" } }, /* @__PURE__ */ R.createElement("li", null, "Username: ", `${x.username}`), /* @__PURE__ */ R.createElement("li", null, "Video Enabled: ", `${x.videoEnabled}`), /* @__PURE__ */ R.createElement("li", null, "Audio Enabled: ", `${x.audioEnabled}`), /* @__PURE__ */ R.createElement("li", null, "Video Device: ", `${x.videoDeviceId}`), /* @__PURE__ */ R.createElement("li", null, "Audio Device: ", `${x.audioDeviceId}`))));
}
function HV({ props: r }) {
  const { dispatch: t, state: i } = $O().widget, o = "lk-button lk-settings-toggle";
  return { mergedProps: R.useMemo(() => al(r, {
    className: o,
    onClick: () => {
      t && t({ msg: "toggle_settings" });
    },
    "aria-pressed": i != null && i.showSettings ? "true" : "false"
  }), [r, o, t, i]) };
}
const $V = /* @__PURE__ */ R.forwardRef(
  function(r, t) {
    const { mergedProps: i } = HV({ props: r });
    return /* @__PURE__ */ R.createElement("button", { ref: t, ...i }, r.children);
  }
);
function qV({
  variation: r,
  controls: t,
  saveUserChoices: i = !0,
  onDeviceError: o,
  ...u
}) {
  var d;
  const [c, m] = R.useState(!1), g = Lv();
  R.useEffect(() => {
    var pe, ye;
    ((pe = g == null ? void 0 : g.widget.state) == null ? void 0 : pe.showChat) !== void 0 && m((ye = g == null ? void 0 : g.widget.state) == null ? void 0 : ye.showChat);
  }, [(d = g == null ? void 0 : g.widget.state) == null ? void 0 : d.showChat]);
  const b = cz(`(max-width: ${c ? 1e3 : 760}px)`) ? "minimal" : "verbose";
  r ?? (r = b);
  const C = { leave: !0, ...t }, E = gz();
  E ? (C.camera ?? (C.camera = E.canPublish), C.microphone ?? (C.microphone = E.canPublish), C.screenShare ?? (C.screenShare = E.canPublish), C.chat ?? (C.chat = E.canPublishData && (t == null ? void 0 : t.chat))) : (C.camera = !1, C.chat = !1, C.microphone = !1, C.screenShare = !1);
  const x = R.useMemo(
    () => r === "minimal" || r === "verbose",
    [r]
  ), O = R.useMemo(
    () => r === "textOnly" || r === "verbose",
    [r]
  ), N = Bj(), [M, I] = R.useState(!1), U = R.useCallback(
    (pe) => {
      I(pe);
    },
    [I]
  ), ae = Zl({ className: "lk-control-bar" }, u), {
    saveAudioInputEnabled: Z,
    saveVideoInputEnabled: B,
    saveAudioInputDeviceId: F,
    saveVideoInputDeviceId: K
  } = tM({ preventSave: !i }), te = R.useCallback(
    (pe, ye) => ye ? Z(pe) : null,
    [Z]
  ), he = R.useCallback(
    (pe, ye) => ye ? B(pe) : null,
    [B]
  );
  return /* @__PURE__ */ R.createElement("div", { ...ae }, C.microphone && /* @__PURE__ */ R.createElement("div", { className: "lk-button-group" }, /* @__PURE__ */ R.createElement(
    Ad,
    {
      source: ue.Source.Microphone,
      showIcon: x,
      onChange: te,
      onDeviceError: (pe) => o == null ? void 0 : o({ source: ue.Source.Microphone, error: pe })
    },
    O && "Microphone"
  ), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ R.createElement(
    ub,
    {
      kind: "audioinput",
      onActiveDeviceChange: (pe, ye) => F(ye ?? "")
    }
  ))), C.camera && /* @__PURE__ */ R.createElement("div", { className: "lk-button-group" }, /* @__PURE__ */ R.createElement(
    Ad,
    {
      source: ue.Source.Camera,
      showIcon: x,
      onChange: he,
      onDeviceError: (pe) => o == null ? void 0 : o({ source: ue.Source.Camera, error: pe })
    },
    O && "Camera"
  ), /* @__PURE__ */ R.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ R.createElement(
    ub,
    {
      kind: "videoinput",
      onActiveDeviceChange: (pe, ye) => K(ye ?? "")
    }
  ))), C.screenShare && N && /* @__PURE__ */ R.createElement(
    Ad,
    {
      source: ue.Source.ScreenShare,
      captureOptions: { audio: !0, selfBrowserSurface: "include" },
      showIcon: x,
      onChange: U,
      onDeviceError: (pe) => o == null ? void 0 : o({ source: ue.Source.ScreenShare, error: pe })
    },
    O && (M ? "Stop screen share" : "Share screen")
  ), C.chat && /* @__PURE__ */ R.createElement(nM, null, x && /* @__PURE__ */ R.createElement(Uz, null), O && "Chat"), C.settings && /* @__PURE__ */ R.createElement($V, null, x && /* @__PURE__ */ R.createElement(Fz, null), O && "Settings"), C.leave && /* @__PURE__ */ R.createElement(Nz, null, x && /* @__PURE__ */ R.createElement(iM, null), O && "Leave"), /* @__PURE__ */ R.createElement(Kz, null));
}
function WV() {
  const r = Mz(), [t, i] = R.useState(!1), o = cb();
  return R.useEffect(() => {
    r !== t && (i(r), r && o.onRecording());
  }, [r]), /* @__PURE__ */ Mt.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        boxShadow: r ? "red 0px 0px 0px 3px inset" : "none",
        pointerEvents: "none"
      }
    }
  );
}
function GV(r) {
  return FD.includes(r);
}
var fM = { exports: {} };
(function(r) {
  (function(t, i) {
    r.exports ? r.exports = i() : t.log = i();
  })(t5, function() {
    var t = function() {
    }, i = "undefined", o = typeof window !== i && typeof window.navigator !== i && /Trident\/|MSIE /.test(window.navigator.userAgent), u = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], d = {}, c = null;
    function m(M, I) {
      var U = M[I];
      if (typeof U.bind == "function")
        return U.bind(M);
      try {
        return Function.prototype.bind.call(U, M);
      } catch {
        return function() {
          return Function.prototype.apply.apply(U, [M, arguments]);
        };
      }
    }
    function g() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function b(M) {
      return M === "debug" && (M = "log"), typeof console === i ? !1 : M === "trace" && o ? g : console[M] !== void 0 ? m(console, M) : console.log !== void 0 ? m(console, "log") : t;
    }
    function C() {
      for (var M = this.getLevel(), I = 0; I < u.length; I++) {
        var U = u[I];
        this[U] = I < M ? t : this.methodFactory(U, M, this.name);
      }
      if (this.log = this.debug, typeof console === i && M < this.levels.SILENT)
        return "No console available for logging";
    }
    function E(M) {
      return function() {
        typeof console !== i && (C.call(this), this[M].apply(this, arguments));
      };
    }
    function x(M, I, U) {
      return b(M) || E.apply(this, arguments);
    }
    function O(M, I) {
      var U = this, ae, Z, B, F = "loglevel";
      typeof M == "string" ? F += ":" + M : typeof M == "symbol" && (F = void 0);
      function K(se) {
        var Ee = (u[se] || "silent").toUpperCase();
        if (!(typeof window === i || !F)) {
          try {
            window.localStorage[F] = Ee;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(F) + "=" + Ee + ";";
          } catch {
          }
        }
      }
      function te() {
        var se;
        if (!(typeof window === i || !F)) {
          try {
            se = window.localStorage[F];
          } catch {
          }
          if (typeof se === i)
            try {
              var Ee = window.document.cookie, Ne = encodeURIComponent(F), Je = Ee.indexOf(Ne + "=");
              Je !== -1 && (se = /^([^;]+)/.exec(
                Ee.slice(Je + Ne.length + 1)
              )[1]);
            } catch {
            }
          return U.levels[se] === void 0 && (se = void 0), se;
        }
      }
      function he() {
        if (!(typeof window === i || !F)) {
          try {
            window.localStorage.removeItem(F);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(F) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function pe(se) {
        var Ee = se;
        if (typeof Ee == "string" && U.levels[Ee.toUpperCase()] !== void 0 && (Ee = U.levels[Ee.toUpperCase()]), typeof Ee == "number" && Ee >= 0 && Ee <= U.levels.SILENT)
          return Ee;
        throw new TypeError("log.setLevel() called with invalid level: " + se);
      }
      U.name = M, U.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, U.methodFactory = I || x, U.getLevel = function() {
        return B ?? Z ?? ae;
      }, U.setLevel = function(se, Ee) {
        return B = pe(se), Ee !== !1 && K(B), C.call(U);
      }, U.setDefaultLevel = function(se) {
        Z = pe(se), te() || U.setLevel(se, !1);
      }, U.resetLevel = function() {
        B = null, he(), C.call(U);
      }, U.enableAll = function(se) {
        U.setLevel(U.levels.TRACE, se);
      }, U.disableAll = function(se) {
        U.setLevel(U.levels.SILENT, se);
      }, U.rebuild = function() {
        if (c !== U && (ae = pe(c.getLevel())), C.call(U), c === U)
          for (var se in d)
            d[se].rebuild();
      }, ae = pe(
        c ? c.getLevel() : "WARN"
      );
      var ye = te();
      ye != null && (B = pe(ye)), C.call(U);
    }
    c = new O(), c.getLogger = function(I) {
      if (typeof I != "symbol" && typeof I != "string" || I === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var U = d[I];
      return U || (U = d[I] = new O(
        I,
        c.methodFactory
      )), U;
    };
    var N = typeof window !== i ? window.log : void 0;
    return c.noConflict = function() {
      return typeof window !== i && window.log === c && (window.log = N), c;
    }, c.getLoggers = function() {
      return d;
    }, c.default = c, c;
  });
})(fM);
var YV = fM.exports;
const KV = /* @__PURE__ */ mP(YV);
function Gp(r) {
  return typeof r > "u" ? !1 : QV(r) || JV(r);
}
function QV(r) {
  var t;
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && r.hasOwnProperty("track") && typeof ((t = r.publication) == null ? void 0 : t.track) < "u" : !1;
}
function JV(r) {
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && r.hasOwnProperty("publication") && typeof r.publication < "u" : !1;
}
function XV(r) {
  return r ? r.hasOwnProperty("participant") && r.hasOwnProperty("source") && typeof r.publication > "u" : !1;
}
function hP(r) {
  if (typeof r == "string" || typeof r == "number")
    return `${r}`;
  if (XV(r))
    return `${r.participant.identity}_${r.source}_placeholder`;
  if (Gp(r))
    return `${r.participant.identity}_${r.publication.source}_${r.publication.trackSid}`;
  throw new Error(`Can't generate a id for the given track reference: ${r}`);
}
function ZV(r, t) {
  return r === void 0 || t === void 0 ? !1 : Gp(r) && Gp(t) ? r.publication.trackSid === t.publication.trackSid : hP(r) === hP(t);
}
function e9() {
  return typeof document < "u";
}
var t9 = [
  ne.ConnectionStateChanged,
  ne.RoomMetadataChanged,
  ne.ActiveSpeakersChanged,
  ne.ConnectionQualityChanged,
  ne.ParticipantConnected,
  ne.ParticipantDisconnected,
  ne.ParticipantPermissionsChanged,
  ne.ParticipantMetadataChanged,
  ne.ParticipantNameChanged,
  ne.ParticipantAttributesChanged,
  ne.TrackMuted,
  ne.TrackUnmuted,
  ne.TrackPublished,
  ne.TrackUnpublished,
  ne.TrackStreamStateChanged,
  ne.TrackSubscriptionFailed,
  ne.TrackSubscriptionPermissionChanged,
  ne.TrackSubscriptionStatusChanged
];
[
  ...t9,
  ne.LocalTrackPublished,
  ne.LocalTrackUnpublished
];
ce.TrackPublished, ce.TrackUnpublished, ce.TrackMuted, ce.TrackUnmuted, ce.TrackStreamStateChanged, ce.TrackSubscribed, ce.TrackUnsubscribed, ce.TrackSubscriptionPermissionChanged, ce.TrackSubscriptionFailed, ce.LocalTrackPublished, ce.LocalTrackUnpublished;
var n9 = [
  ce.ConnectionQualityChanged,
  ce.IsSpeakingChanged,
  ce.ParticipantMetadataChanged,
  ce.ParticipantPermissionsChanged,
  ce.TrackMuted,
  ce.TrackUnmuted,
  ce.TrackPublished,
  ce.TrackUnpublished,
  ce.TrackStreamStateChanged,
  ce.TrackSubscriptionFailed,
  ce.TrackSubscriptionPermissionChanged,
  ce.TrackSubscriptionStatusChanged
];
[
  ...n9,
  ce.LocalTrackPublished,
  ce.LocalTrackUnpublished
];
var K0 = KV.getLogger("lk-components-js");
K0.setDefaultLevel("WARN");
new TextEncoder();
new TextDecoder();
function r9({
  chatMessageFormatter: r,
  chatMessageDecoder: t,
  chatMessageEncoder: i,
  SettingsComponent: o,
  ...u
}) {
  var ae, Z;
  const {
    miniView: d,
    setMiniView: c,
    onFullScreen: m
    // Add other options you need to use
  } = cb(), [g, b] = R.useState({
    showChat: !1,
    unreadMessages: 0,
    showSettings: !1
  }), C = R.useRef(null), E = Iv(), x = eM(
    [
      { source: ue.Source.Camera, withPlaceholder: !0 },
      { source: ue.Source.ScreenShare, withPlaceholder: !1 }
    ],
    { updateOnlyOn: [ne.ActiveSpeakersChanged], onlySubscribed: !1 }
  ), O = (B) => {
    K0.debug("updating widget state", B), b(B);
  }, N = J6(), M = x.filter(Gp).filter((B) => B.publication.source === ue.Source.ScreenShare), I = (ae = Cz(N)) == null ? void 0 : ae[0], U = x.filter((B) => !ZV(B, I));
  return R.useEffect(() => {
    var B, F, K, te, he, pe;
    if (M.some((ye) => ye.publication.isSubscribed) && C.current === null ? (K0.debug("Auto set screen share focus:", { newScreenShareTrack: M[0] }), (F = (B = N.pin).dispatch) == null || F.call(B, { msg: "set_pin", trackReference: M[0] }), C.current = M[0]) : C.current && !M.some(
      (ye) => {
        var se, Ee;
        return ye.publication.trackSid === ((Ee = (se = C.current) == null ? void 0 : se.publication) == null ? void 0 : Ee.trackSid);
      }
    ) && (K0.debug("Auto clearing screen share focus."), (te = (K = N.pin).dispatch) == null || te.call(K, { msg: "clear_pin" }), C.current = null), I && !Gp(I)) {
      const ye = x.find(
        (se) => se.participant.identity === I.participant.identity && se.source === I.source
      );
      ye !== I && Gp(ye) && ((pe = (he = N.pin).dispatch) == null || pe.call(he, { msg: "set_pin", trackReference: ye }));
    }
  }, [
    M.map((B) => `${B.publication.trackSid}_${B.publication.isSubscribed}`).join(),
    (Z = I == null ? void 0 : I.publication) == null ? void 0 : Z.trackSid,
    x
  ]), R.useEffect(() => {
    var B, F, K, te;
    if (console.log("autoFocusRemoteParticipant", "before remoteParticipantConnected", I, E.remoteParticipants.size), E.remoteParticipants.size > 0 && !I) {
      console.log("autoFocusRemoteParticipant", "after remoteParticipantConnected", I);
      const he = x.find(
        (pe) => !pe.participant.isLocal
        // && 
        //   track.publication && 
        //   track.publication.isSubscribed &&
        //   track.publication.track 
      );
      console.log("autoFocusRemoteParticipant", "remoteTrack", he), he && ((F = (B = N.pin).dispatch) == null || F.call(B, { msg: "set_pin", trackReference: he }), console.log("autoFocusRemoteParticipant", "after set_pin"));
    } else
      E.remoteParticipants.size == 0 && I && ((te = (K = N.pin).dispatch) == null || te.call(K, { msg: "clear_pin" }));
  }, [x, I, E.remoteParticipants]), /* @__PURE__ */ Mt.jsxs("div", { className: `lk-video-conference ${d ? "lk-mini-view" : ""}`, ...u, children: [
    e9() && /* @__PURE__ */ Mt.jsxs(
      NV,
      {
        value: N,
        onWidgetChange: O,
        children: [
          /* @__PURE__ */ Mt.jsx("div", { className: "lk-video-conference-inner", children: d ? /* @__PURE__ */ Mt.jsxs("div", { className: "lk-mini-view-container", children: [
            I && /* @__PURE__ */ Mt.jsx(pP, { trackRef: I }),
            /* @__PURE__ */ Mt.jsxs("div", { className: "lk-mini-view-controls", children: [
              /* @__PURE__ */ Mt.jsx("button", { onClick: () => m(), className: "full-view-mini", children: /* @__PURE__ */ Mt.jsx(rM, {}) }),
              /* @__PURE__ */ Mt.jsx(
                Ad,
                {
                  source: ue.Source.Microphone,
                  showIcon: !0
                }
              ),
              /* @__PURE__ */ Mt.jsx(
                Ad,
                {
                  source: ue.Source.Camera,
                  showIcon: !0
                }
              ),
              /* @__PURE__ */ Mt.jsx("button", { onClick: () => E.disconnect(), className: "leave-mini", children: /* @__PURE__ */ Mt.jsx(iM, {}) })
            ] })
          ] }) : /* @__PURE__ */ Mt.jsxs(Mt.Fragment, { children: [
            I ? /* @__PURE__ */ Mt.jsx("div", { className: "lk-focus-layout-wrapper", children: /* @__PURE__ */ Mt.jsxs(EV, { children: [
              /* @__PURE__ */ Mt.jsx(MV, { tracks: U, children: /* @__PURE__ */ Mt.jsx(pE, {}) }),
              I && /* @__PURE__ */ Mt.jsx(pP, { trackRef: I })
            ] }) }) : /* @__PURE__ */ Mt.jsx("div", { className: "lk-grid-layout-wrapper", children: /* @__PURE__ */ Mt.jsx(_V, { tracks: x, children: /* @__PURE__ */ Mt.jsx(pE, {}) }) }),
            /* @__PURE__ */ Mt.jsx(
              qV,
              {
                controls: {
                  chat: !1,
                  settings: !1,
                  screenShare: !1
                  // Add a new control for mini view
                },
                variation: "minimal"
              }
            )
          ] }) }),
          /* @__PURE__ */ Mt.jsx(
            jV,
            {
              style: { display: g.showChat ? "grid" : "none" },
              messageFormatter: r,
              messageEncoder: i,
              messageDecoder: t
            }
          ),
          o && /* @__PURE__ */ Mt.jsx(
            "div",
            {
              className: "lk-settings-menu-modal",
              style: { display: g.showSettings ? "block" : "none" },
              children: /* @__PURE__ */ Mt.jsx(o, {})
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ Mt.jsx(LV, {}),
    /* @__PURE__ */ Mt.jsx(IV, {})
  ] });
}
function i9() {
  const r = cb(), [t, i] = Na.useState(
    void 0
  ), o = Na.useMemo(() => ({
    username: r.participantName,
    videoEnabled: !0,
    audioEnabled: !0
  }), []), [u, d] = Na.useState(
    void 0
  ), c = Na.useCallback(async (b) => {
    i(b);
    const C = new URL(r.connectionDetailsEndpoint);
    C.searchParams.append("roomName", r.roomName), C.searchParams.append("participantName", b.username), r.region && C.searchParams.append("region", r.region);
    const x = await (await fetch(C.toString())).json();
    d(x), r.onJoin();
  }, []), m = Na.useCallback((b) => console.error(b), []), g = typeof r.codec == "string" && GV(r.codec) ? r.codec : "vp9";
  return /* @__PURE__ */ Mt.jsx("main", { "data-lk-theme": "default", style: { height: "100%" }, children: u === void 0 || t === void 0 ? /* @__PURE__ */ Mt.jsx("div", { style: { display: "grid", placeItems: "center", height: "100%" }, children: /* @__PURE__ */ Mt.jsx(
    BV,
    {
      defaults: o,
      onSubmit: c,
      onError: m,
      persistUserChoices: !1
    }
  ) }) : /* @__PURE__ */ Mt.jsx(
    a9,
    {
      connectionDetails: u,
      userChoices: t,
      options: { codec: g, hq: r.hq }
    }
  ) });
}
function a9(r) {
  const t = cb(), i = typeof window < "u" && I_(location.hash.substring(1)), o = typeof window < "u" && i && new Worker(new URL("/assets/livekit-client.e2ee.worker-17b361fb.js", self.location)), u = !!(i && o), d = new m3(), [c, m] = Na.useState(!1), g = Na.useMemo(() => {
    let N = r.options.codec ? r.options.codec : "vp9";
    return u && (N === "av1" || N === "vp9") && (N = void 0), {
      videoCaptureDefaults: {
        deviceId: r.userChoices.videoDeviceId ?? void 0,
        resolution: r.options.hq ? as.h2160 : as.h720
      },
      publishDefaults: {
        dtx: !1,
        videoSimulcastLayers: r.options.hq ? [as.h1080, as.h720] : [as.h540, as.h216],
        red: !u,
        videoCodec: N
      },
      audioCaptureDefaults: {
        deviceId: r.userChoices.audioDeviceId ?? void 0
      },
      adaptiveStream: { pixelDensity: "screen" },
      dynacast: !0,
      e2ee: u ? {
        keyProvider: d,
        worker: o
      } : void 0
    };
  }, [r.userChoices, r.options.hq, r.options.codec]), b = Na.useMemo(() => new Ql(g), []);
  t.onRoomCreated(b), Na.useEffect(() => {
    u ? d.setKey(I_(i)).then(() => {
      b.setE2EEEnabled(!0).catch((N) => {
        if (N instanceof mb)
          t.onError(N), console.error(N);
        else
          throw N;
      });
    }).then(() => m(!0)) : m(!0);
  }, [u, b, i]);
  const C = Na.useMemo(() => ({
    autoSubscribe: !0
  }), []), E = Na.useCallback(() => t.onLeave(), [t]), x = Na.useCallback((N) => {
    console.error(N), t.onError(N);
  }, []), O = Na.useCallback((N) => {
    console.error(N), t.onError(N);
  }, []);
  return /* @__PURE__ */ Mt.jsx(Mt.Fragment, { children: /* @__PURE__ */ Mt.jsxs(
    az,
    {
      connect: c,
      room: b,
      token: r.connectionDetails.participantToken,
      serverUrl: r.connectionDetails.serverUrl,
      connectOptions: C,
      video: r.userChoices.videoEnabled,
      audio: r.userChoices.audioEnabled,
      onDisconnected: E,
      onEncryptionError: O,
      onError: x,
      children: [
        /* @__PURE__ */ Mt.jsx(
          r9,
          {
            chatMessageFormatter: FV
          }
        ),
        /* @__PURE__ */ Mt.jsx(WV, {})
      ]
    }
  ) });
}
function o9(r, t) {
  t = { ...d5, ...t }, vv.createRoot(r).render(
    /* @__PURE__ */ Mt.jsx(Na.StrictMode, { children: /* @__PURE__ */ Mt.jsx(p5, { initialOptions: t, children: /* @__PURE__ */ Mt.jsx(i9, {}) }) })
  );
}
const f9 = {
  initialize: o9,
  toggleMinView: f5
};
export {
  f9 as default
};
